{"entries":[{"timestamp":1749253577065,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":404,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":18,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":24,"length1":108,"diffs":[[1,"    \"description\": \"\",\n"]]},{"start1":176,"length1":43,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":205,"length1":51,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"turtle.ts","value":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://arcade.makecode.com/blocks/custom\n*/\n\n// Enum para facilitar a escolha da cor da caneta (opcional, mas bom para blocos)\nenum TurtlePenColors {\n    //% block=preto\n    Black = 1,\n    //% block=branco\n    White = 15,\n    //% block=vermelho\n    Red = 2,\n    //% block=azul\n    Blue = 8\n    // Adicione mais cores conforme o índice de cores do Arcade\n}\n\n// Define um namespace para sua extensão\n// Isso ajuda a evitar conflitos de nome com outras extensões ou o código do usuário\n// O comentário \"//% color=#0078D7 icon=\"\\uf188\"\" define a cor e o ícone da categoria de blocos\n// \\uf188 é um código de ícone (ex: um círculo, pode procurar em Font Awesome)\n// Você pode usar um ícone de tartaruga se encontrar um código unicode adequado ou usar uma imagem (mais avançado)\n\n/**\n * Blocos para simular gráficos Turtle.\n */\n//% weight=100 color=#0078D7 icon=\"\\uf14b\" block=\"Tartaruga\"\nnamespace turtle {\n    let currentX: number = screen.width / 2;\n    let currentY: number = screen.height / 2;\n    let currentAngle: number = 0; // 0 graus para a direita, 90 para cima (convenção do Arcade)\n    let penActive: boolean = true;\n    let penColor: number = 1; // Cor padrão (preto no Arcade)\n    let turtleSprite: Sprite = null; // Sprite opcional para visualizar a tartaruga\n\n    /**\n     * Inicializa a tartaruga, opcionalmente mostrando um sprite.\n     * @param showTurtleSprite se verdadeiro, mostra um sprite para a tartaruga, eg: true\n     */\n    //% blockId=\"turtle_init\" block=\"iniciar tartaruga || mostrar sprite %showTurtleSprite\"\n    //% showTurtleSprite.defl=false\n    //% group=\"Configuração\"\n    export function init(showTurtleSprite?: boolean): void {\n        currentX = screen.width / 2;\n        currentY = screen.height / 2;\n        currentAngle = 0; // Apontando para a direita\n        penActive = true;\n        penColor = 1; // Preto\n        screen.fill(0); // Limpa a tela com cor de fundo (ex: transparente ou outra)\n\n        if (showTurtleSprite) {\n            if (turtleSprite) {\n                turtleSprite.destroy();\n            }\n            // Crie uma imagem simples para a tartaruga (ex: um triângulo)\n            const turtleImg = img`\n                . . . . . . . .\n                . . . f . . . .\n                . . f f f . . .\n                . f f f f f . .\n                f f f f f f f .\n                . . . f . . . .\n                . . . f . . . .\n                . . . . . . . .\n            `;\n            turtleSprite = sprites.create(turtleImg, SpriteKind.Player); // Ou um novo SpriteKind\n            turtleSprite.setFlag(SpriteFlag.Ghost, true); // Para não interagir com física\n            updateTurtleSprite();\n        } else if (turtleSprite) {\n            turtleSprite.destroy();\n            turtleSprite = null;\n        }\n    }\n\n    function updateTurtleSprite(): void {\n        if (turtleSprite) {\n            turtleSprite.setPosition(currentX, currentY);\n            // A rotação de sprites no Arcade pode ser diferente da sua currentAngle.\n            // image.rotate() ou transformções podem ser necessárias se quiser rotação visual.\n            // Para simplificar, vamos apenas posicionar.\n        }\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"}]},{"timestamp":1749254175166,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":915,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"turtle_init\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"showTurtleSprite\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":28,"diffs":[[1,""]]},{"start1":18,"length1":31,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":331,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":3244,"length1":121,"diffs":[[1,"     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n"]]},{"start1":3340,"length1":653,"diffs":[[1,"    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n"]]},{"start1":3477,"length1":3146,"diffs":[[1,""]]}]}]},{"timestamp":1749254734852,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":978,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"gamesetbackgroundcolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">9</field></shadow></value><next><block type=\"turtle_init\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"showTurtleSprite\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_forward\"><value name=\"steps\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"number_slider\"></shadow><block type=\"math_number\"><field name=\"NUM\">10</field></block></value></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":46,"length1":39,"diffs":[[1,"pause(1000)\n"]]}]}]},{"timestamp":1749304215690,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":331,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1749304399429,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":4337,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"gamesetbackgroundcolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">9</field></shadow></value><next><block type=\"turtle_init\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"showTurtleSprite\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><next><block type=\"turtle_set_pen_color\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">4</field></shadow></value><next><block type=\"turtle_pen_down\"><next><block type=\"turtle_forward\"><value name=\"steps\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"number_slider\"></shadow><block type=\"math_number\"><field name=\"NUM\">10</field></block></value></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1081,"diffs":[[1,"scene.setBackgroundColor(9)\nturtle.init(true)\nturtle.setPenColor(4)\nturtle.penDown()\nturtle.forward(10)\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":0,"length1":335,"diffs":[[1,""]]},{"start1":1,"length1":103,"diffs":[[1,"/**\n* Use this file to define custom functions and blocks.\n* Read more at https://arcade.makecode.com/blocks/custom\n*/\n"]]},{"start1":121,"length1":200,"diffs":[[1,"// Enum para facilitar a escolha da cor da caneta (opcional, mas bom para blocos)\nenum TurtlePenColors {\n    //% block=preto\n    Black = 1,\n    //% block=branco\n    White = 15,\n    //% block=vermelho\n    Red = 2,\n    //% block=azul\n    Blue = 8\n    // Adicione mais cores conforme o índice de cores do Arcade\n}\n"]]},{"start1":433,"length1":186,"diffs":[[1,"// Define um namespace para sua extensão\n// Isso ajuda a evitar conflitos de nome com outras extensões ou o código do usuário\n// O comentário \"//% color=#0078D7 icon=\"\\uf188\"\" define a cor e o ícone da categoria de blocos\n// \\uf188 é um código de ícone (ex: um círculo, pode procurar em Font Awesome)\n// Você pode usar um ícone de tartaruga se encontrar um código unicode adequado ou usar uma imagem (mais avançado)\n"]]},{"start1":850,"length1":142,"diffs":[[1,"/**\n * Blocos para simular gráficos Turtle.\n */\n//% weight=100 color=#0078D7 icon=\"\\uf14b\" block=\"Tartaruga\"\nnamespace turtle {\n    let currentX: number = screen.width / 2;\n    let currentY: number = screen.height / 2;\n    let currentAngle: number = 0; // 0 graus para a direita, 90 para cima (convenção do Arcade)\n    let penActive: boolean = true;\n    let penColor: number = 1; // Cor padrão (preto no Arcade)\n    let turtleSprite: Sprite = null; // Sprite opcional para visualizar a tartaruga\n"]]},{"start1":1347,"length1":167,"diffs":[[1,"    /**\n     * Inicializa a tartaruga, opcionalmente mostrando um sprite.\n     * @param showTurtleSprite se verdadeiro, mostra um sprite para a tartaruga, eg: true\n     */\n    //% blockId=\"turtle_init\" block=\"iniciar tartaruga || mostrar sprite %showTurtleSprite\"\n    //% showTurtleSprite.defl=false\n    //% group=\"Configuração\"\n    export function init(showTurtleSprite?: boolean): void {\n        currentX = screen.width / 2;\n        currentY = screen.height / 2;\n        currentAngle = 0; // Apontando para a direita\n        penActive = true;\n        penColor = 1; // Preto\n        screen.fill(0); // Limpa a tela com cor de fundo (ex: transparente ou outra)\n"]]},{"start1":2009,"length1":4251,"diffs":[[1,"        if (showTurtleSprite) {\n            if (turtleSprite) {\n                turtleSprite.destroy();\n            }\n            // Crie uma imagem simples para a tartaruga (ex: um triângulo)\n            const turtleImg = img`\n                . . . . . . . .\n                . . . f . . . .\n                . . f f f . . .\n                . f f f f f . .\n                f f f f f f f .\n                . . . f . . . .\n                . . . f . . . .\n                . . . . . . . .\n            `;\n            turtleSprite = sprites.create(turtleImg, SpriteKind.Player); // Ou um novo SpriteKind\n            turtleSprite.setFlag(SpriteFlag.Ghost, true); // Para não interagir com física\n            updateTurtleSprite();\n        } else if (turtleSprite) {\n            turtleSprite.destroy();\n            turtleSprite = null;\n"]]},{"start1":2845,"length1":73,"diffs":[[1,""]]},{"start1":2852,"length1":158,"diffs":[[1,"    function updateTurtleSprite(): void {\n"]]},{"start1":2922,"length1":36,"diffs":[[1,"            turtleSprite.setPosition(currentX, currentY);\n            // A rotação de sprites no Arcade pode ser diferente da sua currentAngle.\n            // image.rotate() ou transformções podem ser necessárias se quiser rotação visual.\n            // Para simplificar, vamos apenas posicionar.\n"]]},{"start1":3229,"length1":689,"diffs":[[1,""]]},{"start1":3236,"length1":190,"diffs":[[1,"    /**\n     * Move a tartaruga para frente pela distância especificada.\n     * @param steps número de pixels para mover, eg: 50\n     */\n    //% blockId=\"turtle_forward\" block=\"tartaruga avançar %steps passos\"\n    //% steps.shadow=\"number_slider\" steps.min=0 steps.max=100 steps.defl=10\n    //% group=\"Movimento\"\n    export function forward(steps: number): void {\n        const rad = currentAngle * Math.PI / 180;\n        const prevX = currentX;\n        const prevY = currentY;\n"]]},{"start1":3715,"length1":98,"diffs":[[1,"        currentX += steps * Math.cos(rad);\n        currentY += steps * Math.sin(rad); // No Arcade, Y positivo é para baixo\n"]]},{"start1":3840,"length1":1453,"diffs":[[1,"        if (penActive) {\n            screen.drawLine(Math.round(prevX), Math.round(prevY), Math.round(currentX), Math.round(currentY), penColor);\n"]]},{"start1":3996,"length1":123,"diffs":[[1,"        updateTurtleSprite();\n"]]},{"start1":4033,"length1":239,"diffs":[[1,"    /**\n     * Gira a tartaruga para a direita pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_right\" block=\"tartaruga virar à direita %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function right(angle: number): void {\n        currentAngle = (currentAngle + angle) % 360;\n        updateTurtleSprite();\n"]]},{"start1":4479,"length1":251,"diffs":[[1,"    /**\n     * Gira a tartaruga para a esquerda pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_left\" block=\"tartaruga virar à esquerda %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function left(angle: number): void {\n        currentAngle = (currentAngle - angle + 360) % 360;\n        updateTurtleSprite();\n"]]},{"start1":4931,"length1":321,"diffs":[[1,"    /**\n     * Levanta a caneta da tartaruga (para de desenhar).\n     */\n    //% blockId=\"turtle_pen_up\" block=\"tartaruga levantar caneta\"\n    //% group=\"Caneta\"\n"]]},{"start1":5129,"length1":31,"diffs":[[1,"        penActive = false;\n"]]},{"start1":5163,"length1":62,"diffs":[[1,"    /**\n     * Abaixa a caneta da tartaruga (começa a desenhar).\n     */\n    //% blockId=\"turtle_pen_down\" block=\"tartaruga abaixar caneta\"\n    //% group=\"Caneta\"\n"]]},{"start1":5364,"length1":30,"diffs":[[1,"        penActive = true;\n"]]},{"start1":5397,"length1":160,"diffs":[[1,"    /**\n     * Define a cor da caneta da tartaruga.\n     * @param color cor para usar, eg: TurtlePenColors.Red\n     */\n    //% blockId=\"turtle_set_pen_color\" block=\"tartaruga definir cor da caneta para %color\"\n    //% color.shadow=\"colorindexpicker\" color.defl=1\n    //% group=\"Caneta\"\n    export function setPenColor(color: number): void {\n        penColor = color;\n"]]},{"start1":5771,"length1":162,"diffs":[[1,"    /**\n     * Move a tartaruga para uma posição absoluta (x, y) sem desenhar uma linha.\n     * @param x coordenada x, eg: 80\n     * @param y coordenada y, eg: 60\n     */\n    //% blockId=\"turtle_go_to\" block=\"tartaruga ir para x %x y %y\"\n    //% x.shadow=\"position\"\n    //% y.shadow=\"position\"\n    //% group=\"Posição\"\n    export function goTo(x: number, y: number): void {\n        const wasPenActive = penActive;\n        penActive = false; // Temporariamente levanta a caneta para mover\n        currentX = x;\n        currentY = y;\n        updateTurtleSprite();\n        penActive = wasPenActive; // Restaura o estado da caneta\n"]]},{"start1":6404,"length1":334,"diffs":[[1,"    /**\n     * Define a direção absoluta da tartaruga.\n     * @param angle ângulo em graus (0 para direita), eg: 0\n     */\n    //% blockId=\"turtle_set_heading\" block=\"tartaruga definir direção para %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=359 angle.defl=0\n    //% group=\"Posição\"\n    export function setHeading(angle: number): void {\n        currentAngle = angle % 360;\n        updateTurtleSprite();\n"]]},{"start1":6842,"length1":0,"diffs":[[1,"\n    /**\n     * Limpa a tela e reposiciona a tartaruga no centro.\n     */\n    //% blockId=\"turtle_clear\" block=\"tartaruga limpar tela\"\n    //% group=\"Configuração\"\n    export function clear(): void {\n        screen.fill(0); // Ou a cor de fundo que você preferir\n        init(turtleSprite !== null); // Reinicializa para o centro\n    }\n"]]}]}]},{"timestamp":1749304924017,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1726,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"!GU_s5^D*14Xse80)09m\">tartarugaImg</variable></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"variables_set\"><field name=\"VAR\" id=\"!GU_s5^D*14Xse80)09m\">tartarugaImg</field><comment pinned=\"false\" h=\"80\" w=\"160\">Em main.ts (JavaScript)\nDesenhe uma imagem simples para a tartaruga</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"screen_image_picker\"><field name=\"img\">img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . 5 5 5 . . . . . . . \n. . . . . 5 5 5 5 5 . . . . . . \n. . . . 5 5 5 5 5 5 5 . . . . . \n. . . . f f f f f f f . . . . . \n. . . . 5 5 5 5 5 5 5 . . . . . \n. . . . . 5 5 5 5 5 . . . . . . \n. . . . . . 5 5 5 . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`</field><data>{\"commentRefs\":[],\"fieldData\":{\"img\":null}}</data></block></value><next><block type=\"myTurtle_start\"><value name=\"img\"><shadow type=\"screen_image_picker\"><field name=\"img\"></field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"!GU_s5^D*14Xse80)09m\">tartarugaImg</field></block></value><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_turnLeft\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_turnRight\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">45</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Amarelo</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">5</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_penUp\"><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_penDown\"><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":74,"length1":17,"diffs":[[1,"let tartarugaImg = img`\n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . 5 5 5 . . . . . . . \n    . . . . . 5 5 5 5 5 . . . . . . \n    . . . . 5 5 5 5 5 5 5 . . . . . \n    . . . . f f f f f f f . . . . . \n    . . . . 5 5 5 5 5 5 5 . . . . . \n    . . . . . 5 5 5 5 5 . . . . . . \n    . . . . . . 5 5 5 . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    . . . . . . . . . . . . . . . . \n    `\nmyTurtle.start(tartarugaImg)\n"]]},{"start1":761,"length1":0,"diffs":[[1,"pause(1000)\nmyTurtle.forward(30)\npause(1000)\nmyTurtle.turnLeft(90)\npause(1000)\nmyTurtle.forward(30)\npause(1000)\nmyTurtle.turnRight(45)\npause(1000)\n// Amarelo\nmyTurtle.setPenColor(5)\npause(1000)\nmyTurtle.penUp()\npause(1000)\nmyTurtle.forward(20)\npause(1000)\nmyTurtle.penDown()\npause(1000)\nmyTurtle.forward(30)\npause(1000)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":331,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1749305523999,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1053,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"myTurtle_start\"><comment pinned=\"false\" h=\"80\" w=\"160\">Em main.ts (JavaScript)\nDesenhe uma imagem simples para a tartaruga</comment><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"myTurtle_turnLeft\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"myTurtle_turnRight\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">45</field></shadow></value><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Amarelo</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">5</field></shadow></value><next><block type=\"myTurtle_penUp\"><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"myTurtle_penDown\"><next><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":28,"diffs":[[1,"// Em main.ts (JavaScript)\n// Desenhe uma imagem simples para a tartaruga\n"]]},{"start1":91,"length1":13,"diffs":[[1,"// Vermelho\n"]]},{"start1":127,"length1":96,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":284,"length1":39,"diffs":[[1,"        \"turtle.ts\"\n"]]},{"start1":331,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"added","filename":"main.py","value":"# Em main.ts (JavaScript)\nmyTurtle.start()\n# Vermelho\nmyTurtle.set_pen_color(2)\nfor index in range(4):\n    myTurtle.forward(30)\n    myTurtle.turn_right(90)"}]},{"timestamp":1749305673016,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"pyprj\"\n"]]}]}]},{"timestamp":1749306499242,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":0,"length1":356,"diffs":[[1,"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Tartaruga\"\n// Usando uma cor verde mais escura e o mesmo ícone de tartaruga (bug)\nnamespace myTurtle {\n    let turtleSprite: Sprite = null;\n    let isPenDownFlag: boolean = true;\n    let penColor: number = 1; // Cor padrão (branco)\n    let currentAngle: number = 0; // 0 graus = para a direita\n"]]},{"start1":336,"length1":147,"diffs":[[1,"    let turtleX: number = scene.screenWidth() / 2;\n    let turtleY: number = scene.screenHeight() / 2;\n"]]},{"start1":640,"length1":92,"diffs":[[1,""]]},{"start1":683,"length1":0,"diffs":[[1,"    // Direções para indexar os arrays de frames\n"]]},{"start1":828,"length1":119,"diffs":[[1,"    let currentVisualDirection = DIR_RIGHT;\n    let turtleIdleFrames: Image[];\n    let turtleWalkFrames: Image[][]; // [direção][frame_index]\n"]]},{"start1":971,"length1":56,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA ---\n    // (Estas são representações simplificadas, você pode desenhar as suas no editor de sprites do MakeCode e colar o código aqui)\n\n    // Direita\n"]]},{"start1":1185,"length1":583,"diffs":[[1,"        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . e . . . e . . . . . . \n        . . . . e . . . . . e . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n"]]},{"start1":1884,"length1":583,"diffs":[[1,"        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . . . . . e . . . . . . \n        . . . . . . . . . . e . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n"]]},{"start1":2583,"length1":583,"diffs":[[1,"        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . e . . . . . . . . . . \n        . . . . e . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n"]]},{"start1":3251,"length1":687,"diffs":[[1,"    // Cima (imagens giradas - idealmente seriam desenhadas especificamente)\n    // Para simplificar, vou usar as mesmas da direita por enquanto, mas idealmente você criaria/giraria estas:\n    const turtle_U_idle = turtle_R_idle.clone(); // Clone para não modificar a original\n    turtle_U_idle.flipY(); // Exemplo de transformação, não é rotação correta\n    const turtle_U_walk1 = turtle_R_walk1.clone();\n    turtle_U_walk1.flipY();\n    const turtle_U_walk2 = turtle_R_walk2.clone();\n    turtle_U_walk2.flipY();\n"]]},{"start1":3765,"length1":0,"diffs":[[1,"    // Esquerda\n    const turtle_L_idle = turtle_R_idle.clone();\n    turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone();\n    turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone();\n    turtle_L_walk2.flipX();\n\n    // Baixo\n    const turtle_D_idle = turtle_L_idle.clone(); // Clone da esquerda\n    turtle_D_idle.flipY(); // Exemplo de transformação\n    const turtle_D_walk1 = turtle_L_walk1.clone();\n    turtle_D_walk1.flipY();\n    const turtle_D_walk2 = turtle_L_walk2.clone();\n    turtle_D_walk2.flipY();\n\n\n"]]},{"start1":4355,"length1":120,"diffs":[[1,"        turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n        turtleWalkFrames = [\n"]]},{"start1":4715,"length1":469,"diffs":[[1,"    function _setVisualOrientation() {\n        if (!turtleSprite) return;\n        // Normaliza o ângulo para 0-359\n        let normalizedAngle = (currentAngle % 360 + 360) % 360;\n\n        if (normalizedAngle >= 315 || normalizedAngle < 45) { // Direita\n            currentVisualDirection = DIR_RIGHT;\n        } else if (normalizedAngle >= 45 && normalizedAngle < 135) { // Baixo\n            currentVisualDirection = DIR_DOWN;\n        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // Esquerda\n            currentVisualDirection = DIR_LEFT;\n        } else { // Cima (normalizedAngle >= 225 && normalizedAngle < 315)\n            currentVisualDirection = DIR_UP;\n"]]},{"start1":5400,"length1":25,"diffs":[[1,"        turtleSprite.setImage(turtleIdleFrames[currentVisualDirection]);\n"]]},{"start1":5480,"length1":0,"diffs":[[1,"    //% block=\"iniciar tartaruga\"\n    //% weight=100\n    export function start(): void {\n        _initializeTurtleFrames(); // Carrega as imagens nos arrays\n"]]},{"start1":5638,"length1":635,"diffs":[[1,"        if (turtleSprite) {\n            turtleSprite.destroy();\n"]]},{"start1":5712,"length1":6,"diffs":[[1,"        // Cria o sprite com a imagem inicial (parado, virado para a direita)\n        turtleSprite = sprites.create(turtleIdleFrames[DIR_RIGHT], SpriteKind.Player);\n        turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n"]]},{"start1":5939,"length1":137,"diffs":[[1,"        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n"]]},{"start1":6079,"length1":617,"diffs":[[1,"        currentAngle = 0; // Apontando para a direita\n        currentVisualDirection = DIR_RIGHT; // Sincroniza direção visual\n        _setVisualOrientation(); // Define a imagem correta\n\n        isPenDownFlag = true;\n        penColor = 1;\n        // scene.backgroundImage().fill(scene.backgroundColor()); // Limpa a tela\n"]]},{"start1":6408,"length1":29,"diffs":[[1,"    //% block=\"tartaruga para frente %distancia pixels\"\n    //% distancia.defl=50\n    //% weight=90\n    export function forward(distancia: number): void {\n        if (!turtleSprite) return;\n"]]},{"start1":6599,"length1":304,"diffs":[[1,"        const isMovingBackward = distancia < 0;\n        const absDistancia = Math.abs(distancia);\n"]]},{"start1":6698,"length1":57,"diffs":[[1,"        const radianos = currentAngle * Math.PI / 180;\n        // Se movendo para trás, invertemos a direção do delta\n"]]},{"start1":6879,"length1":166,"diffs":[[1,"        const totalDeltaX = Math.cos(radianos) * absDistancia * directionMultiplier;\n        const totalDeltaY = Math.sin(radianos) * absDistancia * directionMultiplier;\n"]]},{"start1":7050,"length1":89,"diffs":[[1,"        const numAnimationSteps = Math.max(1, Math.ceil(absDistancia / PIXELS_PER_STEP));\n"]]},{"start1":7292,"length1":124,"diffs":[[1,"        const walkCycle = turtleWalkFrames[currentVisualDirection];\n"]]},{"start1":7415,"length1":124,"diffs":[[1,"            // Atualiza frame da animação\n            turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n"]]},{"start1":7611,"length1":72,"diffs":[[1,"            const prevX = turtleX;\n            const prevY = turtleY;\n"]]},{"start1":7682,"length1":64,"diffs":[[1,"            turtleX += stepDx;\n            turtleY += stepDy;\n"]]},{"start1":7745,"length1":30,"diffs":[[1,"            if (isPenDownFlag) {\n"]]},{"start1":7906,"length1":114,"diffs":[[1,"                    Math.round(turtleX),\n                    Math.round(turtleY),\n                    penColor\n"]]},{"start1":8050,"length1":146,"diffs":[[1,"            turtleSprite.setPosition(turtleX, turtleY);\n            pause(ANIMATION_FRAME_DURATION);\n"]]},{"start1":8161,"length1":122,"diffs":[[1,"        // Volta para o frame de idle ao terminar\n        turtleSprite.setImage(turtleIdleFrames[currentVisualDirection]);\n"]]},{"start1":8291,"length1":197,"diffs":[[1,"    //% block=\"tartaruga para trás %distancia pixels\"\n    //% distancia.defl=50\n    //% weight=85\n    export function backward(distancia: number): void {\n        forward(-distancia); // Reutiliza a lógica do forward com distância negativa\n"]]},{"start1":8537,"length1":754,"diffs":[[1,"    //% block=\"tartaruga virar à esquerda %angulo graus\"\n    //% angulo.defl=90\n    //% weight=80\n    export function turnLeft(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle -= angulo;\n"]]},{"start1":8794,"length1":139,"diffs":[[1,""]]},{"start1":8795,"length1":230,"diffs":[[1,"    //% block=\"tartaruga virar à direita %angulo graus\"\n    //% angulo.defl=90\n    //% weight=75\n    export function turnRight(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle += angulo;\n"]]},{"start1":9052,"length1":140,"diffs":[[1,""]]},{"start1":9053,"length1":732,"diffs":[[1,"    //% block=\"levantar caneta da tartaruga\"\n    //% weight=70\n    export function penUp(): void {\n        isPenDownFlag = false;\n"]]},{"start1":9189,"length1":306,"diffs":[[1,""]]},{"start1":9190,"length1":287,"diffs":[[1,"    //% block=\"abaixar caneta da tartaruga\"\n    //% weight=65\n    export function penDown(): void {\n        isPenDownFlag = true;\n"]]},{"start1":9326,"length1":158,"diffs":[[1,""]]},{"start1":9327,"length1":481,"diffs":[[1,"    //% block=\"definir cor da caneta para %cor=colorindexpicker\"\n    //% weight=60\n    export function setPenColor(cor: number): void {\n        penColor = cor;\n"]]},{"start1":9494,"length1":4129,"diffs":[[1,"    //% block=\"limpar desenhos da tartaruga\"\n    //% weight=55\n"]]},{"start1":9593,"length1":59,"diffs":[[1,""]]},{"start1":9663,"length1":676,"diffs":[[1,"    //% block=\"tartaruga ir para casa (centro)\"\n    //% weight=50\n    export function home(): void {\n        if (!turtleSprite) return;\n        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n        currentAngle = 0;\n        _setVisualOrientation();\n"]]},{"start1":10003,"length1":258,"diffs":[[1,"}\n"]]}]}]},{"timestamp":1749306506871,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":821,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"T=*C+ws+^6nEm/}ykYA!\">index</variable></variables><block type=\"pxt-on-start\" x=\"-83\" y=\"36\"><statement name=\"HANDLER\"><block type=\"myTurtle_start\"><comment pinned=\"false\" h=\"80\" w=\"160\">Em main.ts (JavaScript)\nDesenhe uma imagem simples para a tartaruga</comment><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"myTurtle_turnRight\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":31,"diffs":[[1,"//  Em main.ts (JavaScript)\nmyTurtle.start()\n//  Vermelho\nmyTurtle.setPenColor(2)\n"]]},{"start1":124,"length1":44,"diffs":[[1,"    myTurtle.forward(30)\n    myTurtle.turnRight(90)\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":200,"length1":66,"diffs":[[1,"    let _penColor: number = 1; // Cor padrão (branco)\n"]]},{"start1":705,"length1":73,"diffs":[[1,"    let _turtleSpeed = 6; // Padrão do Python (0-10, 0 é o mais rápido). Vamos mapear isso.\n"]]},{"start1":865,"length1":90,"diffs":[[1,"    const DIR_UP = 1;\n"]]},{"start1":911,"length1":83,"diffs":[[1,"    const DIR_DOWN = 3;\n"]]},{"start1":1056,"length1":209,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA (COLE AS SUAS AQUI) ---\n"]]},{"start1":1179,"length1":432,"diffs":[[1,""]]},{"start1":1215,"length1":0,"diffs":[[1,"    . . . . . . 7 . . 7 . . . . . .\n    . . . . . 7 b b 7 . . . . . . .\n    . . . . 7 . b a b . 7 7 . . . .\n    . . . . . 7 b b 7 . . . . . . .\n    . . . . . . 7 . . 7 . . . . . .\n"]]},{"start1":1467,"length1":98,"diffs":[[1,""]]},{"start1":1503,"length1":432,"diffs":[[1,""]]},{"start1":1611,"length1":71,"diffs":[[1,""]]},{"start1":1647,"length1":432,"diffs":[[1,""]]},{"start1":1719,"length1":0,"diffs":[[1,"    `;\n    const turtle_R_walk1 = img`\n"]]},{"start1":1794,"length1":960,"diffs":[[1,""]]},{"start1":1830,"length1":0,"diffs":[[1,"    . . . . . . . 7 . . . 7 . . . .\n    . . . . . . b b 7 . . . . . . .\n    . . . . . 7 b a b . 7 7 . . . .\n    . . . . . . b b 7 . . . . . . .\n    . . . . . . . 7 . . . 7 . . . .\n"]]},{"start1":2118,"length1":610,"diffs":[[1,""]]},{"start1":2190,"length1":539,"diffs":[[1,""]]},{"start1":2226,"length1":72,"diffs":[[1,""]]},{"start1":2262,"length1":107,"diffs":[[1,""]]},{"start1":2334,"length1":0,"diffs":[[1,"    `;\n    const turtle_R_walk2 = img`\n"]]},{"start1":2409,"length1":360,"diffs":[[1,""]]},{"start1":2445,"length1":0,"diffs":[[1,"    . . . . . 7 . . . . 7 . . . . .\n    . . . . . 7 b b . . . . . . . .\n    . . . . 7 . b a b . 7 7 . . . .\n    . . . . . 7 b b . . . . . . . .\n    . . . . . 7 . . . . 7 . . . . .\n"]]},{"start1":2697,"length1":107,"diffs":[[1,""]]},{"start1":2733,"length1":432,"diffs":[[1,""]]},{"start1":2841,"length1":108,"diffs":[[1,""]]},{"start1":2877,"length1":432,"diffs":[[1,""]]},{"start1":2949,"length1":112,"diffs":[[1,"    `;\n"]]},{"start1":2957,"length1":0,"diffs":[[1,"    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX();\n    const turtle_U_idle = turtle_R_idle.clone(); turtle_U_idle.rotate(-90);\n    const turtle_U_walk1 = turtle_R_walk1.clone(); turtle_U_walk1.rotate(-90);\n    const turtle_U_walk2 = turtle_R_walk2.clone(); turtle_U_walk2.rotate(-90);\n    const turtle_D_idle = turtle_R_idle.clone(); turtle_D_idle.rotate(90);\n    const turtle_D_walk1 = turtle_R_walk1.clone(); turtle_D_walk1.rotate(90);\n    const turtle_D_walk2 = turtle_R_walk2.clone(); turtle_D_walk2.rotate(90);\n"]]},{"start1":3806,"length1":287,"diffs":[[1,"            [turtle_R_walk1, turtle_R_walk2], // Direita\n            [turtle_U_walk1, turtle_U_walk2], // Cima\n            [turtle_L_walk1, turtle_L_walk2], // Esquerda\n            [turtle_D_walk1, turtle_D_walk2]  // Baixo\n"]]},{"start1":4172,"length1":0,"diffs":[[1,"        // Mapeia speed 1-10 para uma duração. Python: 1=slowest, 10=fast. 0=fastest.\n        // Vamos inverter: MakeCode 10 = slowest, 1 = fast\n"]]},{"start1":4421,"length1":153,"diffs":[[1,""]]},{"start1":4559,"length1":0,"diffs":[[1,"\n"]]},{"start1":4666,"length1":765,"diffs":[[1,""]]},{"start1":4981,"length1":44,"diffs":[[1,"            _currentHeading = 0;\n"]]},{"start1":5094,"length1":37,"diffs":[[1,"            _penColor = 1;\n"]]},{"start1":5282,"length1":41,"diffs":[[1,""]]},{"start1":5350,"length1":405,"diffs":[[1,"        if (normalizedAngle >= 315 || normalizedAngle < 45) { // Direita\n"]]},{"start1":5472,"length1":419,"diffs":[[1,"        } else if (normalizedAngle >= 45 && normalizedAngle < 135) { // Baixo (MakeCode Y aumenta para baixo)\n"]]},{"start1":5630,"length1":0,"diffs":[[1,"        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // Esquerda\n            _currentVisualDirection = DIR_LEFT;\n        } else { // Cima (normalizedAngle >= 225 && normalizedAngle < 315)\n            _currentVisualDirection = DIR_UP;\n"]]},{"start1":5891,"length1":348,"diffs":[[1,"        _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n"]]},{"start1":6309,"length1":721,"diffs":[[1,""]]},{"start1":6366,"length1":0,"diffs":[[1,"        const directionMultiplier = isMovingBackward ? -1 : 1;\n        const totalDeltaX = Math.cos(radians) * absDistance * directionMultiplier;\n        const totalDeltaY = Math.sin(radians) * absDistance * directionMultiplier;\n"]]},{"start1":6596,"length1":162,"diffs":[[1,""]]},{"start1":6962,"length1":756,"diffs":[[1,""]]},{"start1":7393,"length1":143,"diffs":[[1,"                scene.backgroundImage().drawLine(\n                    Math.round(prevX),\n                    Math.round(prevY),\n                    Math.round(_turtleX),\n                    Math.round(_turtleY),\n                    _penColor\n                );\n"]]},{"start1":7668,"length1":83,"diffs":[[1,"            _turtleSprite.setPosition(_turtleX, _turtleY);\n"]]},{"start1":7856,"length1":82,"diffs":[[1,"            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n"]]},{"start1":8341,"length1":84,"diffs":[[1,"        forward(-distance);\n"]]},{"start1":8877,"length1":78,"diffs":[[1,"        _currentHeading -= angle;\n"]]},{"start1":9286,"length1":76,"diffs":[[1,"        _currentHeading += angle;\n"]]},{"start1":9719,"length1":246,"diffs":[[1,"        // No MakeCode, (0,0) é canto superior esquerdo. Turtle Python é (0,0) no centro.\n        // Vamos manter o sistema de coordenadas do MakeCode por simplicidade na extensão.\n        // Se quisermos simular o centro, teríamos que ajustar x e y aqui.\n        // Ex: _turtleX = x + scene.screenWidth() / 2; _turtleY = y + scene.screenHeight() / 2;\n"]]},{"start1":10072,"length1":243,"diffs":[[1,""]]},{"start1":10171,"length1":0,"diffs":[[1,"        // Não desenha linha no goto, conforme padrão Turtle\n"]]},{"start1":11263,"length1":73,"diffs":[[1,"        _currentHeading = 0;\n"]]},{"start1":11405,"length1":112,"diffs":[[1,"        // _isPenDown = true;\n        // _penColor = 1; // ou cor padrão\n"]]},{"start1":12676,"length1":21,"diffs":[[1,""]]},{"start1":13003,"length1":35,"diffs":[[1,"    //% block=\"pen size %width\"\n"]]},{"start1":13060,"length1":24,"diffs":[[1,"    //% width.defl=1\n"]]},{"start1":13119,"length1":54,"diffs":[[1,"    export function pensize(width: number): void {\n"]]},{"start1":13349,"length1":104,"diffs":[[1,"        console.log(\"pensize not fully implemented yet for visual line thickness.\");\n"]]},{"start1":13440,"length1":79,"diffs":[[1,"    //% block=\"width %width\" group=\"Pen Control\" weight=59 blockHidden=true\n"]]},{"start1":13741,"length1":106,"diffs":[[1,"        return _currentHeading;\n"]]},{"start1":13957,"length1":69,"diffs":[[1,"        return { x: _turtleX, y: _turtleY };\n"]]},{"start1":14288,"length1":37,"diffs":[[1,"        return _turtleX;\n"]]},{"start1":14456,"length1":37,"diffs":[[1,"        return _turtleY;\n"]]},{"start1":14742,"length1":33,"diffs":[[1,"        _setVisualOrientation(); // Garante que a imagem correta seja mostrada\n"]]},{"start1":15886,"length1":31,"diffs":[[1,"        _ensureTurtleExists(); // Garante que o sprite exista para ser destruído se necessário\n"]]},{"start1":16047,"length1":34,"diffs":[[1,"            _turtleSprite = null; // Força a recriação em _ensureTurtleExists\n"]]},{"start1":16135,"length1":63,"diffs":[[1,"        scene.backgroundImage().fill(scene.backgroundColor()); // Limpa a tela\n"]]},{"start1":16282,"length1":16,"diffs":[[1,"        home(); // Coloca na posição e orientação inicial\n"]]},{"start1":16359,"length1":39,"diffs":[[1,"        pencolor(1); // Cor padrão\n        speed(6); // Velocidade padrão\n"]]},{"start1":16562,"length1":0,"diffs":[[1,"    // Isso pode ser chamado em um game.onStart se preferir, mas para uma extensão\n    // é bom que ela \"simplesmente funcione\".\n"]]}]}]},{"timestamp":1749307096002,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":820,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"turtle_right\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":464,"diffs":[[1,"// Vermelho\nturtle.pencolor(2)\nfor (let index = 0; index < 4; index++) {\n    turtle.forward(30)\n    turtle.right(90)\n"]]},{"start1":119,"length1":4321,"diffs":[[1,""]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":10403,"length1":0,"diffs":[[1,"        // Normaliza o ângulo para 0-359\n"]]},{"start1":10512,"length1":154,"diffs":[[1,"        // Determina a direção visual principal (Direita, Cima, Esquerda, Baixo)\n        // MakeCode: 0 é Direita, 90 é Baixo, 180 é Esquerda, 270 é Cima\n        // Turtle Python: 0 é Direita, 90 é Cima, 180 é Esquerda, 270 é Baixo\n        // Nossa _currentHeading segue o padrão Python. Precisamos mapear para o visual.\n"]]},{"start1":10834,"length1":97,"diffs":[[1,"        if (normalizedAngle >= 315 || normalizedAngle < 45) { // Direita (0 graus)\n"]]},{"start1":10966,"length1":97,"diffs":[[1,"        } else if (normalizedAngle >= 45 && normalizedAngle < 135) { // Cima (90 graus Python -> visual para Cima)\n"]]},{"start1":11127,"length1":102,"diffs":[[1,"        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // Esquerda (180 graus)\n"]]},{"start1":11269,"length1":99,"diffs":[[1,"        } else { // Baixo (normalizedAngle >= 225 && normalizedAngle < 315) (270 graus Python -> visual para Baixo)\n"]]},{"start1":12037,"length1":96,"diffs":[[1,"        const isMovingBackward = distance < 0;\n"]]},{"start1":12132,"length1":87,"diffs":[[1,""]]},{"start1":12228,"length1":0,"diffs":[[1,"        // Math.cos/sin esperam radianos e 0=Direita, PI/2 (90deg)=Cima (padrão matemático)\n        // Então, precisamos converter _currentHeading para o sistema matemático:\n        // Python Heading -> Math Angle (rad)\n        // 0 (Dir) -> 0 rad\n        // 90 (Cima) -> PI/2 rad\n        // 180 (Esq) -> PI rad\n        // 270 (Baixo) -> 3PI/2 rad ou -PI/2 rad\n        // No nosso caso, _currentHeading já está em graus onde 0 é direita, 90 é cima.\n        // Mas o sistema de coordenadas Y do MakeCode é invertido (aumenta para baixo).\n        // Então, para seno, um ângulo positivo (para cima) deve resultar em Y negativo.\n"]]},{"start1":12912,"length1":289,"diffs":[[1,"        const totalDeltaX = Math.cos(radians) * absDistance;\n        const totalDeltaY = Math.sin(radians) * absDistance; // Y positivo é para baixo no MakeCode\n"]]},{"start1":13315,"length1":91,"diffs":[[1,""]]},{"start1":13631,"length1":0,"diffs":[[1,"            // Se não houver animação de caminhada, apenas move\n"]]},{"start1":14028,"length1":142,"diffs":[[1,"            _turtleSprite.setPosition(_turtleX, _turtleY);\n            if (_isTurtleVisible) _setVisualOrientation(); // Volta para idle\n"]]},{"start1":14996,"length1":37,"diffs":[[1,"            _setVisualOrientation(); // Volta para a imagem idle da direção atual\n"]]},{"start1":16075,"length1":89,"diffs":[[1,"        _currentHeading -= angle; // No Turtle Python, left subtrai do ângulo\n"]]},{"start1":16528,"length1":85,"diffs":[[1,"        _currentHeading += angle; // No Turtle Python, right soma ao ângulo\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":0,"length1":0,"diffs":[[1,"# Em main.ts (JavaScript)\nmyTurtle.start()\n"]]},{"start1":54,"length1":19,"diffs":[[1,"myTurtle.set_pen_color(2)\n"]]},{"start1":103,"length1":42,"diffs":[[1,"    myTurtle.forward(30)\n    myTurtle.turn_right(90)"]]}]}]},{"timestamp":1749307558052,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":28424,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"turtle_left\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block></next></block></statement></block></xml>"]]}]}]},{"timestamp":1749309778444,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1749309778496,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":192,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"u7oRZPf55k3+ALRXEJ_u\">currentPos</variable></variables><comment x=\"0\" y=\"0\" w=\"380\" h=\"120\">\nCódigo de Teste para a Extensão Turtle\nColoque este código no seu main.ts\n</comment><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">--- Início dos Testes ---</comment><data>0</data><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Iniciando Testes da Turtle...</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_reset\"><comment pinned=\"false\" h=\"80\" w=\"160\">1. Setup Inicial e Quadrado</comment><next><block type=\"turtle_speed\"><comment pinned=\"false\" h=\"80\" w=\"160\">Velocidade média para observação</comment><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">6</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 1: Quadrado Vermelho</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"turtle_pendown\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">Deve virar à direita (horário)</comment><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">2. Mover sem Desenhar e Triângulo com heading</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 2: Mover e Triângulo Azul</field></shadow></value><next><block type=\"turtle_penup\"><next><block type=\"turtle_goto\"><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"turtle_setheading\"><comment pinned=\"false\" h=\"80\" w=\"160\">Apontar para a direita</comment><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Azul</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">4</field></shadow></value><next><block type=\"turtle_pendown\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">3</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"turtle_left\"><comment pinned=\"false\" h=\"80\" w=\"160\">Deve virar à esquerda (anti-horário)</comment><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">120</field></shadow></value></block></next></block></statement><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">3. Testar hideturtle e showturtle</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 3: Esconder/Mostrar Tartaruga</field></shadow></value><next><block type=\"turtle_hideturtle\"><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Tartaruga escondida, movendo...</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Amarelo escuro</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">14</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">25</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_showturtle\"><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Tartaruga visível, movendo para trás...</field></shadow></value><next><block type=\"turtle_backward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">4. Testar home e clear</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 4: Home e Clear</field></shadow></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta para o centro, heading 0</comment><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Roxo</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">5</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_clear\"><comment pinned=\"false\" h=\"80\" w=\"160\">Limpa o desenho, tartaruga permanece</comment><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Desenhos limpos. Tartaruga no lugar.</field></shadow></value><next><block type=\"turtle_right\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">45</field></shadow></value><next><block type=\"turtle_forward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha algo para confirmar</comment><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">5. Testar reset</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 5: Reset Total</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_forward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Tela limpa, tartaruga no centro, virada para direita, caneta branca/1, abaixada\nDeve desenhar uma linha branca/padrão</comment><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">25</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">6. Testar diferentes velocidades</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 6: Velocidades</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Laranja</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">7</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Velocidade 1 (Lenta)</field></shadow></value><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"turtle_right\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Velocidade 10 (Rápida)</field></shadow></value><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">10</field></shadow></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"turtle_right\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Velocidade 0 (Instantânea)</field></shadow></value><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"turtle_right\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"turtle_speed\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta para uma velocidade padrão</comment><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">6</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">7. Testar pensize (chamada de função)</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 7: Pensize (ver console)</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">--- Teste Pensize ---</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">Chamando turtle.pensize(5)</field></shadow></value><next><block type=\"turtle_pensize\"><value name=\"widthNum\"><shadow type=\"math_number\"><field name=\"NUM\">5</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Verde claro</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">3</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">15</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">Chamando turtle.pensize(1)</field></shadow></value><next><block type=\"turtle_pensize\"><value name=\"widthNum\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"turtle_backward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Para ver a linha sobreposta se pensize funcionasse visualmente</comment><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">15</field></shadow></value><next><block type=\"device_pause\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">8. Testar limites da tela e heading para todas as direções</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 8: Direções Cardeais</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">4</field></shadow></value><next><block type=\"turtle_setheading\"><comment pinned=\"false\" h=\"80\" w=\"160\">Direita (0 graus)</comment><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Cima (90 graus)</comment><next><block type=\"turtle_setheading\"><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Azul</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">4</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Esquerda (180 graus)</comment><next><block type=\"turtle_setheading\"><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">180</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Verde</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">3</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">500</field></shadow></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Baixo (270 graus)</comment><next><block type=\"turtle_setheading\"><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">270</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Roxo</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">5</field></shadow></value><next><block type=\"turtle_forward\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">9. Teste de \"estrela\" ou padrão radial</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 9: Padrão Radial</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">7</field></shadow></value><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Rosa</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">10</field></shadow></value><next><block type=\"controls_repeat_ext\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">12</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_backward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta para o centro</comment><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">Gira 30 graus</comment><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value></block></next></block></next></block></statement><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">10. Testar estado da caneta com isdown()</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 10: Estado da Caneta (isdown)</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_speed\"><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">5</field></shadow></value><next><block type=\"turtle_pencolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">1</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">--- Teste isdown ---</field></shadow></value><next><block type=\"console_log\"><comment pinned=\"false\" h=\"80\" w=\"160\">True</comment><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Pen deve estar DOWN por padrão após reset: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_isdown\"></block></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"turtle_penup\"><next><block type=\"console_log\"><comment pinned=\"false\" h=\"80\" w=\"160\">False</comment><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Pen deve estar UP: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_isdown\"></block></value></block></value><next><block type=\"turtle_forward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Não deve desenhar</comment><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"turtle_pendown\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><next><block type=\"console_log\"><comment pinned=\"false\" h=\"80\" w=\"160\">True</comment><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Pen deve estar DOWN: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_isdown\"></block></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1500</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">11. Testar informações de estado (heading, xcor, ycor, position)</comment><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Teste 11: Info de Estado (ver console)</field></shadow></value><next><block type=\"turtle_reset\"><next><block type=\"turtle_goto\"><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">10</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><next><block type=\"turtle_setheading\"><value name=\"to_angle\"><shadow type=\"math_number\"><field name=\"NUM\">45</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\">--- Teste Info Estado ---</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Heading esperado ~45: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_heading\"></block></value></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">XCOR esperado ~10: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_xcor\"></block></value></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">YCOR esperado ~20: </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_ycor\"></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"u7oRZPf55k3+ALRXEJ_u\">currentPos</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_position\"></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"4\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Position esperada x:~10, y:~20 : x=</field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">currentPos.x</field></block></value><value name=\"ADD2\"><shadow type=\"text\"><field name=\"TEXT\">, y=</field></shadow></value><value name=\"ADD3\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">currentPos.y</field></block></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">10</field></shadow></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Novo Heading (ainda 45): </field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"turtle_heading\"></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"u7oRZPf55k3+ALRXEJ_u\">currentPos</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_position\"></block></value><next><block type=\"console_log\"><value name=\"value\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"text_join\"><mutation items=\"4\"></mutation><value name=\"ADD0\"><shadow type=\"text\"><field name=\"TEXT\">Nova Posição: x=</field></shadow></value><value name=\"ADD1\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">currentPos.x</field></block></value><value name=\"ADD2\"><shadow type=\"text\"><field name=\"TEXT\">, y=</field></shadow></value><value name=\"ADD3\"><shadow type=\"text\"><field name=\"TEXT\"></field></shadow><block type=\"typescript_expression\"><field name=\"EXPRESSION\">currentPos.y</field></block></value></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"gameSplash\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"title\"><shadow type=\"text\"><field name=\"TEXT\">Testes Concluídos!</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"// Código de Teste para a Extensão Turtle\n// Coloque este código no seu main.ts\n"]]},{"start1":81,"length1":0,"diffs":[[1,"// --- Início dos Testes ---\ngame.splash(\"Iniciando Testes da Turtle...\")\npause(1000)\n\n// 1. Setup Inicial e Quadrado\nturtle.reset()\nturtle.speed(6) // Velocidade média para observação\ngame.splash(\"Teste 1: Quadrado Vermelho\")\nturtle.pencolor(2) // Vermelho\nturtle.pendown()\nfor (let i = 0; i < 4; i++) {\n    turtle.forward(50)\n    turtle.right(90) // Deve virar à direita (horário)\n}\npause(1500)\n\n// 2. Mover sem Desenhar e Triângulo com heading\ngame.splash(\"Teste 2: Mover e Triângulo Azul\")\nturtle.penup()\nturtle.goto(20, 30)\nturtle.setheading(0) // Apontar para a direita\n\nturtle.pencolor(4) // Azul\nturtle.pendown()\nfor (let i = 0; i < 3; i++) {\n    turtle.forward(40)\n    turtle.left(120) // Deve virar à esquerda (anti-horário)\n}\npause(1500)\n\n// 3. Testar hideturtle e showturtle\ngame.splash(\"Teste 3: Esconder/Mostrar Tartaruga\")\nturtle.hideturtle()\ngame.splash(\"Tartaruga escondida, movendo...\")\nturtle.pencolor(14) // Amarelo escuro\nturtle.forward(25)\npause(1000)\n\nturtle.showturtle()\ngame.splash(\"Tartaruga visível, movendo para trás...\")\nturtle.backward(20)\npause(1500)\n\n// 4. Testar home e clear\ngame.splash(\"Teste 4: Home e Clear\")\nturtle.home() // Volta para o centro, heading 0\nturtle.pencolor(5) // Roxo\nturtle.forward(30)\npause(1000)\n\nturtle.clear() // Limpa o desenho, tartaruga permanece\ngame.splash(\"Desenhos limpos. Tartaruga no lugar.\")\nturtle.right(45)\nturtle.forward(20) // Desenha algo para confirmar\npause(1500)\n\n// 5. Testar reset\ngame.splash(\"Teste 5: Reset Total\")\nturtle.reset()\n// Tela limpa, tartaruga no centro, virada para direita, caneta branca/1, abaixada\nturtle.forward(25) // Deve desenhar uma linha branca/padrão\npause(1500)\n\n// 6. Testar diferentes velocidades\ngame.splash(\"Teste 6: Velocidades\")\nturtle.reset()\nturtle.pencolor(7) // Laranja\nturtle.goto(40, 60)\n\ngame.splash(\"Velocidade 1 (Lenta)\")\nturtle.speed(1)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 10 (Rápida)\")\nturtle.speed(10)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 0 (Instantânea)\")\nturtle.speed(0)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\nturtle.speed(6) // Volta para uma velocidade padrão\npause(1500)\n\n// 7. Testar pensize (chamada de função)\ngame.splash(\"Teste 7: Pensize (ver console)\")\nconsole.log(\"--- Teste Pensize ---\")\nconsole.log(\"Chamando turtle.pensize(5)\")\nturtle.pensize(5)\nturtle.pencolor(3) // Verde claro\nturtle.forward(15)\nconsole.log(\"Chamando turtle.pensize(1)\")\nturtle.pensize(1)\nturtle.backward(15) // Para ver a linha sobreposta se pensize funcionasse visualmente\npause(1500)\n\n// 8. Testar limites da tela e heading para todas as direções\ngame.splash(\"Teste 8: Direções Cardeais\")\nturtle.reset()\nturtle.speed(4)\n\n// Direita (0 graus)\nturtle.setheading(0)\nturtle.pencolor(2) // Vermelho\nturtle.forward(60)\npause(500)\n\n// Cima (90 graus)\nturtle.home()\nturtle.setheading(90)\nturtle.pencolor(4) // Azul\nturtle.forward(40)\npause(500)\n\n// Esquerda (180 graus)\nturtle.home()\nturtle.setheading(180)\nturtle.pencolor(3) // Verde\nturtle.forward(60)\npause(500)\n\n// Baixo (270 graus)\nturtle.home()\nturtle.setheading(270)\nturtle.pencolor(5) // Roxo\nturtle.forward(40)\npause(1000)\n\n// 9. Teste de \"estrela\" ou padrão radial\ngame.splash(\"Teste 9: Padrão Radial\")\nturtle.reset()\nturtle.speed(7)\nturtle.pencolor(10) // Rosa\nfor (let i = 0; i < 12; i++) {\n    turtle.forward(50)\n    turtle.backward(50) // Volta para o centro\n    turtle.right(30)    // Gira 30 graus\n}\npause(1500)\n\n// 10. Testar estado da caneta com isdown()\ngame.splash(\"Teste 10: Estado da Caneta (isdown)\")\nturtle.reset()\nturtle.speed(5)\nturtle.pencolor(1)\nconsole.log(\"--- Teste isdown ---\")\nconsole.log(\"Pen deve estar DOWN por padrão após reset: \" + turtle.isdown()) // True\nturtle.forward(20)\nturtle.penup()\nconsole.log(\"Pen deve estar UP: \" + turtle.isdown()) // False\nturtle.forward(20) // Não deve desenhar\nturtle.pendown()\nconsole.log(\"Pen deve estar DOWN: \" + turtle.isdown()) // True\nturtle.forward(20)\npause(1500)\n\n// 11. Testar informações de estado (heading, xcor, ycor, position)\ngame.splash(\"Teste 11: Info de Estado (ver console)\")\nturtle.reset()\nturtle.goto(10, 20)\nturtle.setheading(45)\nconsole.log(\"--- Teste Info Estado ---\")\nconsole.log(\"Heading esperado ~45: \" + turtle.heading())\nconsole.log(\"XCOR esperado ~10: \" + turtle.xcor())\nconsole.log(\"YCOR esperado ~20: \" + turtle.ycor())\nlet currentPos = turtle.position()\nconsole.log(\"Position esperada x:~10, y:~20 : x=\" + currentPos.x + \", y=\" + currentPos.y)\nturtle.forward(10)\nconsole.log(\"Novo Heading (ainda 45): \" + turtle.heading())\ncurrentPos = turtle.position()\nconsole.log(\"Nova Posição: x=\" + currentPos.x + \", y=\" + currentPos.y)\npause(1000)\n\n\ngame.splash(\"Testes Concluídos!\")"]]}]}]},{"timestamp":1749310278776,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":0,"length1":230,"diffs":[[1,"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Turtle\"\n// Namespace agora é \"turtle\" para corresponder ao Python\n"]]},{"start1":126,"length1":32,"diffs":[[1,""]]},{"start1":164,"length1":188,"diffs":[[1,""]]},{"start1":200,"length1":275,"diffs":[[1,"    let _penColor: number = 1; // Cor padrão (branco no MakeCode)\n    let _currentHeading: number = 0; // 0 graus = para a direita (padrão do MakeCode e Turtle Python)\n"]]},{"start1":369,"length1":476,"diffs":[[1,"    let _turtleX: number = scene.screenWidth() / 2;\n    let _turtleY: number = scene.screenHeight() / 2;\n    let _isTurtleVisible: boolean = true;\n"]]},{"start1":517,"length1":163,"diffs":[[1,"    // --- Constantes de Animação ---\n    const ANIMATION_FRAME_DURATION = 150; // ms entre frames da caminhada\n    const PIXELS_PER_STEP = 4; // Quantos pixels a tartaruga anda por frame de animação\n    let _turtleSpeed = 6; // Padrão do Python (0-10, 0 é o mais rápido).\n"]]},{"start1":791,"length1":381,"diffs":[[1,"    // --- Arte da Tartaruga (Frames) ---\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;    // Corresponde ao ângulo de -90 ou 270 graus (para cima na tela)\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;  // Corresponde ao ângulo de 90 graus (para baixo na tela)\n"]]},{"start1":1056,"length1":117,"diffs":[[1,"    let _currentVisualDirection = DIR_RIGHT;\n    let _turtleIdleFrames: Image[];\n    let _turtleWalkFrames: Image[][];\n"]]},{"start1":1176,"length1":228,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA ---\n    // Você já forneceu a imagem base, vou usar uma similar para R_idle, R_walk1, R_walk2\n    // Por favor, substitua estas com as suas imagens exatas se forem diferentes.\n"]]},{"start1":1385,"length1":52,"diffs":[[1,"    const turtle_R_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo de tartaruga verde simples - substitua pela sua\n    const turtle_R_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . f f .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo - substitua pela sua\n    const turtle_R_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo - substitua pela sua\n"]]},{"start1":3353,"length1":574,"diffs":[[1,"    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX();\n"]]},{"start1":3576,"length1":310,"diffs":[[1,"    // !!! IMPORTANTE: CRIE ESTAS IMAGENS MANUALMENTE NO EDITOR DE SPRITES !!!\n    // Copie a 'turtle_R_idle', cole como 'turtle_U_idle', abra no editor e rotacione.\n    // Repita para walk1, walk2 e para as versões _D_ (para baixo).\n    const turtle_U_idle = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA CIMA\n    const turtle_U_walk1 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA CIMA\n    const turtle_U_walk2 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA CIMA\n"]]},{"start1":5858,"length1":2283,"diffs":[[1,"    const turtle_D_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA BAIXO\n    const turtle_D_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA BAIXO\n    const turtle_D_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA BAIXO\n"]]},{"start1":7909,"length1":100,"diffs":[[1,"\n    function _initializeTurtleFrames() {\n        _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n        _turtleWalkFrames = [\n            [turtle_R_walk1, turtle_R_walk2], // Direita (DIR_RIGHT = 0)\n            [turtle_U_walk1, turtle_U_walk2], // Cima    (DIR_UP = 1)\n            [turtle_L_walk1, turtle_L_walk2], // Esquerda(DIR_LEFT = 2)\n            [turtle_D_walk1, turtle_D_walk2]  // Baixo   (DIR_DOWN = 3)\n        ];\n"]]},{"start1":8376,"length1":144,"diffs":[[1,"    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0; // Mais rápido (quase instantâneo)\n        let duration = ANIMATION_FRAME_DURATION;\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            // Python: 1=slowest, 10=fast.\n            // MakeCode: vamos fazer speed 1 = mais lento (maior pausa), speed 10 = mais rápido (menor pausa)\n            duration = 25 + (10 - _turtleSpeed) * 25; // Ex: speed 1 -> 250ms, speed 10 -> 25ms\n"]]},{"start1":8863,"length1":24,"diffs":[[1,"        return duration;\n"]]},{"start1":8895,"length1":72,"diffs":[[1,"    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            _initializeTurtleFrames();\n            // Verifica se todas as imagens foram carregadas (simplesmente checando se não são nulas)\n            // Se alguma imagem estiver faltando (porque não foi colada), isso pode causar um erro aqui.\n            if (!_turtleIdleFrames[0] || !_turtleIdleFrames[1] || !_turtleIdleFrames[2] || !_turtleIdleFrames[3] ||\n                !_turtleWalkFrames[0][0] || !_turtleWalkFrames[1][0] || !_turtleWalkFrames[2][0] || !_turtleWalkFrames[3][0]) {\n                console.error(\"TURTLE EXTENSION: One or more turtle images are missing. Please define all idle and walk frames.\");\n                // Poderia lançar um erro ou usar uma imagem padrão de fallback\n                // Por agora, apenas loga e continua, o que pode levar a erros visuais.\n            }\n"]]},{"start1":9766,"length1":488,"diffs":[[1,"            _turtleSprite = sprites.create(_turtleIdleFrames[DIR_RIGHT], SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n            _turtleX = scene.screenWidth() / 2;\n            _turtleY = scene.screenHeight() / 2;\n            _turtleSprite.setPosition(_turtleX, _turtleY);\n            _currentHeading = 0; // Direita\n            _currentVisualDirection = DIR_RIGHT;\n            _isPenDown = true;\n            _penColor = 1; // Branco\n            _isTurtleVisible = true;\n            _setVisualOrientation();\n"]]},{"start1":10326,"length1":177,"diffs":[[1,""]]},{"start1":10372,"length1":102,"diffs":[[1,"        _ensureTurtleExists();\n        let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n"]]},{"start1":10471,"length1":554,"diffs":[[1,"        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo\n        // _currentVisualDirection: DIR_RIGHT=0, DIR_UP=1, DIR_LEFT=2, DIR_DOWN=3\n\n        if (normalizedAngle >= 315 || normalizedAngle < 45) {       // 0 graus +/- 45 -> Direita\n            _currentVisualDirection = DIR_RIGHT;\n        } else if (normalizedAngle >= 45 && normalizedAngle < 135) {  // 90 graus +/- 45 -> Cima\n            _currentVisualDirection = DIR_UP;\n        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // 180 graus +/- 45 -> Esquerda\n            _currentVisualDirection = DIR_LEFT;\n        } else { // (normalizedAngle >= 225 && normalizedAngle < 315) // 270 graus +/- 45 -> Baixo\n            _currentVisualDirection = DIR_DOWN;\n"]]},{"start1":11222,"length1":36,"diffs":[[1,""]]},{"start1":11223,"length1":369,"diffs":[[1,"        if (_isTurtleVisible && _turtleIdleFrames[_currentVisualDirection]) {\n            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n        } else if (!_turtleIdleFrames[_currentVisualDirection]) {\n            console.warn(\"TURTLE: Idle frame missing for current visual direction: \" + _currentVisualDirection);\n"]]},{"start1":11577,"length1":309,"diffs":[[1,"    // --- Turtle Motion ---\n"]]},{"start1":11607,"length1":68,"diffs":[[1,"    //% block=\"forward %distance pixels\"\n    //% blockAlias=fd\n    //% distance.defl=50\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _ensureTurtleExists();\n        const isMovingBackward = distance < 0; // Não usado diretamente aqui, mas pode ser útil\n        const absDistance = Math.abs(distance);\n        const effectiveDistance = distance; // Usar a distância com sinal para direção\n"]]},{"start1":12048,"length1":405,"diffs":[[1,"        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo (Padrão Turtle Python)\n        const radians = _currentHeading * Math.PI / 180;\n"]]},{"start1":12201,"length1":174,"diffs":[[1,"        // MakeCode Y aumenta para baixo.\n        // Se heading é 90 (Cima), sin(90)=1. Queremos Y diminuindo. Então -sin().\n        const totalDeltaX = Math.cos(radians) * effectiveDistance;\n        const totalDeltaY = -Math.sin(radians) * effectiveDistance; // Y invertido para MakeCode\n"]]},{"start1":12491,"length1":72,"diffs":[[1,"        const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n        const stepDx = totalDeltaX / numAnimationSteps;\n        const stepDy = totalDeltaY / numAnimationSteps;\n"]]},{"start1":12693,"length1":162,"diffs":[[1,"        let currentWalkFrameIndex = 0;\n        // A direção visual já foi definida por _setVisualOrientation após left/right/seth\n        const walkCycle = _turtleWalkFrames[_currentVisualDirection];\n        const animDuration = _getAnimationDuration();\n"]]},{"start1":12948,"length1":57,"diffs":[[1,"        if (!walkCycle || walkCycle.length === 0 || !walkCycle[0]) {\n            console.warn(\"TURTLE: Walk cycle missing or empty for current visual direction: \" + _currentVisualDirection);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n            _turtleX += totalDeltaX;\n            _turtleY += totalDeltaY;\n            if (_isPenDown) {\n                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n            }\n"]]},{"start1":13555,"length1":0,"diffs":[[1,"            if (_isTurtleVisible) _setVisualOrientation();\n            return;\n        }\n"]]},{"start1":13645,"length1":571,"diffs":[[1,"        for (let i = 0; i < numAnimationSteps; i++) {\n            if (_isTurtleVisible) {\n                _turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n"]]},{"start1":13823,"length1":177,"diffs":[[1,"            currentWalkFrameIndex = (currentWalkFrameIndex + 1) % walkCycle.length;\n"]]},{"start1":13908,"length1":227,"diffs":[[1,"            const prevX = _turtleX;\n            const prevY = _turtleY;\n"]]},{"start1":13981,"length1":226,"diffs":[[1,"            _turtleX += stepDx;\n            _turtleY += stepDy;\n"]]},{"start1":14046,"length1":981,"diffs":[[1,"            if (_isPenDown) {\n                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n            }\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            if (animDuration > 0) {\n                pause(animDuration);\n            }\n"]]},{"start1":14413,"length1":86,"diffs":[[1,"        if (_isTurtleVisible) {\n            _setVisualOrientation();\n"]]},{"start1":14492,"length1":101,"diffs":[[1,""]]},{"start1":14499,"length1":570,"diffs":[[1,"    //% block=\"fd %distance pixels\"\n    //% distance.defl=50\n    //% group=\"Movement\" weight=99\n    //% blockHidden=true\n    export function fd(distance: number): void {\n        forward(distance);\n"]]},{"start1":14703,"length1":1457,"diffs":[[1,"    //% block=\"backward %distance pixels\"\n    //% blockAlias=bk,back\n    //% distance.defl=50\n"]]},{"start1":14887,"length1":32,"diffs":[[1,"        forward(-distance); // forward já lida com distância negativa para animação\n"]]},{"start1":14977,"length1":73,"diffs":[[1,"    //% block=\"bk %distance pixels\" group=\"Movement\" weight=89 blockHidden=true\n"]]},{"start1":15128,"length1":75,"diffs":[[1,"    //% block=\"back %distance pixels\" group=\"Movement\" weight=88 blockHidden=true\n"]]},{"start1":15479,"length1":34,"diffs":[[1,"        _currentHeading += angle; // CORREÇÃO: left aumenta o ângulo (gira anti-horário)\n"]]},{"start1":15943,"length1":34,"diffs":[[1,"        _currentHeading -= angle; // CORREÇÃO: right diminui o ângulo (gira horário)\n"]]},{"start1":16208,"length1":142,"diffs":[[1,"    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos,setposition\n    //% x.defl=80 y.defl=60\n    //% group=\"Movement\" weight=60\n    export function goto(x: number, y: number): void {\n"]]},{"start1":16427,"length1":28,"diffs":[[1,"        // Coordenadas MakeCode: (0,0) canto superior esquerdo.\n        // Turtle Python: (0,0) centro.\n        // Esta extensão usa coordenadas MakeCode para goto.\n        // Se quiser simular o centro, o usuário da extensão precisaria ajustar.\n\n        if (_isPenDown) { // Turtle Python não desenha em goto por padrão, mas alguns podem querer\n            // scene.backgroundImage().drawLine(Math.round(_turtleX), Math.round(_turtleY), Math.round(x), Math.round(y), _penColor);\n        }\n        _turtleX = x;\n        _turtleY = y;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n"]]},{"start1":17022,"length1":220,"diffs":[[1,"    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=59 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=58 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n"]]},{"start1":17329,"length1":0,"diffs":[[1,"\n    //% block=\"set heading %to_angle degrees\"\n    //% blockAlias=seth\n    //% to_angle.defl=0\n    //% group=\"Movement\" weight=50\n    export function setheading(to_angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading = to_angle;\n        _setVisualOrientation();\n    }\n    //% block=\"seth %to_angle degrees\" group=\"Movement\" weight=49 blockHidden=true\n    export function seth(to_angle: number): void { setheading(to_angle); }\n\n    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists();\n        _turtleX = scene.screenWidth() / 2;\n        _turtleY = scene.screenHeight() / 2;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n        _currentHeading = 0; // Padrão Turtle Python: 0 é para a direita\n        _setVisualOrientation();\n        // Turtle Python também redefine a caneta para baixo e cor padrão, etc.\n        // pendown(); // Opcional, se quiser que home sempre baixe a caneta\n        // pencolor(1); // Opcional\n    }\n\n    //% block=\"speed %speedValue (0-10)\"\n    //% speedValue.min=0 speedValue.max=10 speedValue.defl=6\n    //% group=\"Movement\" weight=30\n    export function speed(speedValue: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, speedValue);\n    }\n\n    // --- Pen Control ---\n\n"]]},{"start1":18688,"length1":84,"diffs":[[1,"    //% blockAlias=pd,down\n    //% group=\"Pen Control\" weight=100\n"]]},{"start1":18856,"length1":66,"diffs":[[1,"    //% block=\"pd\" group=\"Pen Control\" weight=99 blockHidden=true\n"]]},{"start1":18968,"length1":68,"diffs":[[1,"    //% block=\"down\" group=\"Pen Control\" weight=98 blockHidden=true\n"]]},{"start1":19085,"length1":107,"diffs":[[1,"    //% block=\"pen up\"\n    //% blockAlias=pu,up\n    //% group=\"Pen Control\" weight=90\n    export function penup(): void {\n"]]},{"start1":19238,"length1":27,"diffs":[[1,"        _isPenDown = false;\n"]]},{"start1":19272,"length1":0,"diffs":[[1,"    //% block=\"pu\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function up(): void { penup(); }\n"]]},{"start1":19719,"length1":163,"diffs":[[1,"    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=70\n    export function isdown(): boolean {\n"]]},{"start1":19857,"length1":28,"diffs":[[1,"        return _isPenDown;\n"]]},{"start1":19891,"length1":31,"diffs":[[1,"    //% block=\"pen size %widthNum\"\n"]]},{"start1":19951,"length1":132,"diffs":[[1,"    //% widthNum.defl=1\n    //% group=\"Pen Control\" weight=60\n    export function pensize(widthNum: number): void {\n"]]},{"start1":20098,"length1":200,"diffs":[[1,"        // Implementação básica: por enquanto não afeta a linha visualmente.\n        // Para implementar, precisaríamos mudar a lógica de drawLine.\n        console.log(\"pensize (\" + widthNum + \") not fully implemented yet for visual line thickness.\");\n"]]},{"start1":20356,"length1":140,"diffs":[[1,"    //% block=\"width %widthNum\" group=\"Pen Control\" weight=59 blockHidden=true\n    export function width(w: number): void { pensize(w); }\n"]]},{"start1":20495,"length1":393,"diffs":[[1,""]]},{"start1":20496,"length1":434,"diffs":[[1,"    // --- Turtle State ---\n"]]},{"start1":20525,"length1":616,"diffs":[[1,""]]},{"start1":20549,"length1":39,"diffs":[[1,"    //% group=\"Turtle State\" weight=100\n"]]},{"start1":20660,"length1":49,"diffs":[[1,"        // Retorna o ângulo normalizado entre 0 e 360\n        return (_currentHeading % 360 + 360) % 360;\n"]]},{"start1":20773,"length1":207,"diffs":[[1,"    //% block=\"position\"\n    //% blockAlias=pos\n    //% group=\"Turtle State\" weight=90\n    export function position(): { x: number, y: number } {\n"]]},{"start1":20950,"length1":1073,"diffs":[[1,"        return { x: Math.round(_turtleX), y: Math.round(_turtleY) };\n"]]},{"start1":21025,"length1":306,"diffs":[[1,"    //% block=\"pos\" group=\"Turtle State\" weight=89 blockHidden=true\n    export function pos(): { x: number, y: number } { return position(); }\n"]]},{"start1":21169,"length1":203,"diffs":[[1,""]]},{"start1":21198,"length1":39,"diffs":[[1,"    //% group=\"Turtle State\" weight=80\n"]]},{"start1":21305,"length1":25,"diffs":[[1,"        return Math.round(_turtleX);\n"]]},{"start1":21378,"length1":39,"diffs":[[1,"    //% group=\"Turtle State\" weight=70\n"]]},{"start1":21485,"length1":25,"diffs":[[1,"        return Math.round(_turtleY);\n"]]},{"start1":21529,"length1":123,"diffs":[[1,"    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=60\n    export function showturtle(): void {\n"]]},{"start1":21690,"length1":45,"diffs":[[1,"        _isTurtleVisible = true;\n        _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        _setVisualOrientation();\n"]]},{"start1":21822,"length1":0,"diffs":[[1,"    //% block=\"st\" group=\"Turtle State\" weight=59 blockHidden=true\n    export function st(): void { showturtle(); }\n"]]},{"start1":21939,"length1":104,"diffs":[[1,"    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=50\n    export function hideturtle(): void {\n"]]},{"start1":22100,"length1":426,"diffs":[[1,"        _isTurtleVisible = false;\n        _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n"]]},{"start1":22199,"length1":0,"diffs":[[1,"    //% block=\"ht\" group=\"Turtle State\" weight=49 blockHidden=true\n    export function ht(): void { hideturtle(); }\n"]]},{"start1":22316,"length1":104,"diffs":[[1,"    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=40\n    export function isvisible(): boolean {\n"]]},{"start1":22464,"length1":145,"diffs":[[1,"        return _isTurtleVisible;\n"]]},{"start1":22504,"length1":287,"diffs":[[1,"    // --- Drawing Control ---\n"]]},{"start1":22645,"length1":340,"diffs":[[1,"        // Limpa apenas os desenhos, não afeta a tartaruga\n        scene.backgroundImage().fill(scene.backgroundColor());\n"]]},{"start1":22774,"length1":249,"diffs":[[1,"    //% block=\"reset turtle\"\n    //% group=\"Drawing Control\" weight=90\n    export function reset(): void {\n"]]},{"start1":22912,"length1":516,"diffs":[[1,"        if (_turtleSprite) {\n            _turtleSprite.destroy();\n            _turtleSprite = null;\n"]]},{"start1":23022,"length1":0,"diffs":[[1,"        scene.backgroundImage().fill(scene.backgroundColor());\n        _ensureTurtleExists(); // Recria e redefine para os padrões\n        home();\n        pendown();\n        pencolor(1);\n        speed(6);\n        showturtle();\n"]]},{"start1":23256,"length1":7994,"diffs":[[1,"    // Inicializa a tartaruga automaticamente para que os blocos funcionem sem um \"start\" explícito\n    _ensureTurtleExists();\n}"]]}]}]},{"timestamp":1749310799022,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":319,"length1":99,"diffs":[[1,"    let _turtleX: number = 80; // Center of screen initially\n    let _turtleY: number = 60; // Center of screen initially\n    let _currentHeading: number = 0; // 0 degrees is to the right\n"]]},{"start1":543,"length1":65,"diffs":[[1,"    let _penColor: number = 1; // Default pen color (white)\n    let _turtleSpeed: number = 6; // 1 (slowest) to 10 (fastest), 0 (instant)\n"]]},{"start1":721,"length1":30,"diffs":[[1,"    let _penSize: number = 1; // Thickness of the line (visual effect mostly for stamps for now)\n"]]},{"start1":819,"length1":0,"diffs":[[1,"    // For animation\n"]]},{"start1":1006,"length1":43,"diffs":[[1,"    let _turtleWalkFrames: Image[][] = []; // Outer array for direction, inner for animation frames\n"]]},{"start1":1233,"length1":31,"diffs":[[1,"    const ANIM_INTERVAL = 150; // ms between animation frames\n"]]},{"start1":1296,"length1":76,"diffs":[[1,"    // For drawing lines\n    let _drawingImage: Image = null; // The image we draw on\n    let _drawingSprite: Sprite = null; // Sprite to display the drawingImage\n"]]},{"start1":1460,"length1":79,"diffs":[[1,"    // For stamping and fill\n    let _fillColor: number = 1; // Default fill color (white)\n    let _currentStampShape: string = \"turtle\"; // \"turtle\", \"circle\", \"square\", \"arrow\", \"triangle\", \"classic\"\n"]]},{"start1":1743,"length1":40,"diffs":[[1,"    let _stampOutlineWidth: number = 1; // For shapes like circle/square, if they have an outline\n"]]},{"start1":1960,"length1":0,"diffs":[[1,"    // For write command\n"]]},{"start1":2030,"length1":44,"diffs":[[1,"    enum TextAnchor { Left, Center, Right } // Internal use for alignment logic\n    // _textAnchor is not explicitly stored as a state var, passed in write()\n"]]},{"start1":2341,"length1":0,"diffs":[[1,"            // Create the drawing surface first\n"]]},{"start1":2581,"length1":205,"diffs":[[1,"                _drawingSprite = sprites.create(_drawingImage, SpriteKind.Background); // Draw on background layer\n                _drawingSprite.z = -1; // Ensure it's behind other things if needed, but turtle is on top\n"]]},{"start1":2817,"length1":0,"diffs":[[1,"            // Create the turtle sprite\n"]]},{"start1":2964,"length1":148,"diffs":[[1,"            _turtleSprite.setFlag(SpriteFlag.StayInScreen, false); // Allow turtle to go off-screen\n            _turtleSprite.z = 10; // Turtle on top of drawings\n"]]},{"start1":3128,"length1":0,"diffs":[[1,"            // Initialize default images if not set by user\n"]]},{"start1":3238,"length1":0,"diffs":[[1,"                // Simple default turtle (e.g., a triangle or use built-in images)\n                // Facing Right (0), Up (1), Left (2), Down (3)\n"]]},{"start1":4281,"length1":27,"diffs":[[1,"                `.clone(); // Default green turtle head\n"]]},{"start1":4443,"length1":63,"diffs":[[1,"                _turtleIdleFrames[VisualDirection.Up].flipY(); // Crude up\n"]]},{"start1":4796,"length1":65,"diffs":[[1,"                _turtleIdleFrames[VisualDirection.Down].flipY(); // Crude down\n"]]},{"start1":4889,"length1":0,"diffs":[[1,"            // Initialize walk frames if empty (can be same as idle for no walk animation)\n"]]},{"start1":5183,"length1":34,"diffs":[[1,"            _updateTurtleImage(); // Set initial image\n"]]},{"start1":5776,"length1":0,"diffs":[[1,"\n"]]},{"start1":6082,"length1":94,"diffs":[[1,"            frames = [_turtleIdleFrames[_currentVisualDirection]]; // Treat idle as a single-frame animation\n        } else {\n            return; // No image for this state/direction\n        }\n\n"]]},{"start1":6600,"length1":407,"diffs":[[1,"\n        if (normalizedHeading >= 315 || normalizedHeading < 45) { // Right\n            _currentVisualDirection = VisualDirection.Right;\n        } else if (normalizedHeading >= 45 && normalizedHeading < 135) { // Up\n            _currentVisualDirection = VisualDirection.Up;\n        } else if (normalizedHeading >= 135 && normalizedHeading < 225) { // Left\n            _currentVisualDirection = VisualDirection.Left;\n        } else { // Down (normalizedHeading >= 225 && normalizedHeading < 315)\n            _currentVisualDirection = VisualDirection.Down;\n        }\n"]]},{"start1":7318,"length1":0,"diffs":[[1,"            // Adjust coordinates to be relative to the drawingImage's top-left (0,0)\n            // MakeCode screen coords are already fine.\n"]]},{"start1":7588,"length1":0,"diffs":[[1,"    // Game update for animation and smooth movement\n"]]},{"start1":7820,"length1":35,"diffs":[[1,"    let _movePerFrame: number = 1; // Pixels per frame for non-instant speed\n"]]},{"start1":7966,"length1":0,"diffs":[[1,"\n        // Animation\n"]]},{"start1":8240,"length1":14,"diffs":[[1,"            } // else idle frame stays at 0\n"]]},{"start1":8372,"length1":0,"diffs":[[1,"\n        // Movement\n"]]},{"start1":8547,"length1":0,"diffs":[[1,"\n"]]},{"start1":8620,"length1":0,"diffs":[[1,"\n"]]},{"start1":8685,"length1":64,"diffs":[[1,"            _turtleY -= moveDistance * Math.sin(_stepAngleRad); // Y is inverted in screen coords\n\n"]]},{"start1":8924,"length1":0,"diffs":[[1,"\n"]]},{"start1":8967,"length1":39,"diffs":[[1,"            if (_stepsToTake <= 0.1) { // Use a small threshold for float precision\n"]]},{"start1":9120,"length1":37,"diffs":[[1,"                _turtleX = _targetX; // Snap to final target\n"]]},{"start1":9218,"length1":61,"diffs":[[1,"                _drawLine(prevX, prevY, _turtleX, _turtleY); // Ensure final segment is drawn\n"]]},{"start1":9442,"length1":38,"diffs":[[1,"                _updateTurtleImage(); // Back to idle\n"]]},{"start1":9510,"length1":32,"diffs":[[1,"        } else if (_isMoving) { // Snapped or finished\n"]]},{"start1":9725,"length1":31,"diffs":[[1,"    //% block=\"print %text\"\n"]]},{"start1":9829,"length1":78,"diffs":[[1,"    export function print(...args: any[]): void {\n        console.log(...args);\n"]]},{"start1":10303,"length1":379,"diffs":[[1,"        _turtleX = screen.width / 2;\n        _targetX = _turtleX;\n        _turtleY = screen.height / 2;\n        _targetY = _turtleY;\n        _currentHeading = 0;\n        _isPenDown = true;\n        _penColor = 1; // White\n        _fillColor = 1; // White\n        _turtleSpeed = 6;\n        _turtleVisible = true;\n        _penSize = 1;\n        _currentStampShape = \"turtle\";\n        _stampStretchWidth = 1;\n        _stampStretchLength = 1;\n        _stampOutlineWidth = 1;\n\n"]]},{"start1":10922,"length1":261,"diffs":[[1,"        _setVisualOrientation();\n        _turtleAnimState = \"idle\";\n        _updateTurtleImage();\n\n        if (_drawingImage) {\n            _drawingImage.fill(0); // Clear drawing surface (transparent)\n        }\n        // Clear all stamps\n        for (let s of _stamps) {\n            s.destroy();\n        }\n        _stamps = [];\n        _nextStampId = 0;\n        _isMoving = false;\n        _stepsToTake = 0;\n"]]},{"start1":11573,"length1":85,"diffs":[[1,"        if (_turtleSpeed === 0) {\n            _movePerFrame = 1000; // Effectively instant for reasonable distances\n        } else {\n            // Map speed 1-10 to a movement step.\n            // Example: speed 1 moves 1 pixel/frame, speed 10 moves 5 pixels/frame\n            _movePerFrame = Math.max(1, _turtleSpeed / 2);\n        }\n"]]},{"start1":11997,"length1":109,"diffs":[[1,"        _turtleAnimState = \"walk\";\n        _updateTurtleImage();\n\n        const startX = _turtleX;\n        const startY = _turtleY;\n"]]},{"start1":12189,"length1":0,"diffs":[[1,"\n"]]},{"start1":12254,"length1":98,"diffs":[[1,"        _targetY = startY - distance * Math.sin(_stepAngleRad); // Y is inverted\n\n        if (_turtleSpeed === 0) { // Instant move\n"]]},{"start1":12445,"length1":54,"diffs":[[1,"            _turtleX = _targetX;\n            _turtleY = _targetY;\n"]]},{"start1":12594,"length1":110,"diffs":[[1,"            _turtleAnimState = \"idle\";\n            _updateTurtleImage();\n            _isMoving = false;\n            _stepsToTake = 0;\n"]]},{"start1":12745,"length1":65,"diffs":[[1,"            _stepsToTake = Math.abs(distance);\n            _isMoving = true;\n            // The game.onUpdate loop will handle the incremental movement\n"]]},{"start1":12914,"length1":175,"diffs":[[1,"    //% block=\"forward %distance\"\n    //% blockAlias=fd\n    //% distance.defl=20\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _moveTurtle(distance);\n    }\n"]]},{"start1":13266,"length1":188,"diffs":[[1,"    //% block=\"backward %distance\"\n    //% blockAlias=bk\n    //% blockAlias=back\n    //% distance.defl=20\n    //% group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        _moveTurtle(-distance);\n    }\n"]]},{"start1":13793,"length1":94,"diffs":[[1,"\n    //% block=\"left %angle degrees\"\n    //% blockAlias=lt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=80\n"]]},{"start1":13957,"length1":82,"diffs":[[1,"        _ensureTurtleExists();\n        _currentHeading += angle;\n        _setVisualOrientation();\n"]]},{"start1":14201,"length1":95,"diffs":[[1,"    //% block=\"right %angle degrees\"\n    //% blockAlias=rt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=70\n"]]},{"start1":14366,"length1":82,"diffs":[[1,"        _ensureTurtleExists();\n        _currentHeading -= angle;\n        _setVisualOrientation();\n"]]},{"start1":14611,"length1":41,"diffs":[[1,"    //% block=\"pen up\"\n    //% blockAlias=pu\n    //% blockAlias=up\n"]]},{"start1":14717,"length1":81,"diffs":[[1,"    export function penup(): void {\n        _ensureTurtleExists();\n        _isPenDown = false;\n    }\n"]]},{"start1":15039,"length1":45,"diffs":[[1,"    //% block=\"pen down\"\n    //% blockAlias=pd\n    //% blockAlias=down\n"]]},{"start1":15148,"length1":82,"diffs":[[1,"    export function pendown(): void {\n        _ensureTurtleExists();\n        _isPenDown = true;\n    }\n"]]},{"start1":15479,"length1":143,"diffs":[[1,"    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=60\n    export function isdown(): boolean {\n        _ensureTurtleExists();\n        return _isPenDown;\n    }\n"]]},{"start1":15651,"length1":189,"diffs":[[1,"    //% block=\"pen color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n    }\n"]]},{"start1":15877,"length1":192,"diffs":[[1,"    //% block=\"fill color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=75\n    export function fillcolor(color: number): void {\n        _ensureTurtleExists();\n        _fillColor = color;\n    }\n"]]},{"start1":16106,"length1":222,"diffs":[[1,"    //% block=\"pen size %size\"\n    //% blockAlias=width\n    //% size.min=1 size.max=100 size.defl=1\n    //% group=\"Pen Control\" weight=70\n    export function pensize(size: number): void {\n        _ensureTurtleExists();\n        _penSize = Math.max(1, size);\n        // Currently, this primarily affects stamp outlines if shapesize doesn't override.\n        // For turtle's own line, _drawLine would need to be enhanced.\n    }\n"]]},{"start1":16672,"length1":68,"diffs":[[1,"    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=80\n"]]},{"start1":16802,"length1":55,"diffs":[[1,"        _ensureTurtleExists();\n        _turtleVisible = false;\n"]]},{"start1":17066,"length1":68,"diffs":[[1,"    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=70\n"]]},{"start1":17196,"length1":54,"diffs":[[1,"        _ensureTurtleExists(); // Ensures sprite exists if called early\n        _turtleVisible = true;\n"]]},{"start1":17501,"length1":157,"diffs":[[1,"    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=60\n    export function isvisible(): boolean {\n        _ensureTurtleExists();\n        return _turtleVisible;\n    }\n"]]},{"start1":17687,"length1":102,"diffs":[[1,"    //% block=\"set heading %angle degrees\"\n    //% blockAlias=seth\n    //% angle.defl=0\n    //% group=\"Movement\" weight=60\n"]]},{"start1":17864,"length1":81,"diffs":[[1,"        _ensureTurtleExists();\n        _currentHeading = angle;\n        _setVisualOrientation();\n"]]},{"start1":18117,"length1":161,"diffs":[[1,"    //% block=\"heading\"\n    //% group=\"Turtle State\" weight=50\n    export function heading(): number {\n        _ensureTurtleExists();\n        return _normalizeAngle(_currentHeading);\n    }\n"]]},{"start1":18307,"length1":118,"diffs":[[1,"    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos\n    //% blockAlias=setposition\n    //% x.defl=80 y.defl=60\n    //% group=\"Movement\" weight=50\n"]]},{"start1":18545,"length1":122,"diffs":[[1,"        const startX = _turtleX;\n        const startY = _turtleY;\n        _targetX = x;\n        _targetY = y;\n\n        if (_turtleSpeed === 0) { // Instant move\n"]]},{"start1":18765,"length1":54,"diffs":[[1,"            _turtleX = _targetX;\n            _turtleY = _targetY;\n"]]},{"start1":18914,"length1":49,"diffs":[[1,"            _isMoving = false;\n            _stepsToTake = 0;\n"]]},{"start1":18992,"length1":66,"diffs":[[1,"            // For goto with speed, we need to calculate direction and distance\n            const dx = _targetX - startX;\n            const dy = _targetY - startY; // Screen Y is inverted from math Y\n"]]},{"start1":19249,"length1":152,"diffs":[[1,"            if (_stepsToTake < 0.1) { // Already there\n                _isMoving = false;\n                _stepsToTake = 0;\n                return;\n            }\n            _stepAngleRad = Math.atan2(-dy, dx); // atan2(y,x), use -dy for screen coords\n            // No need to set _currentHeading for goto, it preserves heading\n            _isMoving = true;\n"]]},{"start1":19931,"length1":48,"diffs":[[1,"    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n"]]},{"start1":20022,"length1":89,"diffs":[[1,"        _ensureTurtleExists();\n        goto(screen.width / 2, screen.height / 2);\n        setheading(0);\n"]]},{"start1":20134,"length1":139,"diffs":[[1,"    //% block=\"x coordinate\"\n    //% group=\"Turtle State\" weight=40\n    export function xcor(): number {\n        _ensureTurtleExists();\n        return _turtleX;\n    }\n"]]},{"start1":20302,"length1":139,"diffs":[[1,"    //% block=\"y coordinate\"\n    //% group=\"Turtle State\" weight=39\n    export function ycor(): number {\n        _ensureTurtleExists();\n        return _turtleY;\n    }\n"]]},{"start1":20470,"length1":177,"diffs":[[1,"    //% block=\"position\"\n    //% group=\"Turtle State\" weight=38\n    export function position(): { x: number, y: number } {\n        _ensureTurtleExists();\n        return { x: _turtleX, y: _turtleY };\n    }\n"]]},{"start1":20676,"length1":52,"diffs":[[1,"    //% block=\"set x %x\"\n    //% group=\"Movement\" weight=35\n"]]},{"start1":20780,"length1":59,"diffs":[[1,"        _ensureTurtleExists();\n        // Python turtle's setx/sety do not draw lines if pen is down,\n        // but they do move the turtle. Our goto handles drawing.\n        // For simplicity, setx/sety will not draw.\n        _turtleX = x;\n        _targetX = x; // Update target as well to stop any ongoing movement\n"]]},{"start1":21146,"length1":45,"diffs":[[1,"        _isMoving = false; // Stop any current interpolated move\n        _stepsToTake = 0;\n"]]},{"start1":21244,"length1":52,"diffs":[[1,"    //% block=\"set y %y\"\n    //% group=\"Movement\" weight=34\n"]]},{"start1":21348,"length1":59,"diffs":[[1,"        _ensureTurtleExists();\n        _turtleY = y;\n        _targetY = y;\n"]]},{"start1":21471,"length1":45,"diffs":[[1,"        _isMoving = false;\n        _stepsToTake = 0;\n"]]},{"start1":21531,"length1":69,"diffs":[[1,"    //% block=\"distance to x %x y %y\"\n    //% group=\"Turtle State\" weight=30\n"]]},{"start1":21669,"length1":75,"diffs":[[1,"        _ensureTurtleExists();\n        const dx = _turtleX - x;\n        const dy = _turtleY - y;\n"]]},{"start1":21818,"length1":66,"diffs":[[1,"    //% block=\"clear drawings\"\n    //% group=\"Drawing Control\" weight=100\n"]]},{"start1":21928,"length1":73,"diffs":[[1,"        _ensureTurtleExists();\n        if (_drawingImage) {\n            _drawingImage.fill(0); // Clear drawing surface (transparent)\n        }\n        // Note: This does NOT clear stamps. Python's clear() also doesn't clear stamps.\n        // Python's clearscreen() clears stamps and resets turtle. Our reset() is closer to clearscreen().\n"]]},{"start1":22275,"length1":0,"diffs":[[1,"    // --- Stamping ---\n"]]},{"start1":22327,"length1":105,"diffs":[[1,"    //% name.options.defl=\"turtle\"\n    //% name.options.enumValues=\"turtle,circle,square,arrow,triangle,classic\"\n"]]},{"start1":22524,"length1":302,"diffs":[[1,"        _ensureTurtleExists();\n        let lowerName = name.toLowerCase();\n        // \"arrow\", \"triangle\", \"classic\" are Python turtle shapes, we'll treat them like \"turtle\" for now\n        if (lowerName === \"turtle\" || lowerName === \"circle\" || lowerName === \"square\" || lowerName === \"arrow\" || lowerName === \"triangle\" || lowerName === \"classic\") {\n            _currentStampShape = lowerName;\n        } else {\n            console.warn(\"Turtle: Unknown shape '\" + name + \"'. Defaulting to 'turtle'.\");\n            _currentStampShape = \"turtle\";\n        }\n"]]},{"start1":23166,"length1":434,"diffs":[[1,"    //% sWidth.defl=1\n    //% sLength.defl=1\n    //% sOutline.defl=1\n    //% inlineInputMode=inline\n    //% group=\"Stamping\" weight=90\n    export function shapesize(sWidth: number, sLength?: number, sOutline?: number): void {\n        _ensureTurtleExists();\n        _stampStretchWidth = Math.max(0.1, sWidth);\n        _stampStretchLength = (sLength === undefined || sLength < 0.1) ? _stampStretchWidth : Math.max(0.1, sLength);\n        _stampOutlineWidth = (sOutline === undefined || sOutline < 0) ? 1 : Math.max(0, sOutline);\n"]]},{"start1":23699,"length1":49,"diffs":[[1,"    //% block=\"stamp\"\n    //% group=\"Stamping\" weight=80\n"]]},{"start1":23794,"length1":170,"diffs":[[1,"        _ensureTurtleExists();\n        let stampImage: Image;\n        const BASE_SHAPE_SIZE = 12; // Default pixel size for a 1x1 shapesize for circle/square\n\n        let w = Math.round(BASE_SHAPE_SIZE * _stampStretchWidth);\n        let h = Math.round(BASE_SHAPE_SIZE * _stampStretchLength);\n\n"]]},{"start1":24134,"length1":65,"diffs":[[1,"            stampImage = image.create(w, h);\n            stampImage.fill(0); // Transparent\n            // Draw outline first, then fill\n"]]},{"start1":24313,"length1":221,"diffs":[[1,"                // For thicker outline, draw multiple concentric circles or one slightly larger\n                stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - 1, _penColor); // Simple outline\n                if (_stampOutlineWidth > 1) { // Basic attempt at thickness\n                    stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _penColor);\n                }\n"]]},{"start1":24888,"length1":65,"diffs":[[1,"            stampImage = image.create(w, h);\n            stampImage.fill(0); // Transparent\n"]]},{"start1":25022,"length1":252,"diffs":[[1,"                stampImage.drawRect(0, 0, w, h, _penColor); // Simple outline\n                if (_stampOutlineWidth > 1) { // Basic attempt at thickness\n                    stampImage.drawRect(_stampOutlineWidth - 1, _stampOutlineWidth - 1, w - 2 * (_stampOutlineWidth - 1), h - 2 * (_stampOutlineWidth - 1), _penColor);\n                }\n"]]},{"start1":25517,"length1":157,"diffs":[[1,"        } else { // \"turtle\", \"arrow\", \"triangle\", \"classic\"\n            let baseTurtleImg = _turtleIdleFrames[_currentVisualDirection] || _turtleIdleFrames[0] || img`1`;\n            stampImage = baseTurtleImg.clone();\n            // Note: shapesize doesn't easily scale pixel art well without specific algorithms.\n            // For these shapes, fillcolor/pencolor from turtle object don't apply; uses image's own colors.\n"]]},{"start1":25951,"length1":0,"diffs":[[1,"\n"]]},{"start1":26102,"length1":248,"diffs":[[1,"        stampSprite.setFlag(SpriteFlag.Ghost, true); // Stamps usually don't interact\n        stampSprite.z = _drawingSprite.z + 1; // Ensure stamps are on top of general drawings\n\n        _nextStampId++;\n        stampSprite.data[\"stampId\"] = _nextStampId;\n        _stamps.push(stampSprite);\n        return _nextStampId;\n"]]},{"start1":26430,"length1":67,"diffs":[[1,"    //% block=\"clear stamp id %stampId\"\n    //% group=\"Stamping\" weight=70\n"]]},{"start1":26706,"length1":68,"diffs":[[1,"                _stamps[i].destroy();\n                _stamps.splice(i, 1);\n                return;\n"]]},{"start1":26837,"length1":0,"diffs":[[1,"    // --- Text Writing ---\n"]]},{"start1":26945,"length1":164,"diffs":[[1,"    //% text.shadowOptions.toString=true\n    //% move.defl=false\n    //% align.defl=\"left\"\n    //% fontSize.min=5 fontSize.max=12 fontSize.defl=5\n    //% group=\"Drawing Control\" weight=70\n"]]},{"start1":27232,"length1":587,"diffs":[[1,"        _ensureTurtleExists();\n\n        let currentFont = image.font5;\n        if (fontSize === 8) currentFont = image.font8;\n        else if (fontSize === 12) currentFont = image.font12; // MakeCode doesn't have font12 by default\n        else if (fontSize && fontSize !== 5) currentFont = image.scaledFont(image.font5, fontSize / 5);\n\n\n        // Estimate text width/height\n        let textWidth = text.length * currentFont.charWidth;\n        let textHeight = currentFont.charHeight;\n\n        // Create an image for the text, slightly larger to avoid clipping if centered\n        let imgPadding = Math.ceil(currentFont.charWidth / 2);\n        let textImage = image.create(textWidth + imgPadding, textHeight + imgPadding);\n        textImage.fill(0); // Transparent background\n\n        let printX = Math.floor(imgPadding / 2); // Start printing with some padding\n\n        textImage.print(text, printX, Math.floor(imgPadding / 2), _penColor, currentFont);\n\n        let textSprite = sprites.create(textImage, STAMP_SPRITE_KIND); // Reuse stamp kind or new Text kind\n"]]},{"start1":28347,"length1":132,"diffs":[[1,"        textSprite.z = _drawingSprite.z + 2; // Text on top of stamps and drawings\n\n        let finalSpriteX = Math.round(_turtleX);\n        let finalSpriteY = Math.round(_turtleY);\n\n"]]},{"start1":28586,"length1":270,"diffs":[[1,"        // Adjust sprite's *center* position based on alignment relative to turtle's current (x,y)\n        if (alignStr === \"center\") {\n            finalSpriteX = Math.round(_turtleX); // Turtle X is center of text\n        } else if (alignStr === \"right\") {\n            finalSpriteX = Math.round(_turtleX - textWidth / 2); // Turtle X is right edge of text\n        } else { // \"left\"\n            finalSpriteX = Math.round(_turtleX + textWidth / 2); // Turtle X is left edge of text\n        }\n        // Turtle Y is typically the baseline or bottom-left. For simplicity, let's make it top-left.\n        // Sprite position is its center, so adjust.\n        finalSpriteY = Math.round(_turtleY + textHeight / 2);\n\n        textSprite.setPosition(finalSpriteX, finalSpriteY);\n\n"]]},{"start1":29377,"length1":142,"diffs":[[1,"            // Python Turtle's write moves pen to end of text (bottom-right for left-aligned).\n            // This is a simplification: move by text width along current heading.\n            const moveDist = textWidth;\n            const moveAngleRad = _degreesToRadians(_currentHeading);\n            _turtleX += moveDist * Math.cos(moveAngleRad);\n            _turtleY -= moveDist * Math.sin(moveAngleRad);\n"]]},{"start1":29865,"length1":54,"diffs":[[1,"            _targetX = _turtleX; // Update target\n            _targetY = _turtleY;\n"]]},{"start1":29965,"length1":0,"diffs":[[1,"    // --- Animation Setup ---\n"]]},{"start1":30196,"length1":197,"diffs":[[1,"        _ensureTurtleExists();\n        if (img) {\n            _turtleIdleFrames[direction] = img;\n            if (_currentVisualDirection === direction && _turtleAnimState === \"idle\") {\n                _updateTurtleImage();\n            }\n        }\n"]]},{"start1":30660,"length1":258,"diffs":[[1,"        _ensureTurtleExists();\n        if (anim && anim.length > 0) {\n            _turtleWalkFrames[direction] = anim;\n            if (_currentVisualDirection === direction && _turtleAnimState === \"walk\") {\n                _currentFrameIndex = 0; // Reset frame index for new animation\n                _updateTurtleImage();\n            }\n"]]},{"start1":31014,"length1":36,"diffs":[[1,"    // Initialize on load\n    reset();\n\n} // End of namespace turtle"]]}]}]},{"timestamp":1749311279242,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":4282,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"u7oRZPf55k3+ALRXEJ_u\">currentPos</variable></variables><block type=\"pxt-on-start\" x=\"-43\" y=\"-62\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":516,"diffs":[[1,"\n"]]}]}]},{"timestamp":1749311583671,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":381,"length1":97,"diffs":[[1,"    let _currentHeading: number = 0;\n"]]},{"start1":485,"length1":120,"diffs":[[1,"    let _turtleSpeed: number = 6;\n"]]},{"start1":715,"length1":158,"diffs":[[1,"    let _turtleIdleFrames: Image[] = [];\n    let _turtleWalkFrames: Image[][] = [];\n"]]},{"start1":926,"length1":62,"diffs":[[1,"    const ANIM_INTERVAL = 150;\n"]]},{"start1":1035,"length1":442,"diffs":[[1,"    let _fillColor: number = 1;\n    let _currentStampShape: string = \"turtle\";\n    let _stampStretchWidth: number = 1;\n    let _stampStretchLength: number = 1;\n    let _stampOutlineWidth: number = 1;\n"]]},{"start1":1354,"length1":161,"diffs":[[1,"    let _textFont: image.Font = image.font5;\n    enum TextAnchor { Left, Center, Right }\n"]]},{"start1":1496,"length1":77,"diffs":[[1,""]]},{"start1":1529,"length1":8915,"diffs":[[1,""]]},{"start1":1705,"length1":278,"diffs":[[1,"                _drawingImage.fill(0); // Transparent background for drawing layer\n                _drawingSprite = sprites.create(_drawingImage); // Create a normal sprite for the drawing canvas\n                _drawingSprite.z = 0; // Drawings are at base layer, above scene background\n"]]},{"start1":2008,"length1":196,"diffs":[[1,"            _turtleSprite = sprites.create(image.create(16, 16), TURTLE_SPRITE_KIND); // Placeholder image\n"]]},{"start1":2182,"length1":34,"diffs":[[1,"            _turtleSprite.z = 10; // Turtle on top of drawings, stamps, and text\n"]]},{"start1":2264,"length1":85,"diffs":[[1,"            if (_turtleIdleFrames.length === 0) {\n                _turtleIdleFrames[VisualDirection.Right] = img`\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                `.clone();\n                _turtleIdleFrames[VisualDirection.Up] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Up].flipY();\n                _turtleIdleFrames[VisualDirection.Left] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Left].flipX();\n                _turtleIdleFrames[VisualDirection.Down] = _turtleIdleFrames[VisualDirection.Up].clone();\n                _turtleIdleFrames[VisualDirection.Down].flipY();\n            }\n            if (_turtleWalkFrames.length === 0) {\n                for (let i = 0; i < 4; i++) {\n                    _turtleWalkFrames[i] = [_turtleIdleFrames[i].clone()];\n                }\n            }\n            _updateTurtleImage();\n"]]},{"start1":4157,"length1":93,"diffs":[[1,""]]},{"start1":4174,"length1":1937,"diffs":[[1,""]]},{"start1":4538,"length1":429,"diffs":[[1,"        let frames: Image[];\n        if (_turtleAnimState === \"walk\" && _turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 0) {\n            frames = _turtleWalkFrames[_currentVisualDirection];\n"]]},{"start1":4843,"length1":297,"diffs":[[1,"            frames = [_turtleIdleFrames[_currentVisualDirection]];\n        } else { return; }\n        if (frames.length > 0) {\n            _currentFrameIndex = _currentFrameIndex % frames.length;\n            _turtleSprite.setImage(frames[_currentFrameIndex]);\n"]]},{"start1":5113,"length1":317,"diffs":[[1,""]]},{"start1":5120,"length1":1,"diffs":[[1,""]]},{"start1":5261,"length1":737,"diffs":[[1,"        if (normalizedHeading >= 315 || normalizedHeading < 45) _currentVisualDirection = VisualDirection.Right;\n        else if (normalizedHeading >= 45 && normalizedHeading < 135) _currentVisualDirection = VisualDirection.Up;\n        else if (normalizedHeading >= 135 && normalizedHeading < 225) _currentVisualDirection = VisualDirection.Left;\n        else _currentVisualDirection = VisualDirection.Down;\n"]]},{"start1":5705,"length1":53,"diffs":[[1,""]]},{"start1":5821,"length1":1443,"diffs":[[1,"            _drawingImage.drawLine(Math.round(x1), Math.round(y1), Math.round(x2), Math.round(y2), _penColor);\n"]]},{"start1":6093,"length1":167,"diffs":[[1,"    let _stepAngleRad: number = 0;\n    let _movePerFrame: number = 1;\n"]]},{"start1":6164,"length1":389,"diffs":[[1,""]]},{"start1":6232,"length1":60,"diffs":[[1,""]]},{"start1":6586,"length1":61,"diffs":[[1,""]]},{"start1":6631,"length1":163,"diffs":[[1,"            _turtleAnimState = \"walk\";\n            let moveDistance = Math.min(_stepsToTake, _movePerFrame);\n"]]},{"start1":6812,"length1":198,"diffs":[[1,"            _turtleX += moveDistance * Math.cos(_stepAngleRad);\n            _turtleY -= moveDistance * Math.sin(_stepAngleRad);\n"]]},{"start1":7080,"length1":123,"diffs":[[1,"            _stepsToTake -= moveDistance;\n            if (_stepsToTake <= 0.1) {\n"]]},{"start1":7230,"length1":76,"diffs":[[1,"                _turtleX = _targetX;\n"]]},{"start1":7304,"length1":248,"diffs":[[1,"                _drawLine(prevX, prevY, _turtleX, _turtleY);\n"]]},{"start1":7452,"length1":520,"diffs":[[1,""]]},{"start1":7533,"length1":69,"diffs":[[1,""]]},{"start1":7547,"length1":203,"diffs":[[1,"        } else if (_isMoving) {\n            _isMoving = false;\n            _turtleAnimState = \"idle\";\n            _updateTurtleImage();\n"]]},{"start1":7702,"length1":4594,"diffs":[[1,""]]},{"start1":8151,"length1":222,"diffs":[[1,""]]},{"start1":8287,"length1":69,"diffs":[[1,"        _ensureTurtleExists();\n"]]},{"start1":8435,"length1":616,"diffs":[[1,"        _currentHeading = 0; _isPenDown = true; _penColor = 1;\n        _fillColor = 1; _turtleSpeed = 6; _turtleVisible = true;\n        _penSize = 1; _currentStampShape = \"turtle\";\n        _stampStretchWidth = 1; _stampStretchLength = 1; _stampOutlineWidth = 1;\n"]]},{"start1":8846,"length1":178,"diffs":[[1,"        _setVisualOrientation(); _turtleAnimState = \"idle\"; _updateTurtleImage();\n        if (_drawingImage) _drawingImage.fill(0);\n"]]},{"start1":9022,"length1":48,"diffs":[[1,"        _stamps = []; _nextStampId = 0;\n        _isMoving = false; _stepsToTake = 0;\n"]]},{"start1":9114,"length1":47,"diffs":[[1,"    //% block=\"speed %speed\"\n"]]},{"start1":9349,"length1":84,"diffs":[[1,"        _movePerFrame = (_turtleSpeed === 0) ? 1000 : Math.max(1, _turtleSpeed / 2);\n"]]},{"start1":9441,"length1":0,"diffs":[[1,"    function _moveTurtle(distance: number): void {\n        _ensureTurtleExists();\n        _turtleAnimState = \"walk\"; _updateTurtleImage();\n        const startX = _turtleX, startY = _turtleY;\n        _stepAngleRad = _degreesToRadians(_currentHeading);\n        _targetX = startX + distance * Math.cos(_stepAngleRad);\n        _targetY = startY - distance * Math.sin(_stepAngleRad);\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleAnimState = \"idle\"; _updateTurtleImage();\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            _stepsToTake = Math.abs(distance); _isMoving = true;\n        }\n    }\n"]]},{"start1":10355,"length1":123,"diffs":[[1,"    export function forward(distance: number): void { _moveTurtle(distance); }\n"]]},{"start1":10685,"length1":125,"diffs":[[1,"    export function backward(distance: number): void { _moveTurtle(-distance); }\n"]]},{"start1":11201,"length1":90,"diffs":[[1,"        _ensureTurtleExists(); _currentHeading += angle; _setVisualOrientation();\n"]]},{"start1":11573,"length1":86,"diffs":[[1,"        _ensureTurtleExists(); _currentHeading -= angle; _setVisualOrientation();\n"]]},{"start1":12815,"length1":284,"diffs":[[1,"    export function pencolor(color: number): void { _ensureTurtleExists(); _penColor = color; }\n"]]},{"start1":13006,"length1":234,"diffs":[[1,"    export function fillcolor(color: number): void { _ensureTurtleExists(); _fillColor = color; }\n"]]},{"start1":13222,"length1":125,"diffs":[[1,"    export function pensize(size: number): void { _ensureTurtleExists(); _penSize = Math.max(1, size); }\n"]]},{"start1":14512,"length1":883,"diffs":[[1,"        _ensureTurtleExists(); _currentHeading = angle; _setVisualOrientation();\n"]]},{"start1":15115,"length1":2411,"diffs":[[1,"        const startX = _turtleX, startY = _turtleY;\n        _targetX = x; _targetY = y;\n"]]},{"start1":15499,"length1":533,"diffs":[[1,"            const dx = _targetX - startX, dy = _targetY - startY;\n            _stepsToTake = Math.sqrt(dx * dx + dy * dy);\n            if (_stepsToTake < 0.1) { _isMoving = false; _stepsToTake = 0; return; }\n            _stepAngleRad = Math.atan2(-dy, dx); _isMoving = true;\n"]]},{"start1":16097,"length1":1,"diffs":[[1,""]]},{"start1":16180,"length1":750,"diffs":[[1,"        _ensureTurtleExists(); goto(screen.width / 2, screen.height / 2); setheading(0);\n"]]},{"start1":16830,"length1":243,"diffs":[[1,"        _ensureTurtleExists(); _turtleX = x; _targetX = x;\n"]]},{"start1":16937,"length1":107,"diffs":[[1,"        _isMoving = false; _stepsToTake = 0;\n"]]},{"start1":17085,"length1":179,"diffs":[[1,"        _ensureTurtleExists(); _turtleY = y; _targetY = y;\n"]]},{"start1":17192,"length1":107,"diffs":[[1,"        _isMoving = false; _stepsToTake = 0;\n"]]},{"start1":17603,"length1":97,"diffs":[[1,"        _ensureTurtleExists(); if (_drawingImage) _drawingImage.fill(0);\n"]]},{"start1":17683,"length1":705,"diffs":[[1,""]]},{"start1":17711,"length1":144,"diffs":[[1,"    //% name.options.defl=\"turtle\" name.options.enumValues=\"turtle,circle,square,arrow,triangle,classic\"\n    //% group=\"Stamping\" weight=100\n"]]},{"start1":17900,"length1":427,"diffs":[[1,"        _ensureTurtleExists(); let l = name.toLowerCase();\n        if ([\"turtle\", \"circle\", \"square\", \"arrow\", \"triangle\", \"classic\"].indexOf(l) > -1) _currentStampShape = l;\n        else { console.warn(\"Turtle: Unknown shape '\" + name + \"'. Defaulting to 'turtle'.\"); _currentStampShape = \"turtle\"; }\n"]]},{"start1":18209,"length1":1038,"diffs":[[1,"    //% block=\"shape size width %sWidth || length %sLength outline %sOutline\"\n    //% sWidth.defl=1 sLength.defl=1 sOutline.defl=1 inlineInputMode=inline group=\"Stamping\" weight=90\n    export function shapesize(sW: number, sL?: number, sO?: number): void {\n        _ensureTurtleExists(); _stampStretchWidth = Math.max(0.1, sW);\n        _stampStretchLength = (sL === undefined || sL < 0.1) ? _stampStretchWidth : Math.max(0.1, sL);\n        _stampOutlineWidth = (sO === undefined || sO < 0) ? 1 : Math.max(0, sO);\n"]]},{"start1":18728,"length1":1,"diffs":[[1,""]]},{"start1":18815,"length1":1579,"diffs":[[1,"        _ensureTurtleExists(); let stampImage: Image; const BASE = 12;\n        let w = Math.round(BASE * _stampStretchWidth), h = Math.round(BASE * _stampStretchLength);\n        if (_currentStampShape === \"circle\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - 1, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _penColor);\n"]]},{"start1":19374,"length1":0,"diffs":[[1,"            stampImage.fillCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _fillColor);\n        } else if (_currentStampShape === \"square\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawRect(0, 0, w, h, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawRect(_stampOutlineWidth - 1, _stampOutlineWidth - 1, w - 2 * (_stampOutlineWidth - 1), h - 2 * (_stampOutlineWidth - 1), _penColor);\n            }\n            stampImage.fillRect(_stampOutlineWidth, _stampOutlineWidth, w - 2 * _stampOutlineWidth, h - 2 * _stampOutlineWidth, _fillColor);\n        } else {\n            let base = _turtleIdleFrames[_currentVisualDirection] || _turtleIdleFrames[0] || img`1`;\n            stampImage = base.clone();\n"]]},{"start1":20211,"length1":1,"diffs":[[1,""]]},{"start1":20361,"length1":373,"diffs":[[1,"        stampSprite.setFlag(SpriteFlag.Ghost, true);\n        stampSprite.z = _drawingSprite.z + 1; // Stamps above drawings\n        _nextStampId++; stampSprite.data[\"stampId\"] = _nextStampId;\n        _stamps.push(stampSprite); return _nextStampId;\n"]]},{"start1":20884,"length1":100,"diffs":[[1,"                _stamps[i].destroy(); _stamps.splice(i, 1); return;\n"]]},{"start1":20983,"length1":601,"diffs":[[1,""]]},{"start1":21326,"length1":991,"diffs":[[1,"        _ensureTurtleExists(); let font = image.font5;\n        if (fontSize === 8) font = image.font8;\n        else if (fontSize === 12) font = image.font12;\n        else if (fontSize && fontSize !== 5) font = image.scaledFont(image.font5, fontSize / 5);\n        let tw = text.length * font.charWidth, th = font.charHeight;\n        let pad = Math.ceil(font.charWidth / 2);\n        let img = image.create(tw + pad, th + pad); img.fill(0);\n        img.print(text, Math.floor(pad / 2), Math.floor(pad / 2), _penColor, font);\n        let textSprite = sprites.create(img, STAMP_SPRITE_KIND);\n        textSprite.setFlag(SpriteFlag.Ghost, true);\n        textSprite.z = _drawingSprite.z + 2; // Text above stamps\n        let sx = Math.round(_turtleX), sy = Math.round(_turtleY);\n"]]},{"start1":22153,"length1":443,"diffs":[[1,"        if (alignStr === \"center\") sx = Math.round(_turtleX);\n        else if (alignStr === \"right\") sx = Math.round(_turtleX - tw / 2);\n        else sx = Math.round(_turtleX + tw / 2);\n        sy = Math.round(_turtleY + th / 2);\n        textSprite.setPosition(sx, sy);\n"]]},{"start1":22443,"length1":337,"diffs":[[1,"            const md = tw, ma = _degreesToRadians(_currentHeading);\n            _turtleX += md * Math.cos(ma); _turtleY -= md * Math.sin(ma);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _targetX = _turtleX; _targetY = _turtleY;\n"]]},{"start1":22988,"length1":388,"diffs":[[1,"        _turtleIdleFrames[direction] = img;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"idle\") _updateTurtleImage();\n"]]},{"start1":23423,"length1":372,"diffs":[[1,"        _turtleWalkFrames[direction] = anim;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"walk\") {\n            _currentFrameIndex = 0; _updateTurtleImage();\n"]]},{"start1":23626,"length1":2810,"diffs":[[1,"    reset(); // Initialize on load\n"]]}]}]},{"timestamp":1749316901934,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":11367,"length1":133,"diffs":[[1,"                _drawingSprite = sprites.create(_drawingImage, SpriteKind.배경); // MODIFICADO: Usar um SpriteKind existente se possível\n"]]}]}]},{"timestamp":1749316950321,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":205,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"D},(]p^ZMw))Q)Cq]myc\">s1</variable><variable id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"turtle_reset\"><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Red outline</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"turtle_fillcolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Yellow fill</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">14</field></shadow></value><next><block type=\"turtle_shape\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">circle</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Double size, 2px outline</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">100</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"turtle_shape\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">square</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">1x base width, 3x base height</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">3</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">80</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"turtle_clearstamp\"><value name=\"stampId\"><block type=\"variables_get\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><shadow type=\"text\"><field name=\"TEXT\">Hello from Turtle!</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_xcor\"></block></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_ycor\"></block></value><next><block type=\"turtle_write\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Score: 100</field></shadow></value><value name=\"move\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">FALSE</field></shadow></value><value name=\"align\"><shadow type=\"text\"><field name=\"TEXT\">center</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":14,"diffs":[[1,"turtle.reset()\n// Red outline\nturtle.pencolor(2)\n// Yellow fill\nturtle.fillcolor(14)\nturtle.shape(\"circle\")\n// Double size, 2px outline\nturtle.shapesize(2, 2, 2)\nturtle.goto(100, 40)\nlet s1 = turtle.stamp()\nturtle.shape(\"square\")\n// 1x base width, 3x base height\nturtle.shapesize(1, 3, 1)\nturtle.goto(80, 60)\nlet s2 = turtle.stamp()\npause(2000)\nturtle.clearstamp(s1)\npause(1000)\nturtle.print(\"Hello from Turtle!\")\nturtle.print(turtle.xcor())\nturtle.print(turtle.ycor())\nturtle.write(\n\"Score: 100\",\nfalse,\n\"center\"\n)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":249,"length1":340,"diffs":[[1,""]]},{"start1":250,"length1":169,"diffs":[[1,"    // --- State Variables ---\n    let _turtleSprite: Sprite = null;\n    let _turtleX: number = 80;\n    let _turtleY: number = 60;\n    let _currentHeading: number = 0; // 0 degrees is to the right, positive is counter-clockwise\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1;\n    let _turtleSpeed: number = 6; // 0 (fastest) to 10 (slowest in Python Turtle, but here 0 is instant, 1-10 animated)\n    let _turtleVisible: boolean = true;\n    let _penSize: number = 1;\n"]]},{"start1":736,"length1":260,"diffs":[[1,"    enum VisualDirection { Right, Up, Left, Down }\n    let _currentVisualDirection: VisualDirection = VisualDirection.Right;\n    let _turtleIdleFrames: Image[] = []; // Index by VisualDirection\n    let _turtleWalkFrames: Image[][] = []; // Index by VisualDirection, then frame index\n    let _turtleAnimState: \"idle\" | \"walk\" = \"idle\";\n    let _currentFrameIndex: number = 0;\n    let _lastAnimTime: number = 0;\n    const ANIM_INTERVAL = 150; // ms between animation frames\n\n    let _drawingImage: Image = null;\n    let _drawingSprite: Sprite = null;\n\n    let _fillColor: number = 1; // For fill operations (e.g., in stamp, and later begin_fill/end_fill)\n    let _currentShapeName: string = \"turtle\"; // Current shape of the turtle sprite itself\n    let _shapeStretchWidth: number = 1;    // Multiplier for turtle shape width\n    let _shapeStretchLength: number = 1;   // Multiplier for turtle shape length\n    let _shapeOutlineWidth: number = 1;    // Outline for turtle shape (if applicable)\n\n    const STAMP_SPRITE_KIND = SpriteKind.create();\n    let _stamps: Sprite[] = [];\n    let _nextStampId: number = 0;\n\n    // let _textFont: image.Font = image.font5; // Not directly used, font chosen in write()\n    // enum TextAnchor { Left, Center, Right } // Not directly used\n\n    const TURTLE_SPRITE_KIND = SpriteKind.create();\n    const DEFAULT_TURTLE_IMG_SIZE = 16; // Base size for turtle shape images\n\n    // --- Helper Functions ---\n\n    // NOVO: Helper para criar imagens de formas orientadas\n    function _createOrientedShapeImage(shapeName: string, direction: VisualDirection, size: number, color: number, outline: number): Image {\n        let img = image.create(size, size);\n        img.fill(0); // Transparent background (color 0)\n        const s2 = Math.round(size / 2);\n        const s4 = Math.round(size / 4);\n        const s3_8 = Math.round(size * 3 / 8);\n        const s1_8 = Math.round(size * 1 / 8);\n        const end = size - 1;\n\n        // Helper para desenhar linha com outline (simples)\n        const drawLineWithOutline = (x0: number, y0: number, x1: number, y1: number, col: number, outW: number) => {\n            if (outW > 1) { // Desenha outline mais grosso primeiro (se for o caso, simplificado)\n                // Esta é uma simplificação. Linhas grossas com outline são complexas.\n                // Por ora, o outline afeta mais as formas preenchidas.\n            }\n            img.drawLine(x0, y0, x1, y1, col);\n        };\n\n        switch (shapeName) {\n            case \"arrow\":\n                // Ponta da seta sempre na direção do movimento\n                // Corpo da seta\n                let tipX: number, tipY: number;\n                let baseX1: number, baseY1: number, baseX2: number, baseY2: number;\n\n                switch (direction) {\n                    case VisualDirection.Right: // Aponta para a direita\n                        tipX = end - s1_8; tipY = s2;\n                        img.drawLine(s1_8, s2, tipX, tipY, color); // Corpo\n                        img.drawLine(tipX - s4, tipY - s4, tipX, tipY, color); // Ponta sup\n                        img.drawLine(tipX - s4, tipY + s4, tipX, tipY, color); // Ponta inf\n                        break;\n                    case VisualDirection.Left: // Aponta para a esquerda\n                        tipX = s1_8; tipY = s2;\n                        img.drawLine(end - s1_8, s2, tipX, tipY, color); // Corpo\n                        img.drawLine(tipX + s4, tipY - s4, tipX, tipY, color); // Ponta sup\n                        img.drawLine(tipX + s4, tipY + s4, tipX, tipY, color); // Ponta inf\n                        break;\n                    case VisualDirection.Up: // Aponta para cima\n                        tipX = s2; tipY = s1_8;\n                        img.drawLine(s2, end - s1_8, tipX, tipY, color); // Corpo\n                        img.drawLine(tipX - s4, tipY + s4, tipX, tipY, color); // Ponta esq\n                        img.drawLine(tipX + s4, tipY + s4, tipX, tipY, color); // Ponta dir\n                        break;\n                    case VisualDirection.Down: // Aponta para baixo\n                        tipX = s2; tipY = end - s1_8;\n                        img.drawLine(s2, s1_8, tipX, tipY, color); // Corpo\n                        img.drawLine(tipX - s4, tipY - s4, tipX, tipY, color); // Ponta esq\n                        img.drawLine(tipX + s4, tipY - s4, tipX, tipY, color); // Ponta dir\n                        break;\n                }\n                break;\n            case \"triangle\": // Triângulo equilátero apontando na direção\n                // (Simplificado para apontar para a direita, flipX/Y fará o resto aproximadamente)\n                switch (direction) {\n                    case VisualDirection.Right:\n                        img.drawLine(s1_8, s1_8, end - s1_8, s2, color);\n                        img.drawLine(end - s1_8, s2, s1_8, end - s1_8, color);\n                        img.drawLine(s1_8, end - s1_8, s1_8, s1_8, color);\n                        break;\n                    case VisualDirection.Left:\n                        img.drawLine(end - s1_8, s1_8, s1_8, s2, color);\n                        img.drawLine(s1_8, s2, end - s1_8, end - s1_8, color);\n                        img.drawLine(end - s1_8, end - s1_8, end - s1_8, s1_8, color);\n                        break;\n                    case VisualDirection.Up:\n                        img.drawLine(s1_8, end - s1_8, s2, s1_8, color);\n                        img.drawLine(s2, s1_8, end - s1_8, end - s1_8, color);\n                        img.drawLine(end - s1_8, end - s1_8, s1_8, end - s1_8, color);\n                        break;\n                    case VisualDirection.Down:\n                        img.drawLine(s1_8, s1_8, s2, end - s1_8, color);\n                        img.drawLine(s2, end - s1_8, end - s1_8, s1_8, color);\n                        img.drawLine(end - s1_8, s1_8, s1_8, s1_8, color);\n                        break;\n                }\n                break;\n            case \"square\":\n                if (outline > 0) img.drawRect(s4, s4, s2, s2, color);\n                if (outline < size / 2) img.fillRect(s4 + outline, s4 + outline, s2 - 2 * outline, s2 - 2 * outline, _fillColor); // Usa _fillColor para preenchimento\n                break;\n            case \"circle\":\n                if (outline > 0) img.drawCircle(s2, s2, s2 - Math.max(1, outline / 2), color);\n                if (outline < s2) img.fillCircle(s2, s2, s2 - outline, _fillColor); // Usa _fillColor\n                break;\n            case \"classic\": // Tartaruga clássica do Logo (aproximação)\n                // A imagem \"classic\" é mais complexa e geralmente é um bitmap.\n                // Esta é uma representação vetorial simples.\n                // Para \"classic\", idealmente usaríamos uma imagem pixel art como a \"turtle\".\n                // Por ora, uma seta mais robusta:\n                img.drawLine(s2, s1_8, s2, end - s1_8, color); // Corpo\n                img.drawLine(s1_8, s3_8, end - s1_8, s3_8, color); // Braços\n                img.drawLine(s2, s1_8, s2 - s4, s1_8 + s4, color); // Cabeça\n                img.drawLine(s2, s1_8, s2 + s4, s1_8 + s4, color);\n                break;\n            default: // Incluindo \"turtle\"\n                return null; // Indica que deve usar as _turtleIdleFrames/_turtleWalkFrames originais\n"]]},{"start1":8069,"length1":187,"diffs":[[1,"        return img;\n    }\n"]]},{"start1":8096,"length1":229,"diffs":[[1,""]]},{"start1":8097,"length1":253,"diffs":[[1,"    function _applyCurrentShapeToTurtleSprite() {\n        if (!_turtleSprite) return;\n\n        const currentW = Math.max(1, Math.round(DEFAULT_TURTLE_IMG_SIZE * _shapeStretchWidth));\n        const currentL = Math.max(1, Math.round(DEFAULT_TURTLE_IMG_SIZE * _shapeStretchLength));\n        // Para formas não quadradas, o 'size' para _createOrientedShapeImage pode ser max(W,L)\n        const shapeImgSize = Math.max(currentW, currentL, DEFAULT_TURTLE_IMG_SIZE);\n\n\n        if (_currentShapeName === \"turtle\") {\n            // Restaurar as imagens originais da tartaruga pixel art, se necessário\n            // (elas são definidas em _ensureTurtleExists)\n            // Se _shapeStretchWidth/Length != 1, precisaríamos escalar as imagens pixel art.\n            // Image.scale() pode ser usado, mas pode distorcer pixel art.\n            // Por simplicidade, vamos assumir que \"turtle\" usa seu tamanho/animação padrão.\n            // Ou, se quisermos escalar:\n            if (_turtleIdleFrames[VisualDirection.Right]) { // Checa se a original existe\n                const baseIdleRight = turtle.getTurtleDefaultImage(VisualDirection.Right); // Precisa de uma função para pegar a original\n                const baseWalkRightFrame0 = turtle.getTurtleDefaultWalkAnimation(VisualDirection.Right, 0);\n\n                if (currentW !== baseIdleRight.width || currentL !== baseIdleRight.height) {\n                    // Escalar e recriar as 4 direções e animações\n                    // Isso é complexo para fazer bem com pixel art.\n                    // Por ora, \"turtle\" não é afetada por shapesize para manter a pixel art.\n                } else {\n                    // Restaurar se já foram modificadas\n                    _initializeTurtleDefaultFrames(); // Garante que as frames da \"turtle\" estão corretas\n                }\n            }\n\n        } else {\n            // Para formas vetoriais: \"arrow\", \"circle\", \"square\", \"triangle\", \"classic\"\n            for (let dirEnum = 0; dirEnum < 4; dirEnum++) {\n                const visualDir = dirEnum as VisualDirection;\n                let shapeImg = _createOrientedShapeImage(_currentShapeName, visualDir, shapeImgSize, _penColor, _shapeOutlineWidth);\n                if (shapeImg) {\n                    _turtleIdleFrames[visualDir] = shapeImg;\n                    // Formas vetoriais geralmente não têm animação de \"walk\" por padrão\n                    _turtleWalkFrames[visualDir] = [shapeImg.clone()];\n                } else {\n                    // Fallback se _createOrientedShapeImage retornar null (ex: forma desconhecida, ou erro)\n                    // Usar a forma \"turtle\" padrão como fallback\n                    _turtleIdleFrames[visualDir] = turtle.getTurtleDefaultImage(visualDir);\n                    _turtleWalkFrames[visualDir] = [turtle.getTurtleDefaultImage(visualDir).clone()];\n                }\n            }\n        }\n        _updateTurtleImage(); // Aplica a imagem (potencialmente nova/redimensionada) ao sprite\n"]]},{"start1":11085,"length1":214,"diffs":[[1,""]]},{"start1":11086,"length1":205,"diffs":[[1,"    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            if (!_drawingImage) {\n                _drawingImage = image.create(screen.width, screen.height);\n                // _drawingImage.fill(0); // Cor 0 é transparente. Não preencher aqui, bgcolor faz isso.\n                _drawingSprite = sprites.create(_drawingImage, SpriteKind.); // MODIFICADO: Usar um SpriteKind existente se possível\n                _drawingSprite.z = 0;\n            }\n"]]},{"start1":11553,"length1":78,"diffs":[[1,"            _initializeTurtleDefaultFrames(); // MODIFICADO: movido para função separada\n"]]},{"start1":11643,"length1":257,"diffs":[[1,"            _turtleSprite = sprites.create(_turtleIdleFrames[VisualDirection.Right], TURTLE_SPRITE_KIND);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, false);\n            _turtleSprite.z = 10;\n\n            _applyCurrentShapeToTurtleSprite(); // Aplica a forma e tamanho iniciais\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n            _setVisualOrientation(); // Garante que a orientação visual inicial está correta\n"]]},{"start1":12196,"length1":0,"diffs":[[1,"    }\n"]]},{"start1":12203,"length1":184,"diffs":[[1,"    function _initializeTurtleDefaultFrames() {\n        if (_turtleIdleFrames.length === 0 || !_turtleIdleFrames[VisualDirection.Right]) { // Verifica se já foi inicializado\n            const baseTurtleRight = img`\n                . . . . . . . . . . . . . . . .\n                . . . . . f f f . . . . . . . .\n                . . . . f 9 9 f f . . . . . . .\n                . . . f 9 1 1 9 f . . . . . . .\n                . . . f 1 1 1 9 f . . . . . . .\n                . . . f 1 1 1 9 f . . . . . . .\n                . . . f 9 1 1 9 f . . . . . . .\n                . . . . f 9 9 f f . . . . . . .\n                . . . . . f f f . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n                . . . . . . . . . . . . . . . .\n            `;\n            _turtleIdleFrames[VisualDirection.Right] = baseTurtleRight;\n            _turtleIdleFrames[VisualDirection.Up] = baseTurtleRight.clone(); _turtleIdleFrames[VisualDirection.Up].flipY(); // Aproximação\n            _turtleIdleFrames[VisualDirection.Left] = baseTurtleRight.clone(); _turtleIdleFrames[VisualDirection.Left].flipX();\n            _turtleIdleFrames[VisualDirection.Down] = _turtleIdleFrames[VisualDirection.Up].clone(); // Já flipado Y\n            // _turtleIdleFrames[VisualDirection.Down].flipY(); // Não precisa de duplo flip se Up já é a base para Down\n\n            // Animação de \"walk\" padrão (pode ser simples, só para ter algo)\n            for (let i = 0; i < 4; i++) {\n                if (!_turtleWalkFrames[i] || _turtleWalkFrames[i].length === 0) {\n                    _turtleWalkFrames[i] = [_turtleIdleFrames[i].clone()]; // Animação de 1 frame por padrão\n                }\n            }\n        }\n"]]},{"start1":14139,"length1":221,"diffs":[[1,"\n    function _degreesToRadians(degrees: number): number {\n        return degrees * (Math.PI / 180);\n"]]},{"start1":14247,"length1":668,"diffs":[[1,"    function _normalizeAngle(degrees: number): number {\n        degrees = degrees % 360;\n        if (degrees < 0) {\n            degrees += 360;\n        }\n        return degrees;\n"]]},{"start1":14432,"length1":260,"diffs":[[1,"    function _updateTurtleImage() {\n        if (!_turtleSprite) return;\n\n        // Garante que as frames para a forma atual estão carregadas\n        // _applyCurrentShapeToTurtleSprite(); // Chamado em shape() e turtlesize()\n\n        let framesToUse: Image[];\n        if (_turtleAnimState === \"walk\" &&\n            _turtleWalkFrames[_currentVisualDirection] &&\n            _turtleWalkFrames[_currentVisualDirection].length > 0) {\n            framesToUse = _turtleWalkFrames[_currentVisualDirection];\n        } else if (_turtleIdleFrames[_currentVisualDirection]) {\n            framesToUse = [_turtleIdleFrames[_currentVisualDirection]];\n        } else {\n            // Fallback se algo der muito errado\n            framesToUse = [image.create(DEFAULT_TURTLE_IMG_SIZE, DEFAULT_TURTLE_IMG_SIZE)];\n            framesToUse[0].fill(1); // Quadrado vermelho como erro\n        }\n\n        if (framesToUse.length > 0) {\n            _currentFrameIndex = _currentFrameIndex % framesToUse.length;\n            const currentImage = framesToUse[_currentFrameIndex];\n            if (currentImage) { // Checa se a imagem existe\n                _turtleSprite.setImage(currentImage);\n            }\n        }\n"]]},{"start1":15629,"length1":112,"diffs":[[1,"\n    function _setVisualOrientation() {\n        if (!_turtleSprite) return;\n        let normalizedHeading = _normalizeAngle(_currentHeading);\n\n        // Mapeia o heading matemático para uma das 4 direções visuais\n        // 0 = Direita, 90 = Cima, 180 = Esquerda, 270 = Baixo\n        if (normalizedHeading >= 315 || normalizedHeading < 45) { // Direita (Este)\n            _currentVisualDirection = VisualDirection.Right;\n        } else if (normalizedHeading >= 45 && normalizedHeading < 135) { // Cima (Norte)\n            _currentVisualDirection = VisualDirection.Up;\n        } else if (normalizedHeading >= 135 && normalizedHeading < 225) { // Esquerda (Oeste)\n            _currentVisualDirection = VisualDirection.Left;\n        } else { // Baixo (Sul) (normalizedHeading >= 225 && normalizedHeading < 315)\n            _currentVisualDirection = VisualDirection.Down;\n        }\n        _updateTurtleImage();\n"]]},{"start1":16545,"length1":112,"diffs":[[1,"    // MODIFICADO: _drawLine para respeitar _penSize\n    function _drawLine(x1: number, y1: number, x2: number, y2: number) {\n        if (_isPenDown && _drawingImage) {\n            const rX1 = Math.round(x1);\n            const rY1 = Math.round(y1);\n            const rX2 = Math.round(x2);\n            const rY2 = Math.round(y2);\n\n            if (_penSize <= 1) {\n                _drawingImage.drawLine(rX1, rY1, rX2, rY2, _penColor);\n            } else {\n                // Para linhas grossas, desenhamos uma série de círculos preenchidos\n                const radius = Math.max(1, Math.floor(_penSize / 2));\n                const dx = Math.abs(rX2 - rX1);\n                const dy = Math.abs(rY2 - rY1);\n                const sx = (rX1 < rX2) ? 1 : -1;\n                const sy = (rY1 < rY2) ? 1 : -1;\n                let err = dx - dy;\n\n                let cx = rX1;\n                let cy = rY1;\n\n                // Loop de Bresenham para desenhar círculos ao longo da linha\n                while (true) {\n                    _drawingImage.fillCircle(cx, cy, radius, _penColor);\n                    if ((cx === rX2) && (cy === rY2)) break;\n                    let e2 = 2 * err;\n                    if (e2 > -dy) { err -= dy; cx += sx; }\n                    if (e2 < dx) { err += dx; cy += sy; }\n                    // Para evitar gaps em linhas diagonais muito grossas, pode ser necessário\n                    // preencher mais densamente ou usar outra técnica (ex: desenhar retângulos).\n                    // Mas fillCircle em cada ponto de Bresenham é uma boa aproximação.\n                }\n            }\n        }\n"]]},{"start1":18174,"length1":142,"diffs":[[1,"    let _targetX: number = _turtleX;\n    let _targetY: number = _turtleY;\n    let _isMoving: boolean = false;\n    let _stepsToTake: number = 0;\n    let _stepAngleRad: number = 0; // Ângulo do segmento de movimento atual\n    let _movePerFrame: number = 1; // Distância a mover por frame de animação de movimento\n\n    // Fila de comandos para movimentos complexos como circle animado\n    interface TurtleCommand {\n        type: \"move\" | \"turn\" | \"pause\";\n        value: number; // distance for move, angle for turn, duration for pause\n        speed?: number; // speed for this specific command (optional)\n"]]},{"start1":18783,"length1":0,"diffs":[[1,"    let _commandQueue: TurtleCommand[] = [];\n    let _isProcessingQueue: boolean = false;\n"]]},{"start1":18874,"length1":422,"diffs":[[1,"\n    game.onUpdate(function () {\n        if (!_turtleSprite) return;\n\n        // Processamento da animação da tartaruga (visual)\n        if (game.runtime() - _lastAnimTime > ANIM_INTERVAL) {\n            if (_turtleAnimState === \"walk\" || (_turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 1)) {\n                _currentFrameIndex++;\n            }\n            _updateTurtleImage();\n            _lastAnimTime = game.runtime();\n        }\n\n        // Processamento do movimento da tartaruga (físico)\n        if (_isMoving && _stepsToTake > 0) {\n            _turtleAnimState = \"walk\"; // Garante que está andando enquanto se move\n            let moveDistanceThisFrame = Math.min(_stepsToTake, _movePerFrame);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n\n            _turtleX += moveDistanceThisFrame * Math.cos(_stepAngleRad);\n            _turtleY -= moveDistanceThisFrame * Math.sin(_stepAngleRad); // Y é invertido no Turtle (para cima é positivo)\n\n            _drawLine(prevX, prevY, _turtleX, _turtleY);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _stepsToTake -= moveDistanceThisFrame;\n\n            if (_stepsToTake <= 0.01) { // Usar uma pequena tolerância\n                _stepsToTake = 0;\n                _isMoving = false;\n                _turtleX = _targetX; // Ajusta para a posição exata do alvo\n                _turtleY = _targetY;\n                // Desenha o último pequeno segmento se houver diferença\n                if (Math.abs(prevX - _targetX) > 0.1 || Math.abs(prevY - _targetY) > 0.1) {\n                    _drawLine(prevX, prevY, _turtleX, _turtleY);\n                }\n                _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n\n                if (_commandQueue.length === 0) { // Só volta para idle se a fila estiver vazia\n                    _turtleAnimState = \"idle\";\n                    _updateTurtleImage();\n                } else {\n                    // Se há comandos na fila, não para, processa o próximo\n                    _processNextCommandFromQueue();\n                }\n            }\n        } else if (_isMoving) { // _stepsToTake se tornou 0 ou negativo\n            _isMoving = false;\n            if (_commandQueue.length === 0) {\n                _turtleAnimState = \"idle\";\n                _updateTurtleImage();\n            } else {\n                _processNextCommandFromQueue();\n            }\n        } else if (_commandQueue.length > 0 && !_isProcessingQueue) {\n            // Se não está se movendo, mas há comandos na fila e não estamos processando\n            _processNextCommandFromQueue();\n        }\n    });\n\n    function _addCommandToQueue(command: TurtleCommand) {\n        _commandQueue.push(command);\n        if (!_isMoving && !_isProcessingQueue) {\n            _processNextCommandFromQueue();\n        }\n"]]},{"start1":21787,"length1":48,"diffs":[[1,"    function _processNextCommandFromQueue() {\n        if (_commandQueue.length === 0) {\n            _isProcessingQueue = false;\n            if (!_isMoving) { // Garante que volta para idle se não houver mais movimento pendente\n                _turtleAnimState = \"idle\";\n                _updateTurtleImage();\n            }\n            return;\n        }\n\n        _isProcessingQueue = true;\n        const command = _commandQueue.shift();\n\n        if (command.type === \"move\") {\n            _moveTurtleInternal(command.value, command.speed);\n        } else if (command.type === \"turn\") {\n            _turnTurtleInternal(command.value);\n            // Turns são instantâneos, então processa o próximo comando\n            control.runInParallel(_processNextCommandFromQueue); // Evita recursão profunda\n        } else if (command.type === \"pause\") {\n            // Pausas precisam ser tratadas com cuidado para não bloquear o onUpdate\n            // Por enquanto, vamos assumir que pausas são tratadas externamente ou são curtas\n            // Para pausas mais longas, precisaríamos de uma máquina de estados mais complexa\n            // ou usar `control.pauseUntil` se apropriado.\n            // Para simplificar, pausas na fila podem ser apenas `pause(duration)`\n            // mas isso bloquearia.\n            // Alternativa: game.after(duration, () => _processNextCommandFromQueue());\n            game.after(command.value, () => {\n                _processNextCommandFromQueue();\n            });\n            return; // Não processa o próximo imediatamente, espera o game.after\n        }\n        // Se o comando não for uma pausa, e for um movimento que se resolve no onUpdate,\n        // o onUpdate chamará _processNextCommandFromQueue quando o movimento terminar.\n        // Se for um turno (instantâneo), já chamamos _processNextCommandFromQueue.\n        if (command.type !== \"pause\" && command.type !== \"move\") { // Se não for move (que se resolve no onUpdate) nem pause (que usa game.after)\n            _isProcessingQueue = false; // Permite que o próximo comando seja pego se a fila não estiver vazia\n        }\n    }\n\n    function _moveTurtleInternal(distance: number, speedOverride?: number): void {\n        _ensureTurtleExists();\n        // _turtleAnimState = \"walk\"; // Definido no game.onUpdate quando _isMoving\n        // _updateTurtleImage();\n\n        const effectiveSpeed = (speedOverride !== undefined) ? speedOverride : _turtleSpeed;\n\n        const startX = _turtleX;\n        const startY = _turtleY;\n        _stepAngleRad = _degreesToRadians(_currentHeading); // Usa o heading atual\n\n        _targetX = startX + distance * Math.cos(_stepAngleRad);\n        _targetY = startY - distance * Math.sin(_stepAngleRad); // Y invertido\n\n        if (effectiveSpeed === 0) { // Movimento instantâneo\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX;\n            _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _isMoving = false;\n            _stepsToTake = 0;\n            // Se for instantâneo e parte de uma fila, processa o próximo\n            if (_commandQueue.length > 0) {\n                control.runInParallel(_processNextCommandFromQueue);\n            } else {\n                _turtleAnimState = \"idle\"; // Volta para idle se for o último comando\n                _updateTurtleImage();\n                _isProcessingQueue = false;\n            }\n        } else {\n            _stepsToTake = Math.abs(distance);\n            _movePerFrame = (effectiveSpeed === 0) ? _stepsToTake : Math.max(0.1, effectiveSpeed / 2); // Ajuste para velocidade\n            if (_stepsToTake < 0.01) { // Se a distância for muito pequena\n                _stepsToTake = 0;\n                _isMoving = false;\n                if (_commandQueue.length > 0) {\n                    control.runInParallel(_processNextCommandFromQueue);\n                } else {\n                    _turtleAnimState = \"idle\";\n                    _updateTurtleImage();\n                    _isProcessingQueue = false;\n                }\n                return;\n            }\n            _isMoving = true; // O loop game.onUpdate cuidará do movimento\n        }\n    }\n\n    function _turnTurtleInternal(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading += angle;\n        _setVisualOrientation();\n    }\n\n\n    // --- Custom print function ---\n    //% block=\"print %content\"\n    //% text.shadowOptions.toString=true\n    //% group=\"Utility\" weight=100\n    export function print(content: any): void {\n        console.log(content);\n    }\n\n    // --- Screen Control ---\n    //% block=\"background color %color=colorindexpicker\"\n    //% group=\"Screen Control\" weight=90\n    export function bgcolor(color: number): void {\n        scene.setBackgroundColor(color);\n        if (_drawingImage) { // Se a tartaruga já foi usada, o fundo do _drawingImage também precisa ser limpo\n            // _drawingImage.fill(0); // Não, isso apagaria os desenhos. bgcolor não apaga desenhos.\n        }\n    }\n\n    // --- Core Turtle API ---\n    //% block=\"reset\"\n    //% group=\"Turtle State\" weight=100\n    export function reset(): void {\n        _ensureTurtleExists(); // Garante que tudo está inicializado\n        _turtleX = screen.width / 2; _targetX = _turtleX;\n        _turtleY = screen.height / 2; _targetY = _turtleY;\n        _currentHeading = 0;\n        _isPenDown = true;\n        _penColor = 1; // Cor padrão (geralmente preto ou branco dependendo da paleta)\n        _fillColor = 1;\n        _turtleSpeed = 6;\n        _turtleVisible = true;\n        _penSize = 1;\n        _currentShapeName = \"turtle\";\n        _shapeStretchWidth = 1;\n        _shapeStretchLength = 1;\n        _shapeOutlineWidth = 1;\n\n        _commandQueue = []; // Limpa a fila de comandos\n        _isMoving = false;\n        _stepsToTake = 0;\n        _isProcessingQueue = false;\n\n        _applyCurrentShapeToTurtleSprite(); // Aplica a forma padrão (turtle) e tamanho\n        _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n        _setVisualOrientation();\n        _turtleAnimState = \"idle\";\n        _updateTurtleImage();\n\n        if (_drawingImage) _drawingImage.fill(0); // Limpa a camada de desenho\n        for (let s of _stamps) s.destroy();\n        _stamps = [];\n        _nextStampId = 0;\n    }\n\n    //% block=\"speed %speed (0=fastest, 1-10)\"\n    //% speed.min=0 speed.max=10 speed.defl=6\n    //% group=\"Turtle State\" weight=90\n    export function speed(s: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, s);\n        // _movePerFrame é ajustado em _moveTurtleInternal com base na _turtleSpeed\n    }\n\n\n    //% block=\"forward %distance\" alias=fd\n    //% distance.defl=20 group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _addCommandToQueue({ type: \"move\", value: distance });\n    }\n    //% block=\"fd %distance\" group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance\" alias=bk alias=back\n    //% distance.defl=20 group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        _addCommandToQueue({ type: \"move\", value: -distance });\n    }\n    //% block=\"bk %distance\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n    //% block=\"left %angle degrees\" alias=lt\n    //% angle.defl=90 group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _addCommandToQueue({ type: \"turn\", value: angle }); // Positivo para anti-horário\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\" alias=rt\n    //% angle.defl=90 group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _addCommandToQueue({ type: \"turn\", value: -angle }); // Negativo para horário\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"pen up\" alias=pu alias=up\n    //% group=\"Pen Control\" weight=100\n    export function penup(): void { _ensureTurtleExists(); _isPenDown = false; }\n    //% block=\"pu\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen down\" alias=pd alias=down\n    //% group=\"Pen Control\" weight=90\n    export function pendown(): void { _ensureTurtleExists(); _isPenDown = true; }\n    //% block=\"pd\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"is pen down?\" group=\"Pen Control\" weight=60\n    export function isdown(): boolean { _ensureTurtleExists(); return _isPenDown; }\n\n    //% block=\"pen color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n        // Se a forma da tartaruga deve refletir a penColor (comum na Turtle do Python)\n        _applyCurrentShapeToTurtleSprite(); // Re-aplica a forma com a nova cor\n    }\n\n    //% block=\"fill color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=75\n    export function fillcolor(color: number): void {\n        _ensureTurtleExists();\n        _fillColor = color;\n        // Se a forma da tartaruga usa fillcolor para seu preenchimento\n        _applyCurrentShapeToTurtleSprite();\n    }\n\n    //% block=\"pen size %size\" alias=width\n    //% size.min=1 size.max=100 size.defl=1 group=\"Pen Control\" weight=70\n    export function pensize(size: number): void {\n        _ensureTurtleExists();\n        _penSize = Math.max(1, size);\n    }\n    //% block=\"width %size\" group=\"Pen Control\" weight=69 blockHidden=true\n    export function width(size: number): void { pensize(size); }\n\n    //% block=\"hide turtle\" alias=ht group=\"Turtle State\" weight=80\n    export function hideturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = false;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=79 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"show turtle\" alias=st group=\"Turtle State\" weight=70\n    export function showturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = true;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=69 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"is turtle visible?\" group=\"Turtle State\" weight=60\n    export function isvisible(): boolean { _ensureTurtleExists(); return _turtleVisible; }\n\n    //% block=\"set heading %angle degrees\" alias=seth\n    //% angle.defl=0 group=\"Movement\" weight=60\n    export function setheading(angle: number): void {\n        _ensureTurtleExists();\n        // Para seth, queremos que seja uma mudança de orientação, não um \"turn\" relativo.\n        // A fila de comandos é para sequências de movimento/giro. Seth é um estado.\n        // Se estiver no meio de um movimento, o que fazer? Python Turtle geralmente para o movimento.\n        if (_isMoving) { // Para o movimento atual se houver\n            _isMoving = false;\n            _stepsToTake = 0;\n            _commandQueue = []; // Limpa a fila, pois seth é um comando absoluto\n            _isProcessingQueue = false;\n        }\n        _currentHeading = angle; // Não normaliza aqui, Python Turtle permite headings > 360 ou < 0\n        _setVisualOrientation();\n        if (!_isMoving && _commandQueue.length === 0) { // Se não estava se movendo e a fila está vazia\n            _turtleAnimState = \"idle\";\n            _updateTurtleImage();\n        }\n    }\n    //% block=\"seth %angle degrees\" group=\"Movement\" weight=59 blockHidden=true\n    export function seth(angle: number): void { setheading(angle); }\n\n    //% block=\"heading\" group=\"Turtle State\" weight=50\n    export function heading(): number { _ensureTurtleExists(); return _normalizeAngle(_currentHeading); }\n\n    //% block=\"go to x %x y %y\" alias=setpos alias=setposition\n    //% x.defl=80 y.defl=60 group=\"Movement\" weight=50\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        // Similar a seth, goto é um comando absoluto.\n        if (_isMoving) {\n            _isMoving = false;\n            _stepsToTake = 0;\n            // Não limpa a fila aqui, goto pode ser um comando na fila.\n        }\n\n        const startX = _turtleX;\n        const startY = _turtleY;\n        const newTargetX = x;\n        const newTargetY = y; // Coordenadas da tela (Y para baixo)\n        // Mas a tartaruga pensa em Y para cima.\n        // A conversão é feita no cálculo do ângulo e no _turtleY -= ...\n\n        const dx = newTargetX - startX;\n        // dy precisa considerar que o Y da tartaruga é invertido em relação à tela\n        // Se a tartaruga está em (tx, ty_turtle) e quer ir para (nx, ny_turtle)\n        // ny_turtle = screen.height - ny_screen\n        // No nosso sistema, _turtleY já está no sistema \"turtle Y para cima\" relativo ao centro.\n        // Então, o dy é direto.\n        const dy = newTargetY - startY;\n\n\n        // Calcula o ângulo para o novo alvo. Não muda o heading da tartaruga.\n        const angleToTargetRad = Math.atan2(-dy, dx); // -dy porque o Y da tartaruga é para cima\n\n        // Adiciona o comando goto à fila\n        // Precisamos de um tipo de comando \"goto\" ou decompor em \"turn to target\" e \"move\"\n        // Python Turtle: goto() move a tartaruga. Se a caneta estiver abaixada, desenha.\n        // O heading da tartaruga não muda com goto().\n\n        // Para simplificar, vamos usar a lógica de _moveTurtleInternal, mas precisamos\n        // calcular a distância e o _stepAngleRad para este movimento específico.\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Criar um comando de movimento especial para goto que usa um ângulo calculado\n        // em vez do _currentHeading. Ou, mais simples, _moveTurtleInternal já usa _currentHeading.\n        // Para goto, o movimento é em direção ao ponto, não ao longo do heading atual.\n        // Isso significa que _moveTurtleInternal não serve diretamente para goto se quisermos manter o heading.\n\n        // Solução: goto é um movimento direto.\n        // Se speed = 0, é instantâneo.\n        // Se speed != 0, é animado.\n        // A fila de comandos pode ter um tipo \"goto\".\n\n        // Por ora, vamos fazer goto como um movimento direto que define _targetX, _targetY\n        // e _stepAngleRad especificamente para este movimento.\n        _targetX = newTargetX;\n        _targetY = newTargetY;\n\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            _stepsToTake = distance;\n            if (_stepsToTake < 0.01) { _isMoving = false; _stepsToTake = 0; return; }\n            _stepAngleRad = angleToTargetRad; // Usa o ângulo para o alvo, não o heading da tartaruga\n            _movePerFrame = (_turtleSpeed === 0) ? _stepsToTake : Math.max(0.1, _turtleSpeed / 2);\n            _isMoving = true;\n            // Nota: Isso fará a tartaruga se mover para o ponto, mas sua orientação visual\n            // (baseada em _currentHeading) não mudará. Isso está correto para goto().\n        }\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=49 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=48 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n\n    //% block=\"home\" group=\"Movement\" weight=40\n"]]},{"start1":38305,"length1":228,"diffs":[[1,"        _ensureTurtleExists();\n        // Home deve ser um comando que pode ser enfileirado\n        // goto(screen.width / 2, screen.height / 2);\n        // setheading(0);\n        // Por enquanto, vamos fazer direto, limpando a fila.\n        _commandQueue = [];\n        _isProcessingQueue = false;\n        _isMoving = false;\n        _stepsToTake = 0;\n\n        goto(screen.width / 2, screen.height / 2); // Isso vai animar se speed != 0\n        // Precisamos esperar goto terminar antes de seth.\n        // Com a fila, seria:\n        // _addCommandToQueue({ type: \"goto\", x: screen.width/2, y: screen.height/2 });\n        // _addCommandToQueue({ type: \"seth\", value: 0 });\n        // Por ora, seth é imediato após goto iniciar.\n        setheading(0);\n"]]},{"start1":39061,"length1":0,"diffs":[[1,"\n    //% block=\"x coordinate\" group=\"Turtle State\" weight=40\n    export function xcor(): number { _ensureTurtleExists(); return _turtleX; }\n\n    //% block=\"y coordinate\" group=\"Turtle State\" weight=39\n    export function ycor(): number { _ensureTurtleExists(); return _turtleY; }\n\n    //% block=\"position\" group=\"Turtle State\" weight=38\n    export function position(): { x: number, y: number } { _ensureTurtleExists(); return { x: _turtleX, y: _turtleY }; }\n\n    //% block=\"set x %x\" group=\"Movement\" weight=35\n    export function setx(x: number): void {\n        _ensureTurtleExists();\n        // Similar a seth, é um estado. Para o movimento atual.\n        if (_isMoving) { _isMoving = false; _stepsToTake = 0; _commandQueue = []; _isProcessingQueue = false; }\n        _turtleX = x; _targetX = x;\n        _turtleSprite.x = Math.round(_turtleX);\n        if (!_isMoving && _commandQueue.length === 0) { _turtleAnimState = \"idle\"; _updateTurtleImage(); }\n    }\n\n    //% block=\"set y %y\" group=\"Movement\" weight=34\n    export function sety(y: number): void {\n        _ensureTurtleExists();\n        if (_isMoving) { _isMoving = false; _stepsToTake = 0; _commandQueue = []; _isProcessingQueue = false; }\n        _turtleY = y; _targetY = y;\n        _turtleSprite.y = Math.round(_turtleY);\n        if (!_isMoving && _commandQueue.length === 0) { _turtleAnimState = \"idle\"; _updateTurtleImage(); }\n    }\n\n    //% block=\"distance to x %x y %y\" group=\"Turtle State\" weight=30\n    export function distance(x: number, y: number): number {\n        _ensureTurtleExists(); const dx = _turtleX - x, dy = _turtleY - y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    //% block=\"clear drawings\" group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        _ensureTurtleExists(); if (_drawingImage) _drawingImage.fill(0); // Cor 0 é transparente\n    }\n\n    // NOVO: Funções para obter as imagens padrão da tartaruga (para restauração)\n    export function getTurtleDefaultImage(direction: VisualDirection): Image {\n        _initializeTurtleDefaultFrames(); // Garante que estão carregadas\n        return _turtleIdleFrames[direction];\n    }\n    export function getTurtleDefaultWalkAnimation(direction: VisualDirection, frame: number): Image {\n        _initializeTurtleDefaultFrames();\n        if (_turtleWalkFrames[direction] && _turtleWalkFrames[direction][frame]) {\n            return _turtleWalkFrames[direction][frame];\n        }\n        return _turtleIdleFrames[direction]; // Fallback\n    }\n\n\n    // MODIFICADO: shape() para afetar o sprite da tartaruga\n    //% block=\"shape %name\"\n    //% name.options.defl=\"turtle\" name.options.enumValues=\"turtle,arrow,triangle,square,circle,classic\"\n    //% group=\"Turtle State\" weight=85\n    export function shape(name: string): void {\n        _ensureTurtleExists();\n        let lName = name.toLowerCase();\n        if ([\"turtle\", \"arrow\", \"triangle\", \"square\", \"circle\", \"classic\"].indexOf(lName) === -1) {\n            console.warn(\"Turtle: Unknown shape '\" + name + \"'. Defaulting to 'turtle'.\");\n            lName = \"turtle\";\n        }\n        _currentShapeName = lName;\n        _applyCurrentShapeToTurtleSprite(); // Aplica a nova forma (e cor/tamanho atuais)\n    }\n\n    // MODIFICADO: shapesize() para afetar o sprite da tartaruga (renomeado para turtlesize internamente para clareza)\n    // O bloco original `shapesize` do usuário era para carimbos. Vamos manter isso,\n    // mas também ter um para a tartaruga, ou fazer `shapesize` afetar ambos.\n    // Python Turtle: shapesize() ou turtlesize() afetam a tartaruga.\n    // Vamos fazer com que este `shapesize` afete a tartaruga.\n    //% block=\"turtle appearance stretch_width %sWidth || stretch_length %sLength outline %sOutline\"\n    //% sWidth.defl=1 sLength.defl=1 sOutline.defl=1 inlineInputMode=inline\n    //% group=\"Turtle State\" weight=83\n    export function turtlesize(sW?: number, sL?: number, sO?: number): void {\n        _ensureTurtleExists();\n        _shapeStretchWidth = (sW === undefined || sW <= 0) ? 1 : sW;\n        _shapeStretchLength = (sL === undefined || sL <= 0) ? _shapeStretchWidth : sL; // Se sL não for dado, usa sW\n        _shapeOutlineWidth = (sO === undefined || sO < 0) ? 1 : sO;\n        _applyCurrentShapeToTurtleSprite();\n    }\n\n\n    //% block=\"stamp\" group=\"Stamping\" weight=80\n    export function stamp(): number {\n        _ensureTurtleExists();\n        let stampImage: Image;\n        const BASE_STAMP_SIZE = 12; // Tamanho base para carimbos de formas vetoriais\n\n        // Usa a forma, tamanho e cor atuais da tartaruga para o carimbo\n        // Se a forma for \"turtle\", clona a imagem atual da tartaruga.\n        if (_currentShapeName === \"turtle\" && _turtleSprite) {\n            stampImage = _turtleSprite.image.clone(); // Clona a imagem exata da tartaruga\n        } else {\n            // Para formas vetoriais, desenha o carimbo com base nos parâmetros _shapeStretch e _currentShapeName\n            // Usa _penColor para o contorno e _fillColor para o preenchimento do carimbo.\n            const stampW = Math.round(BASE_STAMP_SIZE * _shapeStretchWidth);\n            const stampL = Math.round(BASE_STAMP_SIZE * _shapeStretchLength);\n            const stampSize = Math.max(stampW, stampL);\n\n            // Temporariamente cria uma imagem orientada para a direita para o carimbo\n            // (A rotação do carimbo em si não é suportada diretamente, ele é carimbado como está)\n            // Idealmente, o carimbo deveria ser uma cópia da tartaruga rotacionada.\n            // Por ora, carimba a forma base (orientada à direita).\n            stampImage = _createOrientedShapeImage(_currentShapeName, VisualDirection.Right, stampSize, _penColor, _shapeOutlineWidth);\n            if (!stampImage) { // Fallback se _createOrientedShapeImage falhar\n                stampImage = image.create(DEFAULT_TURTLE_IMG_SIZE, DEFAULT_TURTLE_IMG_SIZE);\n                stampImage.fill(2); // Cor de erro\n            }\n        }\n\n        let stampSprite = sprites.create(stampImage, STAMP_SPRITE_KIND);\n        stampSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        // Os carimbos devem estar abaixo da tartaruga, mas acima dos desenhos?\n        // Python Turtle: carimbos são como \"adesivos\" na tela.\n        stampSprite.z = _drawingSprite.z + 1; // Acima dos desenhos, abaixo da tartaruga\n        _nextStampId++;\n        stampSprite.data[\"stampId\"] = _nextStampId;\n        _stamps.push(stampSprite);\n        return _nextStampId;\n    }\n\n    //% block=\"clear stamp id %stampId\" group=\"Stamping\" weight=70\n    export function clearstamp(stampId: number): void {\n        _ensureTurtleExists();\n        for (let i = _stamps.length - 1; i >= 0; i--) {\n            if (_stamps[i].data[\"stampId\"] === stampId) {\n                _stamps[i].destroy();\n                _stamps.splice(i, 1);\n                return;\n            }\n        }\n    }\n\n    //% block=\"clear all stamps\" group=\"Stamping\" weight=65\n    export function clearstamps(n?: number): void {\n        _ensureTurtleExists();\n        if (n === undefined || n < 0 || n >= _stamps.length) { // Limpa todos\n            for (let s of _stamps) s.destroy();\n            _stamps = [];\n        } else { // Limpa os últimos 'n' carimbos\n            const numToClear = Math.min(n, _stamps.length);\n            for (let i = 0; i < numToClear; i++) {\n                const stampToRemove = _stamps.pop();\n                if (stampToRemove) stampToRemove.destroy();\n            }\n        }\n    }\n\n\n    //% block=\"write text %text || move %move align %align font size %fontSize\"\n    //% text.shadowOptions.toString=true move.defl=false align.defl=\"left\"\n    //% fontSize.min=5 fontSize.max=12 fontSize.defl=5 group=\"Drawing Control\" weight=70\n    export function write(text: string, move?: boolean, align?: string, fontSize?: number): void {\n        _ensureTurtleExists();\n        let fontToUse = image.font5;\n        if (fontSize === 8) fontToUse = image.font8;\n        else if (fontSize === 12) fontToUse = image.font12;\n        else if (fontSize && fontSize !== 5) {\n            // scaledFont pode não estar disponível em todas as versões do MakeCode ou pode ter limitações.\n            // Por segurança, podemos nos ater às fontes padrão ou avisar.\n            // fontToUse = image.scaledFont(image.font5, fontSize / 5);\n            console.warn(\"Turtle: Custom font scaling might not be fully supported. Using default size.\");\n        }\n\n        // Desenha o texto na _drawingImage, não como um sprite separado, para ser como a Turtle do Python.\n        // A posição é relativa à tartaruga.\n        let textWidth = text.length * fontToUse.charWidth;\n        let textHeight = fontToUse.charHeight;\n\n        let drawX = Math.round(_turtleX);\n        let drawY = Math.round(_turtleY); // Y da tartaruga (centro inferior do texto)\n\n        let alignStr = (align || \"left\").toLowerCase();\n        if (alignStr === \"center\") {\n            drawX -= textWidth / 2;\n        } else if (alignStr === \"right\") {\n            drawX -= textWidth;\n        }\n        // Se \"left\", drawX já é o início do texto.\n\n        // O Y na print é o canto superior esquerdo. Turtle Y é a base.\n        // Ajustar para que o texto apareça na linha de base da tartaruga.\n        _drawingImage.print(text, drawX, drawY - textHeight, _penColor, fontToUse);\n\n        if (move) {\n            // Move a tartaruga para a direita pelo comprimento do texto, ao longo do heading atual.\n            const moveDistance = textWidth;\n            const moveAngleRad = _degreesToRadians(_currentHeading);\n            // Adiciona comando de movimento à fila\n            _addCommandToQueue({ type: \"move\", value: moveDistance });\n        }\n    }\n\n    //% block=\"set turtle idle image for %direction to %img=screen_image_picker\"\n    //% group=\"Animation\" weight=60\n    export function setTurtleImage(direction: VisualDirection, img: Image): void {\n        _ensureTurtleExists(); if (!img) return;\n        // Só permite mudar a imagem se a forma atual for \"turtle\"\n        if (_currentShapeName === \"turtle\") {\n            _turtleIdleFrames[direction] = img;\n            if (_currentVisualDirection === direction && _turtleAnimState === \"idle\") _updateTurtleImage();\n        } else {\n            console.warn(\"Turtle: Can only set custom idle image when shape is 'turtle'.\");\n        }\n    }\n\n    //% block=\"set turtle walk animation for %direction to %anim=animation_editor\"\n    //% group=\"Animation\" weight=50\n    export function setTurtleAnimation(direction: VisualDirection, anim: Image[]): void {\n        _ensureTurtleExists(); if (!anim || anim.length === 0) return;\n        if (_currentShapeName === \"turtle\") {\n            _turtleWalkFrames[direction] = anim;\n            if (_currentVisualDirection === direction && _turtleAnimState === \"walk\") {\n                _currentFrameIndex = 0; _updateTurtleImage();\n            }\n        } else {\n            console.warn(\"Turtle: Can only set custom walk animation when shape is 'turtle'.\");\n        }\n    }\n\n    // --- NOVO: Funções Turtle adicionais ---\n\n    //% block=\"dot size %size=number || color %color=colorindexpicker\"\n    //% size.defl=5\n    //% group=\"Pen Control\" weight=50\n    export function dot(size?: number, color?: number): void {\n        _ensureTurtleExists();\n        // Python Turtle: Se size não for dado, usa max(pensize + 4, 2*pensize).\n        const dotSize = (size === undefined || size <= 0)\n            ? Math.max(_penSize + 4, 2 * _penSize)\n            : size;\n        const dotColor = (color === undefined) ? _penColor : color;\n        const radius = Math.max(1, Math.floor(dotSize / 2));\n\n        if (_drawingImage) {\n            _drawingImage.fillCircle(Math.round(_turtleX), Math.round(_turtleY), radius, dotColor);\n        }\n    }\n\n    //% block=\"circle radius %radius || extent %extent degrees steps %steps\"\n    //% radius.defl=50\n    //% extent.defl=360\n    //% group=\"Movement\" weight=30\n    export function circle(radius: number, extent?: number, steps?: number): void {\n        _ensureTurtleExists();\n        if (radius == 0) return;\n\n        const fullCircleTurns = 360;\n        let angleExtent = (extent === undefined) ? fullCircleTurns : extent;\n\n        // Python Turtle: extent=0 ou extent=360 desenha um círculo completo.\n        // Se extent for, por exemplo, 720, desenha dois círculos.\n        if (angleExtent == 0 && extent !== undefined) return; // Se extent for explicitamente 0, não faz nada.\n        if (Math.abs(angleExtent) > 10000) angleExtent = 10000 * Math.sign(angleExtent); // Limita o extent\n\n        // Heurística para número de passos, similar à da CPython Turtle\n        const numSteps = (steps === undefined || steps <= 0)\n            ? Math.floor(Math.min(12 + Math.abs(radius) / 10, 3 + Math.abs(angleExtent) / 5)) + 1\n            : Math.max(1, Math.floor(steps));\n\n        if (numSteps === 0) return;\n\n        let arcLengthTotal = 2 * Math.PI * Math.abs(radius) * (Math.abs(angleExtent) / fullCircleTurns);\n        let stepLength = arcLengthTotal / numSteps;\n        let turnAnglePerStep = angleExtent / numSteps;\n\n        // Se o raio for negativo, o centro está à direita da tartaruga, então invertemos a direção da curva.\n        if (radius < 0) {\n            turnAnglePerStep = -turnAnglePerStep;\n        }\n\n        // Adiciona comandos à fila\n        _addCommandToQueue({ type: \"turn\", value: turnAnglePerStep / 2 });\n        for (let i = 0; i < numSteps; i++) {\n            _addCommandToQueue({ type: \"move\", value: stepLength });\n            _addCommandToQueue({ type: \"turn\", value: turnAnglePerStep });\n        }\n        // Ajuste final do ângulo para completar o extent corretamente\n        _addCommandToQueue({ type: \"turn\", value: -turnAnglePerStep / 2 });\n    }\n\n\n    // Inicializa a tartaruga quando a extensão é carregada\n    reset();\n"]]}]}]},{"timestamp":1749317541900,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":133,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"turtle_home\"></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":2915,"diffs":[[1,""]]},{"start1":14,"length1":1859,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":350,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":0,"length1":107,"diffs":[[1,"/**\n * Custom Turtle Graphics Extension\n */\n//% weight=100 color=#00A654 icon=\"\\uf188\" block=\"Turtle\"\n//% groups=['Movement', 'Pen Control', 'Drawing Control', 'Turtle State', 'Stamping', 'Animation', 'Screen Control', 'Utility']\n"]]},{"start1":249,"length1":242,"diffs":[[1,"    //% color=\"#0078D7\" icon=\"\\uf188\" // Define a cor e um ícone para a categoria de blocos\n    let turtleSprite: Sprite = null;\n    let isPenDownFlag: boolean = true;\n    let penColor: number = 1; // Cor padrão (branco, por exemplo, dependendo da paleta)\n    let currentAngle: number = 0; // 0 graus = para a direita, 90 = para cima, etc.\n"]]},{"start1":590,"length1":147,"diffs":[[1,"    // Variáveis para a posição da tartaruga (o centro do sprite)\n    let turtleX: number = scene.screenWidth() / 2;\n    let turtleY: number = scene.screenHeight() / 2;\n"]]},{"start1":760,"length1":8336,"diffs":[[1,"    // Função para inicializar a tartaruga (pode ser chamada no início do jogo)\n    //% block=\"iniciar tartaruga com imagem %img=screen_image_picker\"\n    export function start(img: Image): void {\n        if (turtleSprite) {\n            turtleSprite.destroy();\n"]]},{"start1":1030,"length1":31,"diffs":[[1,"        turtleSprite = sprites.create(img, SpriteKind.Player); // Ou um novo SpriteKind\n        turtleSprite.setFlag(SpriteFlag.StayInScreen, true); // Para não sair da tela inicialmente\n"]]},{"start1":1218,"length1":870,"diffs":[[1,"        // Posição inicial e ângulo\n        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n        currentAngle = 0; // Apontando para a direita\n"]]},{"start1":1448,"length1":560,"diffs":[[1,"        isPenDownFlag = true; // Caneta abaixada por padrão\n        penColor = 1; // Cor padrão\n        // Limpar a tela ao iniciar? Ou deixar para uma função clear()?\n        // scene.backgroundImage().fill(15) // Preenche com cor de fundo (ex: preto)\n"]]},{"start1":1708,"length1":137,"diffs":[[1,"    //% block=\"tartaruga para frente %distancia pixels\"\n    //% distancia.defl=50\n    export function forward(distancia: number): void {\n        if (!turtleSprite) return; // Só executa se a tartaruga foi iniciada\n"]]},{"start1":1923,"length1":154,"diffs":[[1,"        const radianos = currentAngle * Math.PI / 180;\n        const deltaX = Math.cos(radianos) * distancia;\n        const deltaY = Math.sin(radianos) * distancia; // No MakeCode, Y positivo é para baixo\n"]]},{"start1":2129,"length1":596,"diffs":[[1,"        const newX = turtleX + deltaX;\n        const newY = turtleY + deltaY;\n"]]},{"start1":2208,"length1":337,"diffs":[[1,"        if (isPenDownFlag) {\n            scene.backgroundImage().drawLine(\n                Math.round(turtleX),\n                Math.round(turtleY),\n                Math.round(newX),\n                Math.round(newY),\n                penColor\n            );\n"]]},{"start1":2475,"length1":6,"diffs":[[1,""]]},{"start1":2476,"length1":2915,"diffs":[[1,"        turtleX = newX;\n        turtleY = newY;\n        turtleSprite.setPosition(turtleX, turtleY);\n        // Adicionar um pequeno pause para ver o movimento?\n        // pause(100); \n"]]},{"start1":2667,"length1":197,"diffs":[[1,"    //% block=\"tartaruga para trás %distancia pixels\"\n    //% distancia.defl=50\n    export function backward(distancia: number): void {\n        forward(-distancia); // Reutiliza a lógica do forward com distância negativa\n"]]},{"start1":2895,"length1":268,"diffs":[[1,"    //% block=\"tartaruga virar à esquerda %angulo graus\"\n    //% angulo.defl=90\n    export function turnLeft(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle -= angulo;\n        // Para manter o ângulo entre 0-359 se quisermos\n        // currentAngle = (currentAngle % 360 + 360) % 360; \n        // Girar o sprite (MakeCode não tem uma rotação simples de sprite por ângulo,\n        // então vamos controlar a direção pelo currentAngle e o sprite pode sempre\n        // apontar para uma direção fixa ou ter múltiplas imagens para diferentes ângulos)\n        // Por enquanto, a imagem do sprite não vai girar, apenas a lógica de movimento.\n"]]},{"start1":3569,"length1":306,"diffs":[[1,""]]},{"start1":3570,"length1":317,"diffs":[[1,"    //% block=\"tartaruga virar à direita %angulo graus\"\n    //% angulo.defl=90\n    export function turnRight(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle += angulo;\n        // currentAngle = (currentAngle % 360 + 360) % 360;\n"]]},{"start1":3836,"length1":139,"diffs":[[1,""]]},{"start1":3837,"length1":314,"diffs":[[1,"    //% block=\"levantar caneta da tartaruga\"\n    export function penUp(): void {\n        isPenDownFlag = false;\n"]]},{"start1":3955,"length1":140,"diffs":[[1,""]]},{"start1":3956,"length1":808,"diffs":[[1,"    //% block=\"abaixar caneta da tartaruga\"\n    export function penDown(): void {\n        isPenDownFlag = true;\n"]]},{"start1":4074,"length1":306,"diffs":[[1,""]]},{"start1":4075,"length1":287,"diffs":[[1,"    //% block=\"definir cor da caneta para %cor=colorindexpicker\"\n    export function setPenColor(cor: number): void {\n        penColor = cor;\n"]]},{"start1":4223,"length1":158,"diffs":[[1,""]]},{"start1":4224,"length1":4828,"diffs":[[1,"    //% block=\"limpar desenhos da tartaruga\"\n"]]},{"start1":4305,"length1":122,"diffs":[[1,"        // Preenche a tela com a cor de fundo (ex: 15 para preto, ou 0 para transparente se for sobre outra imagem)\n        // Você pode querer que isso seja configurável ou use a cor de fundo atual.\n        const backgroundColor = scene.backgroundColor(); // Pega a cor de fundo atual\n        scene.backgroundImage().fill(backgroundColor);\n"]]},{"start1":4653,"length1":475,"diffs":[[1,"    //% block=\"tartaruga ir para casa (centro)\"\n    export function home(): void {\n        if (!turtleSprite) return;\n        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n        currentAngle = 0; // Apontando para a direita\n"]]},{"start1":4970,"length1":128,"diffs":[[1,""]]}]}]},{"timestamp":1749318016864,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":266,"length1":77,"diffs":[[1,""]]},{"start1":369,"length1":258,"diffs":[[1,"    let _turtleX: number = scene.screenWidth() / 2;\n    let _turtleY: number = scene.screenHeight() / 2;\n"]]},{"start1":516,"length1":114,"diffs":[[1,""]]},{"start1":858,"length1":22,"diffs":[[1,"    const DIR_UP = 1;    // Corresponde ao ângulo de -90 ou 270 graus (para cima na tela)\n"]]},{"start1":972,"length1":24,"diffs":[[1,"    const DIR_DOWN = 3;  // Corresponde ao ângulo de 90 graus (para baixo na tela)\n"]]},{"start1":1056,"length1":77,"diffs":[[1,"    let _currentVisualDirection = DIR_RIGHT;\n"]]},{"start1":1176,"length1":108,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA ---\n    // Você já forneceu a imagem base, vou usar uma similar para R_idle, R_walk1, R_walk2\n    // Por favor, substitua estas com as suas imagens exatas se forem diferentes.\n\n"]]},{"start1":1992,"length1":7,"diffs":[[1,"    `; // Exemplo de tartaruga verde simples - substitua pela sua\n"]]},{"start1":2666,"length1":7,"diffs":[[1,"    `; // Exemplo - substitua pela sua\n"]]},{"start1":3313,"length1":7,"diffs":[[1,"    `; // Exemplo - substitua pela sua\n"]]},{"start1":3655,"length1":0,"diffs":[[1,"    // Copie a 'turtle_R_idle', cole como 'turtle_U_idle', abra no editor e rotacione.\n    // Repita para walk1, walk2 e para as versões _D_ (para baixo).\n"]]},{"start1":7909,"length1":533,"diffs":[[1,""]]},{"start1":7910,"length1":1,"diffs":[[1,""]]},{"start1":7951,"length1":1375,"diffs":[[1,"        _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n        _turtleWalkFrames = [\n            [turtle_R_walk1, turtle_R_walk2], // Direita (DIR_RIGHT = 0)\n            [turtle_U_walk1, turtle_U_walk2], // Cima    (DIR_UP = 1)\n            [turtle_L_walk1, turtle_L_walk2], // Esquerda(DIR_LEFT = 2)\n            [turtle_D_walk1, turtle_D_walk2]  // Baixo   (DIR_DOWN = 3)\n        ];\n"]]},{"start1":8376,"length1":3533,"diffs":[[1,"    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0; // Mais rápido (quase instantâneo)\n        let duration = ANIMATION_FRAME_DURATION;\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            // Python: 1=slowest, 10=fast.\n            // MakeCode: vamos fazer speed 1 = mais lento (maior pausa), speed 10 = mais rápido (menor pausa)\n            duration = 25 + (10 - _turtleSpeed) * 25; // Ex: speed 1 -> 250ms, speed 10 -> 25ms\n"]]},{"start1":8863,"length1":20,"diffs":[[1,"        return duration;\n"]]},{"start1":8895,"length1":1995,"diffs":[[1,""]]},{"start1":8962,"length1":751,"diffs":[[1,"            _initializeTurtleFrames();\n            // Verifica se todas as imagens foram carregadas (simplesmente checando se não são nulas)\n            // Se alguma imagem estiver faltando (porque não foi colada), isso pode causar um erro aqui.\n            if (!_turtleIdleFrames[0] || !_turtleIdleFrames[1] || !_turtleIdleFrames[2] || !_turtleIdleFrames[3] ||\n                !_turtleWalkFrames[0][0] || !_turtleWalkFrames[1][0] || !_turtleWalkFrames[2][0] || !_turtleWalkFrames[3][0]) {\n                console.error(\"TURTLE EXTENSION: One or more turtle images are missing. Please define all idle and walk frames.\");\n                // Poderia lançar um erro ou usar uma imagem padrão de fallback\n                // Por agora, apenas loga e continua, o que pode levar a erros visuais.\n"]]},{"start1":9765,"length1":244,"diffs":[[1,""]]},{"start1":9766,"length1":81,"diffs":[[1,"            _turtleSprite = sprites.create(_turtleIdleFrames[DIR_RIGHT], SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n            _turtleX = scene.screenWidth() / 2;\n            _turtleY = scene.screenHeight() / 2;\n            _turtleSprite.setPosition(_turtleX, _turtleY);\n            _currentHeading = 0; // Direita\n            _currentVisualDirection = DIR_RIGHT;\n            _isPenDown = true;\n            _penColor = 1; // Branco\n            _isTurtleVisible = true;\n            _setVisualOrientation();\n"]]},{"start1":10333,"length1":488,"diffs":[[1,"    function _setVisualOrientation() {\n        _ensureTurtleExists();\n        let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n"]]},{"start1":10471,"length1":740,"diffs":[[1,"        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo\n        // _currentVisualDirection: DIR_RIGHT=0, DIR_UP=1, DIR_LEFT=2, DIR_DOWN=3\n"]]},{"start1":10626,"length1":193,"diffs":[[1,"        if (normalizedAngle >= 315 || normalizedAngle < 45) {       // 0 graus +/- 45 -> Direita\n            _currentVisualDirection = DIR_RIGHT;\n        } else if (normalizedAngle >= 45 && normalizedAngle < 135) {  // 90 graus +/- 45 -> Cima\n            _currentVisualDirection = DIR_UP;\n        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // 180 graus +/- 45 -> Esquerda\n            _currentVisualDirection = DIR_LEFT;\n        } else { // (normalizedAngle >= 225 && normalizedAngle < 315) // 270 graus +/- 45 -> Baixo\n            _currentVisualDirection = DIR_DOWN;\n        }\n"]]},{"start1":11223,"length1":309,"diffs":[[1,"        if (_isTurtleVisible && _turtleIdleFrames[_currentVisualDirection]) {\n            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n        } else if (!_turtleIdleFrames[_currentVisualDirection]) {\n            console.warn(\"TURTLE: Idle frame missing for current visual direction: \" + _currentVisualDirection);\n"]]},{"start1":11816,"length1":0,"diffs":[[1,"        const isMovingBackward = distance < 0; // Não usado diretamente aqui, mas pode ser útil\n"]]},{"start1":11960,"length1":44,"diffs":[[1,"        const effectiveDistance = distance; // Usar a distância com sinal para direção\n"]]},{"start1":12048,"length1":0,"diffs":[[1,"        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo (Padrão Turtle Python)\n"]]},{"start1":12200,"length1":0,"diffs":[[1,"\n        // MakeCode Y aumenta para baixo.\n        // Se heading é 90 (Cima), sin(90)=1. Queremos Y diminuindo. Então -sin().\n"]]},{"start1":12393,"length1":100,"diffs":[[1,"        const totalDeltaY = -Math.sin(radians) * effectiveDistance; // Y invertido para MakeCode\n"]]},{"start1":12732,"length1":0,"diffs":[[1,"        // A direção visual já foi definida por _setVisualOrientation após left/right/seth\n        const walkCycle = _turtleWalkFrames[_currentVisualDirection];\n"]]},{"start1":12948,"length1":0,"diffs":[[1,"        if (!walkCycle || walkCycle.length === 0 || !walkCycle[0]) {\n            console.warn(\"TURTLE: Walk cycle missing or empty for current visual direction: \" + _currentVisualDirection);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n            _turtleX += totalDeltaX;\n            _turtleY += totalDeltaY;\n            if (_isPenDown) {\n                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n            }\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            if (_isTurtleVisible) _setVisualOrientation();\n            return;\n        }\n\n"]]},{"start1":13699,"length1":84,"diffs":[[1,"            if (_isTurtleVisible) {\n                _turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n            }\n            currentWalkFrameIndex = (currentWalkFrameIndex + 1) % walkCycle.length;\n"]]},{"start1":13908,"length1":70,"diffs":[[1,"            const prevX = _turtleX;\n            const prevY = _turtleY;\n"]]},{"start1":13981,"length1":0,"diffs":[[1,"            _turtleX += stepDx;\n            _turtleY += stepDy;\n\n"]]},{"start1":14076,"length1":262,"diffs":[[1,"                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n"]]},{"start1":14233,"length1":661,"diffs":[[1,"            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n"]]},{"start1":14445,"length1":88,"diffs":[[1,"            _setVisualOrientation();\n"]]},{"start1":14560,"length1":122,"diffs":[[1,"    //% group=\"Movement\" weight=99\n    //% blockHidden=true\n    export function fd(distance: number): void {\n        forward(distance);\n    }\n"]]},{"start1":14887,"length1":28,"diffs":[[1,"        forward(-distance); // forward já lida com distância negativa para animação\n"]]},{"start1":15479,"length1":69,"diffs":[[1,"        _currentHeading += angle; // CORREÇÃO: left aumenta o ângulo (gira anti-horário)\n        _setVisualOrientation();\n"]]},{"start1":15943,"length1":69,"diffs":[[1,"        _currentHeading -= angle; // CORREÇÃO: right diminui o ângulo (gira horário)\n        _setVisualOrientation();\n"]]},{"start1":16278,"length1":26,"diffs":[[1,"    //% x.defl=80 y.defl=60\n"]]},{"start1":16427,"length1":406,"diffs":[[1,"        // Coordenadas MakeCode: (0,0) canto superior esquerdo.\n        // Turtle Python: (0,0) centro.\n        // Esta extensão usa coordenadas MakeCode para goto.\n        // Se quiser simular o centro, o usuário da extensão precisaria ajustar.\n\n        if (_isPenDown) { // Turtle Python não desenha em goto por padrão, mas alguns podem querer\n            // scene.backgroundImage().drawLine(Math.round(_turtleX), Math.round(_turtleY), Math.round(x), Math.round(y), _penColor);\n        }\n        _turtleX = x;\n        _turtleY = y;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n"]]},{"start1":17583,"length1":35,"diffs":[[1,"        _setVisualOrientation();\n"]]},{"start1":17903,"length1":222,"diffs":[[1,"        _turtleX = scene.screenWidth() / 2;\n        _turtleY = scene.screenHeight() / 2;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n        _currentHeading = 0; // Padrão Turtle Python: 0 é para a direita\n        _setVisualOrientation();\n        // Turtle Python também redefine a caneta para baixo e cor padrão, etc.\n"]]},{"start1":18309,"length1":0,"diffs":[[1,"        // pencolor(1); // Opcional\n"]]},{"start1":18574,"length1":66,"diffs":[[1,"        _turtleSpeed = Math.clamp(0, 10, speedValue);\n"]]},{"start1":19712,"length1":178,"diffs":[[1,""]]},{"start1":19951,"length1":39,"diffs":[[1,"    //% widthNum.defl=1\n"]]},{"start1":20098,"length1":59,"diffs":[[1,"        // Implementação básica: por enquanto não afeta a linha visualmente.\n        // Para implementar, precisaríamos mudar a lógica de drawLine.\n        console.log(\"pensize (\" + widthNum + \") not fully implemented yet for visual line thickness.\");\n"]]},{"start1":20525,"length1":758,"diffs":[[1,""]]},{"start1":20660,"length1":0,"diffs":[[1,"        // Retorna o ângulo normalizado entre 0 e 360\n"]]},{"start1":20950,"length1":75,"diffs":[[1,"        return { x: Math.round(_turtleX), y: Math.round(_turtleY) };\n"]]},{"start1":21305,"length1":40,"diffs":[[1,"        return Math.round(_turtleX);\n"]]},{"start1":21485,"length1":40,"diffs":[[1,"        return Math.round(_turtleY);\n"]]},{"start1":21723,"length1":82,"diffs":[[1,"        _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        _setVisualOrientation();\n"]]},{"start1":22134,"length1":162,"diffs":[[1,"        _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n"]]},{"start1":22645,"length1":0,"diffs":[[1,"        // Limpa apenas os desenhos, não afeta a tartaruga\n"]]},{"start1":22881,"length1":0,"diffs":[[1,"        _ensureTurtleExists();\n"]]},{"start1":22978,"length1":78,"diffs":[[1,"            _turtleSprite = null;\n"]]},{"start1":23022,"length1":419,"diffs":[[1,"        scene.backgroundImage().fill(scene.backgroundColor());\n"]]},{"start1":23153,"length1":278,"diffs":[[1,"        home();\n        pendown();\n        pencolor(1);\n        speed(6);\n        showturtle();\n"]]},{"start1":23356,"length1":499,"diffs":[[1,"    _ensureTurtleExists();\n"]]}]}]},{"timestamp":1749318690111,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"turtle.ts","patch":[{"start1":14498,"length1":91,"diffs":[[1,"                // Rotaciona a imagem. image.rotate é no sentido horário.\n                // _currentHeading: 0=Direita, 90=Cima.\n                // Para imagem: 0=original, 90=rotacionada 90° horário (Baixo no nosso sistema de heading)\n                // Então, rotação da imagem = -_currentHeading.\n                finalImage.rotate(-_currentHeading);\n"]]}]}]},{"timestamp":1749318705633,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":581,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"36\" y=\"52\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":37,"diffs":[[1,"\n// Código de Teste para a Extensão Turtle\n// Coloque este código no seu main.ts\n\n// --- Início dos Testes ---\ngame.splash(\"Iniciando Testes da Turtle...\")\npause(1000)\n\n// 1. Setup Inicial e Quadrado\nturtle.reset()\nturtle.speed(6) // Velocidade média para observação\ngame.splash(\"Teste 1: Quadrado Vermelho\")\nturtle.pencolor(2) // Vermelho\nturtle.pendown()\nfor (let i = 0; i < 4; i++) {\n    turtle.forward(50)\n    turtle.right(90) // Deve virar à direita (horário)\n}\npause(1500)\n\n// 2. Mover sem Desenhar e Triângulo com heading\ngame.splash(\"Teste 2: Mover e Triângulo Azul\")\nturtle.penup()\nturtle.goto(20, 30)\nturtle.setheading(0) // Apontar para a direita\n\nturtle.pencolor(4) // Azul\nturtle.pendown()\nfor (let i = 0; i < 3; i++) {\n    turtle.forward(40)\n    turtle.left(120) // Deve virar à esquerda (anti-horário)\n}\npause(1500)\n\n// 3. Testar hideturtle e showturtle\ngame.splash(\"Teste 3: Esconder/Mostrar Tartaruga\")\nturtle.hideturtle()\ngame.splash(\"Tartaruga escondida, movendo...\")\nturtle.pencolor(14) // Amarelo escuro\nturtle.forward(25)\npause(1000)\n\nturtle.showturtle()\ngame.splash(\"Tartaruga visível, movendo para trás...\")\nturtle.backward(20)\npause(1500)\n\n// 4. Testar home e clear\ngame.splash(\"Teste 4: Home e Clear\")\nturtle.home() // Volta para o centro, heading 0\nturtle.pencolor(5) // Roxo\nturtle.forward(30)\npause(1000)\n\nturtle.clear() // Limpa o desenho, tartaruga permanece\ngame.splash(\"Desenhos limpos. Tartaruga no lugar.\")\nturtle.right(45)\nturtle.forward(20) // Desenha algo para confirmar\npause(1500)\n\n// 5. Testar reset\ngame.splash(\"Teste 5: Reset Total\")\nturtle.reset()\n// Tela limpa, tartaruga no centro, virada para direita, caneta branca/1, abaixada\nturtle.forward(25) // Deve desenhar uma linha branca/padrão\npause(1500)\n\n// 6. Testar diferentes velocidades\ngame.splash(\"Teste 6: Velocidades\")\nturtle.reset()\nturtle.pencolor(7) // Laranja\nturtle.goto(40, 60)\n\ngame.splash(\"Velocidade 1 (Lenta)\")\nturtle.speed(1)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 10 (Rápida)\")\nturtle.speed(10)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 0 (Instantânea)\")\nturtle.speed(0)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\nturtle.speed(6) // Volta para uma velocidade padrão\npause(1500)\n\n// 7. Testar pensize (chamada de função)\ngame.splash(\"Teste 7: Pensize (ver console)\")\nconsole.log(\"--- Teste Pensize ---\")\nconsole.log(\"Chamando turtle.pensize(5)\")\nturtle.pensize(5)\nturtle.pencolor(3) // Verde claro\nturtle.forward(15)\nconsole.log(\"Chamando turtle.pensize(1)\")\nturtle.pensize(1)\nturtle.backward(15) // Para ver a linha sobreposta se pensize funcionasse visualmente\npause(1500)\n\n// 8. Testar limites da tela e heading para todas as direções\ngame.splash(\"Teste 8: Direções Cardeais\")\nturtle.reset()\nturtle.speed(4)\n\n// Direita (0 graus)\nturtle.setheading(0)\nturtle.pencolor(2) // Vermelho\nturtle.forward(60)\npause(500)\n\n// Cima (90 graus)\nturtle.home()\nturtle.setheading(90)\nturtle.pencolor(4) // Azul\nturtle.forward(40)\npause(500)\n\n// Esquerda (180 graus)\nturtle.home()\nturtle.setheading(180)\nturtle.pencolor(3) // Verde\nturtle.forward(60)\npause(500)\n\n// Baixo (270 graus)\nturtle.home()\nturtle.setheading(270)\nturtle.pencolor(5) // Roxo\nturtle.forward(40)\npause(1000)\n\n// 9. Teste de \"estrela\" ou padrão radial\ngame.splash(\"Teste 9: Padrão Radial\")\nturtle.reset()\nturtle.speed(7)\nturtle.pencolor(10) // Rosa\nfor (let i = 0; i < 12; i++) {\n    turtle.forward(50)\n    turtle.backward(50) // Volta para o centro\n    turtle.right(30)    // Gira 30 graus\n}\npause(1500)\n\n// 10. Testar estado da caneta com isdown()\ngame.splash(\"Teste 10: Estado da Caneta (isdown)\")\nturtle.reset()\nturtle.speed(5)\nturtle.pencolor(1)\nconsole.log(\"--- Teste isdown ---\")\nconsole.log(\"Pen deve estar DOWN por padrão após reset: \" + turtle.isdown()) // True\nturtle.forward(20)\nturtle.penup()\nconsole.log(\"Pen deve estar UP: \" + turtle.isdown()) // False\nturtle.forward(20) // Não deve desenhar\nturtle.pendown()\nconsole.log(\"Pen deve estar DOWN: \" + turtle.isdown()) // True\nturtle.forward(20)\npause(1500)\n\n// 11. Testar informações de estado (heading, xcor, ycor, position)\ngame.splash(\"Teste 11: Info de Estado (ver console)\")\nturtle.reset()\nturtle.goto(10, 20)\nturtle.setheading(45)\nconsole.log(\"--- Teste Info Estado ---\")\nconsole.log(\"Heading esperado ~45: \" + turtle.heading())\nconsole.log(\"XCOR esperado ~10: \" + turtle.xcor())\nconsole.log(\"YCOR esperado ~20: \" + turtle.ycor())\nlet currentPos = turtle.position()\nconsole.log(\"Position esperada x:~10, y:~20 : x=\" + currentPos.x + \", y=\" + currentPos.y)\nturtle.forward(10)\nconsole.log(\"Novo Heading (ainda 45): \" + turtle.heading())\ncurrentPos = turtle.position()\nconsole.log(\"Nova Posição: x=\" + currentPos.x + \", y=\" + currentPos.y)\npause(1000)\n\n\ngame.splash(\"Testes Concluídos!\")"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":49,"length1":0,"diffs":[[1,"// Namespace agora é \"turtle\" para corresponder ao Python\n"]]},{"start1":200,"length1":131,"diffs":[[1,"    let _penColor: number = 1; // Cor padrão (branco no MakeCode)\n    let _penThickness: number = 1; // Nova variável para espessura da caneta\n    let _currentHeading: number = 0; // 0 graus = para a direita (padrão do MakeCode e Turtle Python)\n"]]},{"start1":531,"length1":0,"diffs":[[1,"    // Internamente, armazenamos como coordenadas Turtle e convertemos para/de MakeCode quando necessário.\n"]]},{"start1":746,"length1":0,"diffs":[[1,"    let _currentShape: string = \"turtle\"; // Formas: \"turtle\", \"arrow\", \"circle\", \"square\", \"triangle\", \"classic\"\n"]]},{"start1":861,"length1":142,"diffs":[[1,"    // --- Constantes de Animação ---\n    const ANIMATION_FRAME_DURATION = 150; // ms entre frames da caminhada\n    const PIXELS_PER_STEP = 4; // Quantos pixels a tartaruga anda por frame de animação\n    let _turtleSpeed = 6; // Padrão do Python (0-10, 0 é o mais rápido).\n"]]},{"start1":1273,"length1":45,"diffs":[[1,"    let _currentVisualDirection = DIR_RIGHT; // Apenas para a forma \"turtle\"\n"]]},{"start1":1425,"length1":36,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA (para _currentShape === \"turtle\") ---\n"]]},{"start1":1564,"length1":296,"diffs":[[1,"    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n"]]},{"start1":3601,"length1":0,"diffs":[[1,"    // !!! IMPORTANTE: CRIE ESTAS IMAGENS MANUALMENTE NO EDITOR DE SPRITES !!!\n"]]},{"start1":3711,"length1":640,"diffs":[[1,"    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n"]]},{"start1":8070,"length1":0,"diffs":[[1,"    function _screenToTurtleX(screenX: number): number {\n        return screenX - scene.screenWidth() / 2;\n    }\n    function _screenToTurtleY(screenY: number): number {\n        return scene.screenHeight() / 2 - screenY; // Y invertido\n    }\n"]]},{"start1":8313,"length1":0,"diffs":[[1,"\n"]]},{"start1":8355,"length1":98,"diffs":[[1,"        // Só inicializa se não tiver sido feito ou se as imagens forem nulas\n        if (!_turtleIdleFrames || !_turtleIdleFrames[0]) {\n"]]},{"start1":8835,"length1":172,"diffs":[[1,"            // Validação simples\n"]]},{"start1":8910,"length1":209,"diffs":[[1,"                if (!_turtleIdleFrames[i] || !_turtleWalkFrames[i] || !_turtleWalkFrames[i][0] || !_turtleWalkFrames[i][1]) {\n                    console.warn(`TURTLE: Missing image frames for 'turtle' shape, direction ${i}. Animation may not work correctly.`);\n                    // Usar uma imagem de fallback se alguma estiver faltando para evitar crash\n                    const fallbackImg = image.create(16, 16); fallbackImg.fill(1); fallbackImg.drawRect(0, 0, 16, 16, 7);\n                    if (!_turtleIdleFrames[i]) _turtleIdleFrames[i] = fallbackImg;\n                    if (!_turtleWalkFrames[i] || !_turtleWalkFrames[i][0]) _turtleWalkFrames[i] = [fallbackImg, fallbackImg];\n                    if (!_turtleWalkFrames[i][1]) _turtleWalkFrames[i][1] = fallbackImg;\n"]]},{"start1":9706,"length1":307,"diffs":[[1,""]]},{"start1":9737,"length1":0,"diffs":[[1,"    function _createShapeImage(shapeName: string, size: number = 16, color: number = _penColor): Image {\n        let img = image.create(size, size);\n        // Centralizar a forma na imagem para melhor rotação\n        let s2 = Math.floor(size / 2);\n        let s4 = Math.floor(size / 4);\n        let s34 = Math.floor(size * 3 / 4);\n\n        switch (shapeName.toLowerCase()) {\n            case \"circle\":\n                img.drawCircle(s2, s2, s2 - 2, color); // Contorno\n                img.fillCircle(s2, s2, s2 - 3, color); // Preenchimento\n                break;\n            case \"square\":\n                img.fillRect(s4, s4, s2, s2, color);\n                break;\n            case \"arrow\": // Triângulo apontando para a direita\n                img.drawLine(s34, s2, s4, s4, color);       // Top\n                img.drawLine(s4, s4, s4, s34, color);       // Left base\n                img.drawLine(s4, s34, s34, s2, color);      // Bottom\n                // Preenchimento simples (pode não ser perfeito para todos os tamanhos)\n                for (let y = s4 + 1; y < s34; y++) {\n                    let x_start = s4;\n                    let x_end = s4 + Math.floor(((y - s4) / (s2 - s4)) * (s34 - s4));\n                    if (y > s2) {\n                        x_end = s4 + Math.floor(((s34 - y) / (s34 - s2)) * (s34 - s4));\n                    }\n                    img.drawLine(x_start, y, x_end, y, color);\n                }\n                break;\n            case \"triangle\": // Similar ao arrow\n                img.drawLine(s2, s4, s4, s34, color);       // Left\n                img.drawLine(s4, s34, s34, s34, color);     // Bottom\n                img.drawLine(s34, s34, s2, s4, color);      // Right\n                // Preenchimento\n                for (let y = s4; y <= s34; y++) {\n                    let prog = (y - s4) / (s34 - s4);\n                    let x_start = s2 - Math.floor(prog * (s2 - s4));\n                    let x_end = s2 + Math.floor(prog * (s34 - s2));\n                    img.drawLine(x_start, y, x_end, y, color);\n                }\n                break;\n            case \"classic\": // Uma seta mais fina, como a do Python Turtle\n                // Pontos para \"classic\" (0,0), (-5,-9), (0,-7), (5,-9) - adaptado e escalado\n                // Nariz em (s2, s2 + s4/2), corpo para baixo\n                let classic_pts = [\n                    s2, s4,             // Ponto superior (nariz)\n                    s2 - s4, s2 + s4,   // Inferior esquerdo\n                    s2, s2 + s4 / 2,      // Meio (entalhe)\n                    s2 + s4, s2 + s4    // Inferior direito\n                ];\n                // Desenha o polígono (contorno)\n                img.drawLine(classic_pts[0], classic_pts[1], classic_pts[2], classic_pts[3], color);\n                img.drawLine(classic_pts[2], classic_pts[3], classic_pts[4], classic_pts[5], color);\n                img.drawLine(classic_pts[4], classic_pts[5], classic_pts[6], classic_pts[7], color);\n                img.drawLine(classic_pts[6], classic_pts[7], classic_pts[0], classic_pts[1], color);\n                // Preenchimento seria mais complexo, deixar como contorno por enquanto ou usar uma imagem pré-feita.\n                // Para simplificar, usar a mesma imagem do \"arrow\" por enquanto.\n                return _createShapeImage(\"arrow\", size, color);\n\n            default: // Fallback para um quadrado se a forma não for reconhecida\n                img.fillRect(s4, s4, s2, s2, 15); // Cor diferente para indicar fallback\n                break;\n        }\n        return img;\n    }\n\n\n"]]},{"start1":13385,"length1":77,"diffs":[[1,""]]},{"start1":13386,"length1":430,"diffs":[[1,"        let finalImage: Image = null;\n"]]},{"start1":13425,"length1":158,"diffs":[[1,"        if (_currentShape === \"turtle\") {\n            _initializeTurtleFrames(); // Garante que os frames da tartaruga estão carregados\n            let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n            if (normalizedAngle >= 315 || normalizedAngle < 45) { _currentVisualDirection = DIR_RIGHT; }\n            else if (normalizedAngle >= 45 && normalizedAngle < 135) { _currentVisualDirection = DIR_UP; }\n            else if (normalizedAngle >= 135 && normalizedAngle < 225) { _currentVisualDirection = DIR_LEFT; }\n            else { _currentVisualDirection = DIR_DOWN; }\n\n            if (_turtleIdleFrames && _turtleIdleFrames[_currentVisualDirection]) {\n                finalImage = _turtleIdleFrames[_currentVisualDirection];\n            } else { // Fallback se a imagem da tartaruga estiver faltando\n                finalImage = _createShapeImage(\"square\", 16, 7); // Quadrado amarelo\n            }\n        } else {\n            let baseImage = _createShapeImage(_currentShape);\n            if (baseImage) {\n                finalImage = baseImage.clone();\n                // finalImage.rotate(-_currentHeading); // << REMOVA OU COMENTE ESTA LINHA\n            } else { // Fallback se _createShapeImage falhar\n                finalImage = _createShapeImage(\"square\", 16, 7); // Quadrado amarelo\n            }\n        }\n\n        if (_isTurtleVisible && finalImage) {\n            _turtleSprite.setImage(finalImage);\n"]]},{"start1":15021,"length1":287,"diffs":[[1,""]]},{"start1":15038,"length1":0,"diffs":[[1,"\n"]]},{"start1":15106,"length1":75,"diffs":[[1,""]]},{"start1":15228,"length1":37,"diffs":[[1,"            _penColor = 1;\n"]]},{"start1":15353,"length1":49,"diffs":[[1,"            _currentShape = \"turtle\"; // Padrão inicial\n"]]},{"start1":15410,"length1":293,"diffs":[[1,"            // Cria o sprite com uma imagem temporária ou baseada na forma inicial\n            let initialImage: Image;\n            if (_currentShape === \"turtle\") {\n                _initializeTurtleFrames();\n                initialImage = (_turtleIdleFrames && _turtleIdleFrames[DIR_RIGHT]) ? _turtleIdleFrames[DIR_RIGHT] : _createShapeImage(\"square\", 16, 7);\n            } else {\n                initialImage = _createShapeImage(_currentShape);\n"]]},{"start1":15871,"length1":1,"diffs":[[1,""]]},{"start1":16303,"length1":49,"diffs":[[1,"        let duration = ANIMATION_FRAME_DURATION; // Default\n"]]},{"start1":16418,"length1":0,"diffs":[[1,"            // Python: 1=slowest, 10=fast.\n            // Esta fórmula: speed 1 -> 250ms, speed 10 -> 25ms\n"]]},{"start1":16619,"length1":27,"diffs":[[1,"            duration = 25; // Mais rápido\n"]]},{"start1":16703,"length1":0,"diffs":[[1,"    // Função de desenho de linha com espessura\n"]]},{"start1":17083,"length1":0,"diffs":[[1,"            // Algoritmo de Bresenham para iterar pelos pontos da linha\n            // e desenhar círculos em cada ponto.\n"]]},{"start1":18420,"length1":67,"diffs":[[1,"        const totalDeltaY = Math.sin(radians) * effectiveDistance; // Y da Turtle aumenta para cima\n"]]},{"start1":18817,"length1":1150,"diffs":[[1,""]]},{"start1":19435,"length1":236,"diffs":[[1,"            if (_currentShape === \"turtle\" && _isTurtleVisible && _turtleWalkFrames && _turtleWalkFrames[_currentVisualDirection]) {\n                if (_turtleWalkFrames[_currentVisualDirection].length > 0) {\n                    _turtleSprite.setImage(_turtleWalkFrames[_currentVisualDirection][currentWalkFrameIndex]);\n                    currentWalkFrameIndex = (currentWalkFrameIndex + 1) % _turtleWalkFrames[_currentVisualDirection].length;\n                }\n            } // Para outras formas, a imagem já está rotacionada por _updateSpriteAppearance\n"]]},{"start1":20123,"length1":66,"diffs":[[1,"            _updateSpriteAppearance(); // Retorna à imagem \"idle\" ou orientação correta\n"]]},{"start1":21976,"length1":0,"diffs":[[1,"        // x, y são coordenadas Turtle (0,0 é centro)\n        // Turtle Python não desenha em goto por padrão.\n        // Se quiser desenhar, precisaria de uma lógica similar a forward()\n"]]},{"start1":22310,"length1":289,"diffs":[[1,"        // _updateSpriteAppearance(); // A orientação não muda com goto\n"]]},{"start1":23321,"length1":29,"diffs":[[1,"        _currentHeading = 0; // Direita\n"]]},{"start1":23493,"length1":0,"diffs":[[1,"        // pendown(); // Opcional, se quiser que home sempre baixe a caneta\n"]]},{"start1":24948,"length1":0,"diffs":[[1,"        // Se a forma não for \"turtle\", podemos querer atualizar a cor da forma também\n        if (_currentShape !== \"turtle\") {\n            _updateSpriteAppearance();\n        }\n"]]},{"start1":25761,"length1":0,"diffs":[[1,"    //% block=\"shape %name\"\n    //% name.fieldEditor=dropdown\n    //% name.fieldOptions.items='[[\"turtle\", \"turtle\"], [\"arrow\", \"arrow\"], [\"circle\", \"circle\"], [\"square\", \"square\"], [\"triangle\", \"triangle\"], [\"classic\", \"classic\"]]'\n    //% name.defl=\"turtle\"\n    //% group=\"Turtle State\" weight=65\n    export function shape(name: string): void {\n        _ensureTurtleExists();\n        const lowerName = name.toLowerCase();\n        const supportedShapes = [\"turtle\", \"arrow\", \"circle\", \"square\", \"triangle\", \"classic\"];\n        if (supportedShapes.indexOf(lowerName) !== -1) {\n            _currentShape = lowerName;\n            _updateSpriteAppearance();\n        } else {\n            console.warn(`TURTLE: Shape \"${name}\" not recognized.`);\n        }\n    }\n\n"]]},{"start1":27675,"length1":35,"diffs":[[1,"        _updateSpriteAppearance(); // Atualiza a imagem e remove o flag Invisible\n"]]},{"start1":28075,"length1":29,"diffs":[[1,"        if (_turtleSprite) { // Garante que o sprite existe antes de tentar mudar o flag\n"]]},{"start1":28689,"length1":75,"diffs":[[1,""]]},{"start1":28932,"length1":34,"diffs":[[1,"            _turtleSprite = null; // Força a recriação em _ensureTurtleExists\n"]]},{"start1":29020,"length1":63,"diffs":[[1,"        scene.backgroundImage().fill(scene.backgroundColor()); // Limpa desenhos\n        // _ensureTurtleExists será chamado por qualquer comando subsequente,\n        // ou podemos chamá-lo aqui para garantir o estado inicial.\n        // As variáveis de estado globais já são redefinidas em _ensureTurtleExists\n        // quando _turtleSprite é nulo.\n        _currentShape = \"turtle\"; // Redefine a forma para o padrão\n"]]},{"start1":29507,"length1":164,"diffs":[[1,"        // home(); // home() já está implícito na recriação\n        // pendown(); // pendown() já está implícito\n        // pencolor(1); // pencolor() já está implícito\n        // speed(6); // speed() já está implícito\n        // showturtle(); // showturtle() já está implícito\n"]]},{"start1":29792,"length1":536,"diffs":[[1,"    // Inicializa a tartaruga automaticamente para que os blocos funcionem sem um \"start\" explícito\n    // Isso garante que _turtleSprite seja criado na primeira vez que o namespace é carregado.\n    // No entanto, _ensureTurtleExists() é chamado no início de cada função pública,\n    // o que é uma prática mais robusta.\n    // Não é estritamente necessário chamar aqui se todas as funções públicas chamam _ensureTurtleExists().\n    // Mas pode ser bom para configurar o estado inicial assim que o jogo começa.\n    // control.runInParallel(() => _ensureTurtleExists()); // Executa uma vez no início\n"]]}]}]},{"timestamp":1749319245403,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":305,"length1":66,"diffs":[[1,"        \"main.py\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":1014,"length1":320,"diffs":[[1,". . . . . . . . . f . . . . . .\n. . . . . . f . f 7 f f . . . .\n. . . . f 7 7 7 7 7 7 f f . . .\n. . f 7 7 7 7 7 7 7 7 7 f . . .\n. . . . f 7 7 7 7 7 7 f f . . .\n. . . . . f . f 7 f f . . . . .\n. . . . . . . . f . . . . . . .\n. . . . . . . . . . . . . . . .\n"]]},{"start1":2731,"length1":116,"diffs":[[1,"    const turtle_U_idle = img`\n        . . . . . . . . . . . . . . . .\n        . . . . . . f f . f f . . . . .\n        . . . . . . f f . f f . . . . .\n        . . . . . . . f f f f . . . . .\n        . . . . f f f 7 7 7 7 f f f . .\n        . . . f 7 7 7 7 7 7 7 7 7 f . .\n        . . . f 7 7 7 7 7 7 7 7 7 f . .\n        . . . f 7 7 7 7 7 7 7 7 7 f . .\n        . . . f 7 7 7 7 7 7 7 7 7 f . .\n        . . . . f 7 7 7 7 7 7 7 f . . .\n        . . . . f 7 7 7 7 7 7 7 f . . .\n        . . . . . f 7 7 7 7 7 f . . . .\n        . . . . . . f f f f f . . . . .\n        . . . . . . . f f f . . . . . .\n        . . . . . . f . . . f . . . . .\n        . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA CIMA\n"]]}]},{"type":"added","filename":"images.g.jres","value":"{\n    \"image1\": {\n        \"data\": \"hwQPABAAAAAAAAB3AAAAAAAAcHcAAHAHAAB3AAAAdwcAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwcAAHB3AABwBwAAAHcAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp\"\n    },\n    \"image2\": {\n        \"data\": \"hwQPABAAAAAAAAAAdwAAAHAHAAB3BwAAcHcAAAB3AAAAd2dmZncAAABwZmZmBgAAAGBmZmZmcAcAZ2ZmZmZ3dwBnZmZmZnd3AGBmZmZmcAcAcGZmZgYAAAB3Z2ZmdwAAcHcAAAB3AABwBwAAdwcAAAAAAAB3AAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleDown\"\n    },\n    \"image3\": {\n        \"data\": \"hwQQAA8AAAAAAAAAAAAAAHAHAAAAcAcAcHcAdwB3BwAAd2dmdncAAABwZmZmBwAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAd2BmZmYGdwB3YGZmZgZ3AHB3ZmZmdwcAAHdgZgZ3AAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleRight\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQAA8AAAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAAB3YGYGdwAAcHdmZmZ3BwB3YGZmZgZ3AHdgZmZmBncAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAHBmZmYHAAAAd2dmdncAAHB3AHcAdwcAcAcAAABwBwAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleLeft\"\n    },\n    \"image5\": {\n        \"data\": \"hwQPABAAAAAAdwAAAAAAAAB3dwAAAAAAAAB3AAAAdwAAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwAAd3cAAAAAAAB3AAAAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp0\"\n    },\n    \"image6\": {\n        \"data\": \"hwQPABAAAAAAdwAAAAAAAAB3dwAAAAAAAAB3AAAAdwAAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwAAd3cAAAAAAAB3AAAAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}"},{"type":"added","filename":"images.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myImages {\n\n    helpers._registerFactory(\"image\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"image1\":\n            case \"turtleUp\":return img`\n. . . . . . 7 7 . . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n. . . . . . 7 7 . . . . . . . \n. . 7 7 . 6 6 6 6 . 7 7 . . . \n. 7 7 7 6 6 6 6 6 6 7 7 7 . . \n7 7 . 6 6 6 6 6 6 6 6 . 7 7 . \n7 7 . 6 6 6 6 6 6 6 6 . 7 7 . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 7 6 6 6 6 6 6 7 . . . . \n. . 7 7 7 6 6 6 6 7 7 7 . . . \n. 7 7 7 . . 7 7 . . 7 7 7 . . \n. 7 7 . . . . . . . . 7 7 . . \n. . . . . . . . . . . . . . . \n`;\n            case \"image2\":\n            case \"turtleDown\":return img`\n. . . . . . . . . . . . . . . \n. 7 7 . . . . . . . . 7 7 . . \n. 7 7 7 . . 7 7 . . 7 7 7 . . \n. . 7 7 7 6 6 6 6 7 7 7 . . . \n. . . 7 6 6 6 6 6 6 7 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n7 7 . 6 6 6 6 6 6 6 6 . 7 7 . \n7 7 . 6 6 6 6 6 6 6 6 . 7 7 . \n. 7 7 7 6 6 6 6 6 6 7 7 7 . . \n. . 7 7 . 6 6 6 6 . 7 7 . . . \n. . . . . . 7 7 . . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n. . . . . . 7 7 . . . . . . . \n`;\n            case \"image3\":\n            case \"turtleRight\":return img`\n. . . . . . . . 7 7 . . . . . . \n. 7 7 . . . . . 7 7 7 . . . . . \n. 7 7 7 . . . . . . 7 7 . . . . \n. . 7 7 7 6 6 6 6 6 7 7 . . . . \n. . . 7 6 6 6 6 6 6 6 . . . . . \n. . . 6 6 6 6 6 6 6 6 6 . 7 7 . \n. . 7 6 6 6 6 6 6 6 6 6 7 7 7 7 \n. . 7 6 6 6 6 6 6 6 6 6 7 7 7 7 \n. . . 6 6 6 6 6 6 6 6 6 . 7 7 . \n. . . 7 6 6 6 6 6 6 6 . . . . . \n. . 7 7 7 6 6 6 6 6 7 7 . . . . \n. 7 7 7 . . . . . . 7 7 . . . . \n. 7 7 . . . . . 7 7 7 . . . . . \n. . . . . . . . 7 7 . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n            case \"image4\":\n            case \"turtleLeft\":return img`\n. . . . . . 7 7 . . . . . . . . \n. . . . . 7 7 7 . . . . . 7 7 . \n. . . . 7 7 . . . . . . 7 7 7 . \n. . . . 7 7 6 6 6 6 6 7 7 7 . . \n. . . . . 6 6 6 6 6 6 6 7 . . . \n. 7 7 . 6 6 6 6 6 6 6 6 6 . . . \n7 7 7 7 6 6 6 6 6 6 6 6 6 7 . . \n7 7 7 7 6 6 6 6 6 6 6 6 6 7 . . \n. 7 7 . 6 6 6 6 6 6 6 6 6 . . . \n. . . . . 6 6 6 6 6 6 6 7 . . . \n. . . . 7 7 6 6 6 6 6 7 7 7 . . \n. . . . 7 7 . . . . . . 7 7 7 . \n. . . . . 7 7 7 . . . . . 7 7 . \n. . . . . . 7 7 . . . . . . . . \n. . . . . . . . . . . . . . . . \n`;\n            case \"image5\":\n            case \"turtleUp0\":return img`\n. . . . . . 7 7 . . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n7 7 . . . 7 7 7 7 . . . 7 7 . \n7 7 . . . . 7 7 . . . . 7 7 . \n. 7 7 7 . 6 6 6 6 . 7 7 7 . . \n. 7 7 7 6 6 6 6 6 6 7 7 7 . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 7 6 6 6 6 6 6 7 . . . . \n. . 7 7 7 6 6 6 6 7 7 7 . . . \n. . 7 7 . . 7 7 . . 7 7 . . . \n. . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . \n`;\n            case \"image6\":\n            case \"turtleUp1\":return img`\n. . . . . . 7 7 . . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n7 7 . . . 7 7 7 7 . . . 7 7 . \n7 7 . . . . 7 7 . . . . 7 7 . \n. 7 7 7 . 6 6 6 6 . 7 7 7 . . \n. 7 7 7 6 6 6 6 6 6 7 7 7 . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 6 6 6 6 6 6 6 6 . . . . \n. . . 7 6 6 6 6 6 6 7 . . . . \n. . 7 7 7 6 6 6 6 7 7 7 . . . \n. . 7 7 . . 7 7 . . 7 7 . . . \n. . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . \n`;\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"animation\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"song\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1749319835678,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":522,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"?oK/Uhn6b_{(_?gIN!IA\">currentPos</variable></variables><block type=\"pxt-on-start\" x=\"36\" y=\"52\"><statement name=\"HANDLER\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_goto\"><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"turtle.forward(50)\nturtle.goto(0, 0)\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":468,"length1":267,"diffs":[[1,"    const ANIMATION_FRAME_DURATION = 150;\n    const PIXELS_PER_STEP = 4;\n    let _turtleSpeed = 6; // Padrão Python (0-10, 0 é o mais rápido)\n"]]},{"start1":830,"length1":171,"diffs":[[1,""]]},{"start1":905,"length1":357,"diffs":[[1,"    // !!! COLE SUAS IMAGENS AQUI !!!\n    const turtle_R_idle = img`\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . f . . . . . .\n        . . . . . . f . f 7 f f . . . .\n        . . . . f 7 7 7 7 7 7 f f . . .\n        . . f 7 7 7 7 7 7 7 7 7 f . . .\n        . . . . f 7 7 7 7 7 7 f f . . .\n        . . . . . f . f 7 f f . . . . .\n        . . . . . . . . f . . . . . . .\n        . . . . . . . . . . . . . . . .\n    `;\n    const turtle_R_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . f f .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `;\n    const turtle_R_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `;\n"]]},{"start1":2644,"length1":204,"diffs":[[1,"    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX();\n"]]},{"start1":2795,"length1":207,"diffs":[[1,"    const turtle_U_idle =assets.image`turtleUp`; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA CIMA\n    const turtle_U_walk1 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA CIMA\n    const turtle_U_walk2 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA CIMA\n"]]},{"start1":4278,"length1":213,"diffs":[[1,"    const turtle_D_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA BAIXO\n    const turtle_D_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA BAIXO\n    const turtle_D_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA BAIXO\n"]]},{"start1":6662,"length1":59,"diffs":[[1,"        if (!_turtleIdleFrames || !_turtleIdleFrames[0]) { // Evita reinicialização desnecessária\n"]]},{"start1":6854,"length1":651,"diffs":[[1,""]]},{"start1":6888,"length1":191,"diffs":[[1,"                [turtle_R_walk1, turtle_R_walk2],\n                [turtle_U_walk1, turtle_U_walk2],\n                [turtle_L_walk1, turtle_L_walk2],\n                [turtle_D_walk1, turtle_D_walk2]\n"]]},{"start1":7103,"length1":0,"diffs":[[1,"            // Validação e fallback para imagens ausentes\n"]]},{"start1":7544,"length1":183,"diffs":[[1,"                if (!_turtleWalkFrames[i] || !_turtleWalkFrames[i][0] || !_turtleWalkFrames[i][1]) {\n                    console.warn(`TURTLE: Missing walk frames for direction ${i}. Using fallback.`);\n"]]},{"start1":7833,"length1":178,"diffs":[[1,""]]},{"start1":7959,"length1":35,"diffs":[[1,"        _initializeTurtleFrames(); // Garante que os frames estão carregados\n"]]},{"start1":8972,"length1":0,"diffs":[[1,"            // Poderia definir uma imagem de fallback aqui se a validação em _initializeTurtleFrames falhar\n"]]},{"start1":9164,"length1":39,"diffs":[[1,"            _initializeTurtleFrames(); // Carrega as imagens da tartaruga\n"]]},{"start1":9361,"length1":27,"diffs":[[1,"            _penColor = 1; // Branco\n"]]},{"start1":9607,"length1":33,"diffs":[[1,"            if (!initialImage) { // Fallback extremo se tudo falhar\n"]]},{"start1":10099,"length1":39,"diffs":[[1,"            _updateSpriteAppearance(); // Define a imagem correta e visibilidade\n"]]},{"start1":10244,"length1":224,"diffs":[[1,"        if (_turtleSpeed === 0) return 0;\n        let duration = ANIMATION_FRAME_DURATION;\n"]]},{"start1":10390,"length1":120,"diffs":[[1,""]]},{"start1":10444,"length1":72,"diffs":[[1,"        } else if (_turtleSpeed > 10) {\n"]]},{"start1":12168,"length1":0,"diffs":[[1,"        const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n        const stepDx = totalDeltaX / numAnimationSteps;\n        const stepDy = totalDeltaY / numAnimationSteps;\n\n        let currentWalkFrameIndex = 0;\n"]]},{"start1":12464,"length1":74,"diffs":[[1,"        // Garante que os frames de caminhada estão disponíveis\n        if (!_turtleWalkFrames || !_turtleWalkFrames[_currentVisualDirection] || _turtleWalkFrames[_currentVisualDirection].length === 0) {\n            console.warn(\"TURTLE: Walk frames missing or empty for current visual direction: \" + _currentVisualDirection);\n            // Movimento sem animação se os frames estiverem faltando\n"]]},{"start1":13432,"length1":289,"diffs":[[1,"            if (_isTurtleVisible) _updateSpriteAppearance(); // Volta para idle\n            return;\n        }\n"]]},{"start1":13543,"length1":150,"diffs":[[1,"        const walkCycle = _turtleWalkFrames[_currentVisualDirection];\n"]]},{"start1":13614,"length1":78,"diffs":[[1,"        for (let i = 0; i < numAnimationSteps; i++) {\n            const prevRawX = _turtleRawX;\n            const prevRawY = _turtleRawY;\n"]]},{"start1":13753,"length1":439,"diffs":[[1,"            _turtleRawX += stepDx;\n            _turtleRawY += stepDy;\n"]]},{"start1":13824,"length1":160,"diffs":[[1,"            if (_isPenDown) {\n                _drawLineWithThickness(\n                    _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                    _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                    _penColor, _penThickness\n                );\n            }\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n"]]},{"start1":14232,"length1":126,"diffs":[[1,"            if (_isTurtleVisible && walkCycle.length > 0) {\n                _turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n                currentWalkFrameIndex = (currentWalkFrameIndex + 1) % walkCycle.length;\n"]]},{"start1":14468,"length1":10,"diffs":[[1,""]]},{"start1":14469,"length1":233,"diffs":[[1,"            if (animDuration > 0) {\n                pause(animDuration);\n            }\n        }\n"]]},{"start1":14598,"length1":39,"diffs":[[1,"            _updateSpriteAppearance(); // Retorna à imagem \"idle\"\n"]]},{"start1":16429,"length1":148,"diffs":[[1,""]]},{"start1":16576,"length1":92,"diffs":[[1,"        // A orientação não muda com goto, então _updateSpriteAppearance() não é estritamente necessário\n        // a menos que a visibilidade possa ter mudado. Mas como _updateSpriteAppearance também lida\n        // com a visibilidade, é seguro chamar.\n        _updateSpriteAppearance();\n"]]},{"start1":22042,"length1":0,"diffs":[[1,"        // Não precisa de _ensureTurtleExists() pois só mexe no background\n"]]},{"start1":22467,"length1":31,"diffs":[[1,"        _ensureTurtleExists(); // Recria e redefine para os padrões\n        // As configurações padrão (home, pendown, pencolor, speed, showturtle)\n        // são aplicadas dentro de _ensureTurtleExists quando _turtleSprite é nulo.\n"]]},{"start1":22706,"length1":0,"diffs":[[1,"    // Inicializa a tartaruga se nenhum comando for chamado explicitamente no início.\n    // Isso garante que a tartaruga apareça na tela ao iniciar o programa,\n    // mesmo que o usuário não chame nenhum bloco de tartaruga imediatamente.\n    // No entanto, _ensureTurtleExists() no início de cada função pública é a garantia principal.\n    // control.runInParallel(() => _ensureTurtleExists()); // Opcional, mas pode ser bom\n    // Ou simplesmente chamar uma vez para garantir que o namespace está \"pronto\":\n"]]}]},{"type":"edited","filename":"images.g.jres","patch":[{"start1":1490,"length1":192,"diffs":[[1,"        \"data\": \"hwQPABAAAAAAdwAAAAAAAAB3dwAAAAAAAAB3AAAAdwAAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwAAd3cAAAAAAAB3AAAAAAAAAAAAAAAAAAA=\",\n"]]},{"start1":1721,"length1":37,"diffs":[[1,"        \"displayName\": \"turtleUp1\"\n"]]},{"start1":1763,"length1":607,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":3028,"length1":198,"diffs":[[1,"            case \"turtleUp1\":return img`\n. . . . . . 7 7 . . . . . . . \n. . . . . 7 7 7 7 . . . . . . \n7 7 . . . 7 7 7 7 . . . 7 7 . \n7 7 . . . . 7 7 . . . . 7 7 . \n. 7 7 7 . 6 6 6 6 . 7 7 7 . . \n. 7 7 7 6 6 6 6 6 6 7 7 7 . . \n"]]},{"start1":3410,"length1":186,"diffs":[[1,". . . 7 6 6 6 6 6 6 7 . . . . \n. . 7 7 7 6 6 6 6 7 7 7 . . . \n. . 7 7 . . 7 7 . . 7 7 . . . \n. . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . \n"]]},{"start1":3568,"length1":1137,"diffs":[[1,""]]}]}]},{"timestamp":1749320361342,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":585,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_goto\"><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":54,"diffs":[[1,""]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":208,"length1":79,"diffs":[[1,"    let _currentHeading: number = 0; // 0 graus = para a direita\n"]]},{"start1":468,"length1":99,"diffs":[[1,"    const ANIMATION_FRAME_DURATION = 150; // Usado para a pausa entre os \"saltos\" da tartaruga\n    const PIXELS_PER_STEP = 4;      // Distância de cada \"salto\" para controle de velocidade\n    let _turtleSpeed = 6;           // Padrão Python (0-10, 0 é o mais rápido)\n"]]},{"start1":874,"length1":81,"diffs":[[1,"    let _currentVisualDirection = DIR_RIGHT;\n"]]},{"start1":955,"length1":0,"diffs":[[1,"    // _turtleWalkFrames não será mais usado para animar, mas mantemos a estrutura\n    // conforme fornecido, e a inicialização para evitar erros se alguma imagem faltar.\n    let _turtleWalkFrames: Image[][];\n"]]},{"start1":1165,"length1":728,"diffs":[[1,"    // --- IMAGENS DA TARTARUGA ---\n    // !!! COLE SUAS IMAGENS AQUI ou garanta que os assets existem !!!\n    // Se assets.image`nome` não existir, causará erro de compilação.\n    const turtle_R_idle = assets.image`turtleRight`;\n    const turtle_R_walk1 = assets.image`turtleRight`; // Não usado para animação\n    const turtle_R_walk2 = assets.image`turtleRight0`; // Não usado para animação\n\n"]]},{"start1":1631,"length1":173,"diffs":[[1,"    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX(); // Não usado para animação\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX(); // Não usado para animação\n"]]},{"start1":1836,"length1":0,"diffs":[[1,"    const turtle_U_idle = assets.image`turtleUp`;\n    const turtle_U_walk1 = assets.image`turtleUp`; // Não usado para animação\n    const turtle_U_walk2 = assets.image`turtleUp0`; // Não usado para animação\n\n    const turtle_D_idle = assets.image`turtleDown`;\n    const turtle_D_walk1 = assets.image`turtleDown`; // Não usado para animação\n    const turtle_D_walk2 = assets.image`turtleDown0`; // Não usado para animação\n\n"]]},{"start1":2745,"length1":0,"diffs":[[1,"            // Inicializa _turtleWalkFrames para consistência, embora não sejam usados para animação\n            // Isso também garante que o fallback funcione se as imagens walk forem indefinidas.\n            let r_walk2_temp = typeof turtle_R_walk2 !== 'undefined' ? turtle_R_walk2 : turtle_R_walk1; // Usa walk1 se walk2 não definido\n            let l_walk2_temp = typeof turtle_L_walk2 !== 'undefined' ? turtle_L_walk2 : turtle_L_walk1;\n            let u_walk2_temp = typeof turtle_U_walk2 !== 'undefined' ? turtle_U_walk2 : turtle_U_walk1;\n            let d_walk2_temp = typeof turtle_D_walk2 !== 'undefined' ? turtle_D_walk2 : turtle_D_walk1;\n\n            _turtleWalkFrames = [\n                [turtle_R_walk1, r_walk2_temp],\n                [turtle_U_walk1, u_walk2_temp],\n                [turtle_L_walk1, l_walk2_temp],\n                [turtle_D_walk1, d_walk2_temp]\n            ];\n\n"]]},{"start1":4019,"length1":0,"diffs":[[1,"                // Validação para walk frames, mesmo que não usados para animação, para evitar erros de tipo.\n                if (!_turtleWalkFrames[i] || !_turtleWalkFrames[i][0]) {\n                    _turtleWalkFrames[i] = [fallbackImg.clone(), fallbackImg.clone()];\n                } else if (!_turtleWalkFrames[i][1]) {\n                    _turtleWalkFrames[i][1] = _turtleWalkFrames[i][0].clone(); // Usa o primeiro frame se o segundo faltar\n                }\n"]]},{"start1":5746,"length1":85,"diffs":[[1,"            _currentHeading = 0;\n"]]},{"start1":5935,"length1":91,"diffs":[[1,"            _currentVisualDirection = DIR_RIGHT;\n"]]},{"start1":5985,"length1":482,"diffs":[[1,"            let initialImage = _turtleIdleFrames[DIR_RIGHT];\n            if (!initialImage) {\n                initialImage = image.create(16, 16); initialImage.fill(7);\n                console.error(\"TURTLE: Critical failure loading initial turtle image.\");\n"]]},{"start1":6503,"length1":93,"diffs":[[1,"            _updateSpriteAppearance();\n"]]},{"start1":6606,"length1":91,"diffs":[[1,"        if (_turtleSpeed === 0) return 0; // Movimento instantâneo\n        // Se speed não for 0, calcula uma pausa para simular velocidade\n        let duration = ANIMATION_FRAME_DURATION; // Duração base da pausa por passo\n"]]},{"start1":6885,"length1":0,"diffs":[[1,"            // Python: 1=slowest, 10=fast.\n            // Esta fórmula: speed 1 -> pausa maior, speed 10 -> pausa menor\n"]]},{"start1":7059,"length1":40,"diffs":[[1,"        } else if (_turtleSpeed > 10) { // Acima de 10 é rápido como 10\n"]]},{"start1":8870,"length1":34,"diffs":[[1,"        if (animDuration === 0) { // Movimento instantâneo se speed for 0\n"]]},{"start1":9532,"length1":0,"diffs":[[1,"            // Movimento em passos para simular velocidade\n"]]},{"start1":10474,"length1":40,"diffs":[[1,"\n                // A imagem da tartaruga NÃO muda durante os passos.\n                // Ela já foi definida por _updateSpriteAppearance() para a direção atual.\n\n                if (animDuration > 0) { // Pausa entre os \"saltos\"\n"]]},{"start1":10787,"length1":0,"diffs":[[1,"        // Garante que a aparência (direção visual) esteja correta no final do movimento.\n        // Isso é importante se, por exemplo, o movimento foi instantâneo ou\n        // para garantir que a imagem idle correta seja mostrada.\n"]]},{"start1":12856,"length1":0,"diffs":[[1,"        // Se a caneta estiver abaixada, o Turtle do Python não desenha em goto.\n        // Para manter essa semelhança, não desenhamos linha aqui.\n"]]},{"start1":13151,"length1":35,"diffs":[[1,"        _updateSpriteAppearance(); // Atualiza a aparência caso a visibilidade tenha mudado\n"]]},{"start1":14182,"length1":78,"diffs":[[1,"        _currentHeading = 0;\n"]]}]},{"type":"edited","filename":"images.g.jres","patch":[{"start1":2372,"length1":296,"diffs":[[1,""]]}]},{"type":"edited","filename":"images.g.ts","patch":[{"start1":4707,"length1":594,"diffs":[[1,""]]}]}]},{"timestamp":1749320954035,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":395,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value><next><block type=\"turtle_left\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value><next><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value></block></next></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":41,"diffs":[[1,"turtle.forward(50)\nturtle.left(90)\nturtle.forward(50)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":349,"length1":72,"diffs":[[1,"        \"images.g.ts\"\n"]]},{"start1":398,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"turtle.ts","patch":[{"start1":919,"length1":678,"diffs":[[1,""]]},{"start1":959,"length1":678,"diffs":[[1,""]]},{"start1":1559,"length1":773,"diffs":[[1,"    `;\n    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_U_idle = img``;   // <<< Certifique-se que este asset existe\n    const turtle_D_idle = assets.image`turtleDown`; // <<< Certifique-se que este asset existe\n"]]}]},{"type":"added","filename":"tilemap.g.jres","value":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAxMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n        \"tileset\": [\n            \"myTiles.transparency16\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}"},{"type":"added","filename":"tilemap.g.ts","value":"// Auto-generated code. Do not edit.\nnamespace myTiles {\n    //% fixedInstance jres blockIdentity=images._tile\n    export const transparency16 = image.ofBuffer(hex``);\n\n    helpers._registerFactory(\"tilemap\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"level1\":\n            case \"level1\":return tiles.createTilemap(hex`1000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`, [myTiles.transparency16], TileScale.Sixteen);\n        }\n        return null;\n    })\n\n    helpers._registerFactory(\"tile\", function(name: string) {\n        switch(helpers.stringTrim(name)) {\n            case \"transparency16\":return transparency16;\n        }\n        return null;\n    })\n\n}\n// Auto-generated code. Do not edit.\n"}]},{"timestamp":1749321472813,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":20721,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"set_current_tilemap\"><value name=\"tilemap\"><shadow type=\"tiles_tilemap_editor\"><field name=\"tilemap\">tilemap`level1`</field><data>{\"commentRefs\":[],\"fieldData\":{\"tilemap\":\"level1\"}}</data></shadow></value></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":4660,"diffs":[[1,"tiles.setCurrentTilemap(tilemap`level1`)\n"]]}]},{"type":"edited","filename":"tilemap.g.jres","patch":[{"start1":392,"length1":356,"diffs":[[1,"        \"data\": \"MTAxMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMA==\",\n"]]},{"start1":1473,"length1":162,"diffs":[[1,"            \"myTiles.transparency16\"\n"]]}]},{"type":"edited","filename":"tilemap.g.ts","patch":[{"start1":304,"length1":530,"diffs":[[1,"            case \"level1\":return tiles.createTilemap(hex`1000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`, img`\n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n. . . . . . . . . . . . . . . . \n`, [myTiles.transparency16], TileScale.Sixteen);\n"]]}]}]},{"timestamp":1749321955101,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"Z/r-#^tW!nd,3C0!bz.f\">hours</variable><variable id=\"L@CW,U?vqUt1uZknj[dG\">minutes</variable><variable id=\"HZp)mN]?UhTp-yZcb5,z\">seconds</variable><variable id=\"$b*@buOKV4:s~i|$43(M\">HOUR_HAND_LENGTH</variable><variable id=\"I7mv8AA/?AGrMT{c/AIA\">MINUTE_HAND_LENGTH</variable><variable id=\"ky)jxebH{vLPUSg9*=A(\">SECOND_HAND_LENGTH</variable><variable id=\"z3iU_B7-IoQRh*.|+vNm\">i</variable><variable id=\"%}?!yTB%8V/G+mgV^k}Y\">DIAL_RADIUS</variable><variable id=\"xAWXW%-x5LBKk_-[G{VI\">LONG_MARK_LENGTH</variable><variable id=\"`M:.#nN.~1fu9IBxU-[u\">SHORT_MARK_LENGTH</variable><variable id=\"`|Hr-|az8BYlY`1[7Ar|\">currentTimeMillis</variable><variable id=\"AFC4bo[cR^3+y/iqR[ZW\">totalSecondsSinceStart</variable><variable id=\",Gw$O;XwR.QL^l#CvA5X\">totalMinutesSinceStart</variable><variable id=\"v)jrAo?EJ$V=Hj5R`Ird\">totalHoursSinceStart</variable><variable id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</variable></variables><comment x=\"453\" y=\"833\" w=\"300\" h=\"120\">\nVariáveis globais para o tempo\n</comment><block type=\"gameinterval\" x=\"614\" y=\"20\"><comment pinned=\"false\" h=\"80\" w=\"160\">Define a velocidade da tartaruga para a mais rápida (sem animação de movimento)\n--- Loop Principal de Atualização do Relógio ---\nEste bloco será executado a cada 1000 ms (1 segundo)</comment><value name=\"period\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><statement name=\"HANDLER\"><block type=\"turtle_clear\"><comment pinned=\"false\" h=\"80\" w=\"160\">Limpa quaisquer desenhos anteriores da tartaruga da tela de fundo</comment><next><block type=\"function_call\"><mutation name=\"drawDial\" functionid=\"qLP[nH/9=-k1sE2B3o`S\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha o mostrador do relógio (que é estático, mas precisa ser redesenhado após `turtle.clear()`)</comment><next><block type=\"variables_set\"><field name=\"VAR\" id=\"`|Hr-|az8BYlY`1[7Ar|\">currentTimeMillis</field><comment pinned=\"false\" h=\"80\" w=\"160\">--- Cálculo do Tempo de Jogo ---\nTempo em milissegundos desde o início do jogo</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"arcade_game_runtime\"></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"AFC4bo[cR^3+y/iqR[ZW\">totalSecondsSinceStart</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_js_round\"><field name=\"OP\">floor</field><value name=\"ARG0\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"`|Hr-|az8BYlY`1[7Ar|\">currentTimeMillis</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">1000</field></shadow></value></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"HZp)mN]?UhTp-yZcb5,z\">seconds</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"AFC4bo[cR^3+y/iqR[ZW\">totalSecondsSinceStart</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\",Gw$O;XwR.QL^l#CvA5X\">totalMinutesSinceStart</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_js_round\"><field name=\"OP\">floor</field><value name=\"ARG0\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"AFC4bo[cR^3+y/iqR[ZW\">totalSecondsSinceStart</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"L@CW,U?vqUt1uZknj[dG\">minutes</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\",Gw$O;XwR.QL^l#CvA5X\">totalMinutesSinceStart</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"v)jrAo?EJ$V=Hj5R`Ird\">totalHoursSinceStart</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_js_round\"><field name=\"OP\">floor</field><value name=\"ARG0\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\",Gw$O;XwR.QL^l#CvA5X\">totalMinutesSinceStart</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"Z/r-#^tW!nd,3C0!bz.f\">hours</field><comment pinned=\"false\" h=\"80\" w=\"160\">Ajusta as horas para o formato 12 horas (1-12)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_modulo\"><value name=\"DIVIDEND\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"v)jrAo?EJ$V=Hj5R`Ird\">totalHoursSinceStart</field></block></value><value name=\"DIVISOR\"><shadow type=\"math_number\"><field name=\"NUM\">12</field></shadow></value></block></value><next><block type=\"controls_if\"><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">EQ</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"Z/r-#^tW!nd,3C0!bz.f\">hours</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"variables_set\"><field name=\"VAR\" id=\"Z/r-#^tW!nd,3C0!bz.f\">hours</field><comment pinned=\"false\" h=\"80\" w=\"160\">Se for 0 (ex: meia-noite ou meio-dia no tempo de jogo), representa como 12</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">12</field></shadow></value></block></statement><next><block type=\"function_call\"><mutation name=\"drawHands\" functionid=\"+X=!Y94;KjqM,p:jvd#(\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha os ponteiros do relógio com base no tempo calculado</comment></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type=\"pxt-on-start\" x=\"35\" y=\"57\"><statement name=\"HANDLER\"><block type=\"gamesetbackgroundcolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">9</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field><comment pinned=\"false\" h=\"80\" w=\"160\">Será 1-12 para o display\n--- Constantes de Escala e Tamanho ---\nAjustado para caber na tela do MakeCode Arcade (160x120)\nRaio original do mostrador no exemplo era 100. Novo raio máximo ~50.</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0.5</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"%}?!yTB%8V/G+mgV^k}Y\">DIAL_RADIUS</field><comment pinned=\"false\" h=\"80\" w=\"160\">Raio do mostrador (ex: 50)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">100</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"$b*@buOKV4:s~i|$43(M\">HOUR_HAND_LENGTH</field><comment pinned=\"false\" h=\"80\" w=\"160\">Comprimento do ponteiro das horas (ex: 22.5 -&gt; 23)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">45</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"I7mv8AA/?AGrMT{c/AIA\">MINUTE_HAND_LENGTH</field><comment pinned=\"false\" h=\"80\" w=\"160\">Comprimento do ponteiro dos minutos (ex: 30)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"ky)jxebH{vLPUSg9*=A(\">SECOND_HAND_LENGTH</field><comment pinned=\"false\" h=\"80\" w=\"160\">Comprimento do ponteiro dos segundos (ex: 37.5 -&gt; 38)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">75</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"xAWXW%-x5LBKk_-[G{VI\">LONG_MARK_LENGTH</field><comment pinned=\"false\" h=\"80\" w=\"160\">Comprimento da marca longa do mostrador (ex: 10)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">20</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"`M:.#nN.~1fu9IBxU-[u\">SHORT_MARK_LENGTH</field><comment pinned=\"false\" h=\"80\" w=\"160\">Comprimento da marca curta do mostrador (ex: 5)</comment><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">10</field></shadow></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"BQ*c,}fhFYX^l}{_b[W[\">SCALE_FACTOR</field></block></value></block></value><next><block type=\"turtle_hideturtle\"><comment pinned=\"false\" h=\"80\" w=\"160\">--- Configuração Inicial do Relógio ---\nEsconde o sprite da tartaruga, queremos ver apenas o desenho</comment><next><block type=\"turtle_speed\"><comment pinned=\"false\" h=\"80\" w=\"160\">Define a velocidade da tartaruga para a mais rápida (sem animação de movimento)</comment><value name=\"speedValue\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"10\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"1403\" y=\"20\"><mutation name=\"drawHands\" functionid=\"+X=!Y94;KjqM,p:jvd#(\"></mutation><field name=\"function_name\">drawHands</field><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha os ponteiros do relógio (horas, minutos, segundos).</comment><data>0</data><statement name=\"STACK\"><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Cor dos ponteiros: Preto</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">15</field></shadow></value><next><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">--- Ponteiro das Horas ---\n'hours' já está ajustado para o formato 1-12.\nO ângulo é (hora_fracionária / 12) * 360 graus, o que simplifica para hora_fracionária * 30 graus.\nturtle.home() garante que o heading é 0 (direita) antes da rotação.</comment><value name=\"angle\"><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">ADD</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">ADD</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"Z/r-#^tW!nd,3C0!bz.f\">hours</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"L@CW,U?vqUt1uZknj[dG\">minutes</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"HZp)mN]?UhTp-yZcb5,z\">seconds</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">3600</field></shadow></value></block></value></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"$b*@buOKV4:s~i|$43(M\">HOUR_HAND_LENGTH</field></block></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta ao centro (0,0), heading 0 (direita)</comment><next><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">--- Ponteiro dos Minutos ---\nO ângulo é (minuto_fracionário / 60) * 360 graus, o que simplifica para minuto_fracionário * 6 graus.</comment><value name=\"angle\"><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">ADD</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"L@CW,U?vqUt1uZknj[dG\">minutes</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\"><field name=\"OP\">DIVIDE</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"HZp)mN]?UhTp-yZcb5,z\">seconds</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value></block></value></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">6</field></shadow></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"I7mv8AA/?AGrMT{c/AIA\">MINUTE_HAND_LENGTH</field></block></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta ao centro (0,0), heading 0 (direita)</comment><next><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">--- Ponteiro dos Segundos ---\nO ângulo é (segundo / 60) * 360 graus, o que simplifica para segundo * 6 graus.</comment><value name=\"angle\"><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"HZp)mN]?UhTp-yZcb5,z\">seconds</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">6</field></shadow></value></block></value><next><block type=\"turtle_forward\"><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"ky)jxebH{vLPUSg9*=A(\">SECOND_HAND_LENGTH</field></block></value><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta ao centro (0,0), heading 0 (direita)</comment></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"20\" y=\"833\"><mutation name=\"drawDial\" functionid=\"qLP[nH/9=-k1sE2B3o`S\"></mutation><field name=\"function_name\">drawDial</field><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha o mostrador do relógio com as marcas das horas.</comment><statement name=\"STACK\"><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Cor do mostrador: Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"pxt_controls_for\"><value name=\"VAR\"><block type=\"variables_get_reporter\"><mutation duplicateondrag=\"true\"></mutation><field name=\"VAR\" id=\"z3iU_B7-IoQRh*.|+vNm\">i</field></block></value><value name=\"TO\"><shadow type=\"math_whole_number\"><field name=\"NUM\">0</field></shadow><block type=\"math_number\"><field name=\"NUM\">11</field></block></value><statement name=\"DO\"><block type=\"turtle_right\"><comment pinned=\"false\" h=\"80\" w=\"160\">Desenha 12 marcas (para as horas 0 a 11)\nturtle.home() foi chamado no final da iteração anterior (ou na configuração inicial),\nentão o heading da tartaruga é 0 (para a direita) antes desta rotação.\nGira 30 graus para cada marca de hora (360 graus / 12 horas = 30 graus/hora)</comment><value name=\"angle\"><block type=\"math_arithmetic\"><field name=\"OP\">MULTIPLY</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"z3iU_B7-IoQRh*.|+vNm\">i</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value></block></value><next><block type=\"turtle_penup\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><next><block type=\"turtle_forward\"><comment pinned=\"false\" h=\"80\" w=\"160\">Move a tartaruga para a borda do mostrador</comment><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"%}?!yTB%8V/G+mgV^k}Y\">DIAL_RADIUS</field></block></value><next><block type=\"turtle_pendown\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><next><block type=\"controls_if\"><mutation else=\"1\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">A marca para i=0 (correspondente às 12 horas) é mais longa</comment><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">EQ</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"z3iU_B7-IoQRh*.|+vNm\">i</field></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"turtle_backward\"><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"xAWXW%-x5LBKk_-[G{VI\">LONG_MARK_LENGTH</field></block></value></block></statement><statement name=\"ELSE\"><block type=\"turtle_backward\"><value name=\"distance\"><block type=\"variables_get\"><field name=\"VAR\" id=\"`M:.#nN.~1fu9IBxU-[u\">SHORT_MARK_LENGTH</field></block></value></block></statement><next><block type=\"turtle_home\"><comment pinned=\"false\" h=\"80\" w=\"160\">Volta a tartaruga para o centro (0,0) e heading 0 (direita) para a próxima marca</comment></block></next></block></next></block></next></block></next></block></next></block></statement></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1,"diffs":[[1,"/**\n * Variáveis globais para o tempo\n */\n// Desenha os ponteiros do relógio (horas, minutos, segundos).\nfunction drawHands () {\n    // Cor dos ponteiros: Preto\n    turtle.pencolor(15)\n    // --- Ponteiro das Horas ---\n    // 'hours' já está ajustado para o formato 1-12.\n    // O ângulo é (hora_fracionária / 12) * 360 graus, o que simplifica para hora_fracionária * 30 graus.\n    // turtle.home() garante que o heading é 0 (direita) antes da rotação.\n    turtle.right((hours + minutes / 60 + seconds / 3600) * 30)\n    turtle.forward(HOUR_HAND_LENGTH)\n    // Volta ao centro (0,0), heading 0 (direita)\n    turtle.home()\n    // --- Ponteiro dos Minutos ---\n    // O ângulo é (minuto_fracionário / 60) * 360 graus, o que simplifica para minuto_fracionário * 6 graus.\n    turtle.right((minutes + seconds / 60) * 6)\n    turtle.forward(MINUTE_HAND_LENGTH)\n    // Volta ao centro (0,0), heading 0 (direita)\n    turtle.home()\n    // --- Ponteiro dos Segundos ---\n    // O ângulo é (segundo / 60) * 360 graus, o que simplifica para segundo * 6 graus.\n    turtle.right(seconds * 6)\n    turtle.forward(SECOND_HAND_LENGTH)\n    // Volta ao centro (0,0), heading 0 (direita)\n    turtle.home()\n}\n// Desenha o mostrador do relógio com as marcas das horas.\nfunction drawDial () {\n    // Cor do mostrador: Vermelho\n    turtle.pencolor(2)\n    for (let i = 0; i <= 11; i++) {\n        // Desenha 12 marcas (para as horas 0 a 11)\n        // turtle.home() foi chamado no final da iteração anterior (ou na configuração inicial),\n        // então o heading da tartaruga é 0 (para a direita) antes desta rotação.\n        // Gira 30 graus para cada marca de hora (360 graus / 12 horas = 30 graus/hora)\n        turtle.right(i * 30)\n        turtle.penup()\n        // Move a tartaruga para a borda do mostrador\n        turtle.forward(DIAL_RADIUS)\n        turtle.pendown()\n        // A marca para i=0 (correspondente às 12 horas) é mais longa\n        if (i == 0) {\n            turtle.backward(LONG_MARK_LENGTH)\n        } else {\n            turtle.backward(SHORT_MARK_LENGTH)\n        }\n        // Volta a tartaruga para o centro (0,0) e heading 0 (direita) para a próxima marca\n        turtle.home()\n    }\n}\nlet totalHoursSinceStart = 0\nlet totalMinutesSinceStart = 0\nlet totalSecondsSinceStart = 0\nlet currentTimeMillis = 0\nlet seconds = 0\nlet minutes = 0\nlet hours = 0\nlet SHORT_MARK_LENGTH = 0\nlet LONG_MARK_LENGTH = 0\nlet SECOND_HAND_LENGTH = 0\nlet MINUTE_HAND_LENGTH = 0\nlet HOUR_HAND_LENGTH = 0\nlet DIAL_RADIUS = 0\nscene.setBackgroundColor(9)\n// Será 1-12 para o display\n// --- Constantes de Escala e Tamanho ---\n// Ajustado para caber na tela do MakeCode Arcade (160x120)\n// Raio original do mostrador no exemplo era 100. Novo raio máximo ~50.\nlet SCALE_FACTOR = 0.5\n// Raio do mostrador (ex: 50)\nDIAL_RADIUS = 100 * SCALE_FACTOR\n// Comprimento do ponteiro das horas (ex: 22.5 -> 23)\nHOUR_HAND_LENGTH = 45 * SCALE_FACTOR\n// Comprimento do ponteiro dos minutos (ex: 30)\nMINUTE_HAND_LENGTH = 60 * SCALE_FACTOR\n// Comprimento do ponteiro dos segundos (ex: 37.5 -> 38)\nSECOND_HAND_LENGTH = 75 * SCALE_FACTOR\n// Comprimento da marca longa do mostrador (ex: 10)\nLONG_MARK_LENGTH = 20 * SCALE_FACTOR\n// Comprimento da marca curta do mostrador (ex: 5)\nSHORT_MARK_LENGTH = 10 * SCALE_FACTOR\n// --- Configuração Inicial do Relógio ---\n// Esconde o sprite da tartaruga, queremos ver apenas o desenho\nturtle.hideturtle()\n// Define a velocidade da tartaruga para a mais rápida (sem animação de movimento)\nturtle.speed(0)\n// Define a velocidade da tartaruga para a mais rápida (sem animação de movimento)\n// --- Loop Principal de Atualização do Relógio ---\n// Este bloco será executado a cada 1000 ms (1 segundo)\ngame.onUpdateInterval(1000, function () {\n    // Limpa quaisquer desenhos anteriores da tartaruga da tela de fundo\n    turtle.clear()\n    // Desenha o mostrador do relógio (que é estático, mas precisa ser redesenhado após `turtle.clear()`)\n    drawDial()\n    // --- Cálculo do Tempo de Jogo ---\n    // Tempo em milissegundos desde o início do jogo\n    currentTimeMillis = game.runtime()\n    totalSecondsSinceStart = Math.floor(currentTimeMillis / 1000)\n    seconds = totalSecondsSinceStart % 60\n    totalMinutesSinceStart = Math.floor(totalSecondsSinceStart / 60)\n    minutes = totalMinutesSinceStart % 60\n    totalHoursSinceStart = Math.floor(totalMinutesSinceStart / 60)\n    // Ajusta as horas para o formato 12 horas (1-12)\n    hours = totalHoursSinceStart % 12\n    if (hours == 0) {\n        // Se for 0 (ex: meia-noite ou meio-dia no tempo de jogo), representa como 12\n        hours = 12\n    }\n    // Desenha os ponteiros do relógio com base no tempo calculado\n    drawHands()\n})\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":428,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1749253577064,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1749259223389,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"gamesetbackgroundcolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">9</field></shadow></value><next><block type=\"turtle_init\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"showTurtleSprite\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><next><block type=\"turtle_set_pen_color\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">4</field></shadow></value><next><block type=\"turtle_pen_down\"><next><block type=\"turtle_forward\"><value name=\"steps\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"number_slider\"></shadow><block type=\"math_number\"><field name=\"NUM\">10</field></block></value></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"","README.md":" ","assets.json":"","turtle.ts":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://arcade.makecode.com/blocks/custom\n*/\n\n// Enum para facilitar a escolha da cor da caneta (opcional, mas bom para blocos)\nenum TurtlePenColors {\n    //% block=preto\n    Black = 1,\n    //% block=branco\n    White = 15,\n    //% block=vermelho\n    Red = 2,\n    //% block=azul\n    Blue = 8\n    // Adicione mais cores conforme o índice de cores do Arcade\n}\n\n// Define um namespace para sua extensão\n// Isso ajuda a evitar conflitos de nome com outras extensões ou o código do usuário\n// O comentário \"//% color=#0078D7 icon=\"\\uf188\"\" define a cor e o ícone da categoria de blocos\n// \\uf188 é um código de ícone (ex: um círculo, pode procurar em Font Awesome)\n// Você pode usar um ícone de tartaruga se encontrar um código unicode adequado ou usar uma imagem (mais avançado)\n\n/**\n * Blocos para simular gráficos Turtle.\n */\n//% weight=100 color=#0078D7 icon=\"\\uf14b\" block=\"Tartaruga\"\nnamespace turtle {\n    let currentX: number = screen.width / 2;\n    let currentY: number = screen.height / 2;\n    let currentAngle: number = 0; // 0 graus para a direita, 90 para cima (convenção do Arcade)\n    let penActive: boolean = true;\n    let penColor: number = 1; // Cor padrão (preto no Arcade)\n    let turtleSprite: Sprite = null; // Sprite opcional para visualizar a tartaruga\n\n    /**\n     * Inicializa a tartaruga, opcionalmente mostrando um sprite.\n     * @param showTurtleSprite se verdadeiro, mostra um sprite para a tartaruga, eg: true\n     */\n    //% blockId=\"turtle_init\" block=\"iniciar tartaruga || mostrar sprite %showTurtleSprite\"\n    //% showTurtleSprite.defl=false\n    //% group=\"Configuração\"\n    export function init(showTurtleSprite?: boolean): void {\n        currentX = screen.width / 2;\n        currentY = screen.height / 2;\n        currentAngle = 0; // Apontando para a direita\n        penActive = true;\n        penColor = 1; // Preto\n        screen.fill(0); // Limpa a tela com cor de fundo (ex: transparente ou outra)\n\n        if (showTurtleSprite) {\n            if (turtleSprite) {\n                turtleSprite.destroy();\n            }\n            // Crie uma imagem simples para a tartaruga (ex: um triângulo)\n            const turtleImg = img`\n                . . . . . . . .\n                . . . f . . . .\n                . . f f f . . .\n                . f f f f f . .\n                f f f f f f f .\n                . . . f . . . .\n                . . . f . . . .\n                . . . . . . . .\n            `;\n            turtleSprite = sprites.create(turtleImg, SpriteKind.Player); // Ou um novo SpriteKind\n            turtleSprite.setFlag(SpriteFlag.Ghost, true); // Para não interagir com física\n            updateTurtleSprite();\n        } else if (turtleSprite) {\n            turtleSprite.destroy();\n            turtleSprite = null;\n        }\n    }\n\n    function updateTurtleSprite(): void {\n        if (turtleSprite) {\n            turtleSprite.setPosition(currentX, currentY);\n            // A rotação de sprites no Arcade pode ser diferente da sua currentAngle.\n            // image.rotate() ou transformções podem ser necessárias se quiser rotação visual.\n            // Para simplificar, vamos apenas posicionar.\n        }\n    }\n\n    /**\n     * Move a tartaruga para frente pela distância especificada.\n     * @param steps número de pixels para mover, eg: 50\n     */\n    //% blockId=\"turtle_forward\" block=\"tartaruga avançar %steps passos\"\n    //% steps.shadow=\"number_slider\" steps.min=0 steps.max=100 steps.defl=10\n    //% group=\"Movimento\"\n    export function forward(steps: number): void {\n        const rad = currentAngle * Math.PI / 180;\n        const prevX = currentX;\n        const prevY = currentY;\n\n        currentX += steps * Math.cos(rad);\n        currentY += steps * Math.sin(rad); // No Arcade, Y positivo é para baixo\n\n        if (penActive) {\n            screen.drawLine(Math.round(prevX), Math.round(prevY), Math.round(currentX), Math.round(currentY), penColor);\n        }\n        updateTurtleSprite();\n    }\n\n    /**\n     * Gira a tartaruga para a direita pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_right\" block=\"tartaruga virar à direita %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function right(angle: number): void {\n        currentAngle = (currentAngle + angle) % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Gira a tartaruga para a esquerda pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_left\" block=\"tartaruga virar à esquerda %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function left(angle: number): void {\n        currentAngle = (currentAngle - angle + 360) % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Levanta a caneta da tartaruga (para de desenhar).\n     */\n    //% blockId=\"turtle_pen_up\" block=\"tartaruga levantar caneta\"\n    //% group=\"Caneta\"\n    export function penUp(): void {\n        penActive = false;\n    }\n\n    /**\n     * Abaixa a caneta da tartaruga (começa a desenhar).\n     */\n    //% blockId=\"turtle_pen_down\" block=\"tartaruga abaixar caneta\"\n    //% group=\"Caneta\"\n    export function penDown(): void {\n        penActive = true;\n    }\n\n    /**\n     * Define a cor da caneta da tartaruga.\n     * @param color cor para usar, eg: TurtlePenColors.Red\n     */\n    //% blockId=\"turtle_set_pen_color\" block=\"tartaruga definir cor da caneta para %color\"\n    //% color.shadow=\"colorindexpicker\" color.defl=1\n    //% group=\"Caneta\"\n    export function setPenColor(color: number): void {\n        penColor = color;\n    }\n\n    /**\n     * Move a tartaruga para uma posição absoluta (x, y) sem desenhar uma linha.\n     * @param x coordenada x, eg: 80\n     * @param y coordenada y, eg: 60\n     */\n    //% blockId=\"turtle_go_to\" block=\"tartaruga ir para x %x y %y\"\n    //% x.shadow=\"position\"\n    //% y.shadow=\"position\"\n    //% group=\"Posição\"\n    export function goTo(x: number, y: number): void {\n        const wasPenActive = penActive;\n        penActive = false; // Temporariamente levanta a caneta para mover\n        currentX = x;\n        currentY = y;\n        updateTurtleSprite();\n        penActive = wasPenActive; // Restaura o estado da caneta\n    }\n\n    /**\n     * Define a direção absoluta da tartaruga.\n     * @param angle ângulo em graus (0 para direita), eg: 0\n     */\n    //% blockId=\"turtle_set_heading\" block=\"tartaruga definir direção para %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=359 angle.defl=0\n    //% group=\"Posição\"\n    export function setHeading(angle: number): void {\n        currentAngle = angle % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Limpa a tela e reposiciona a tartaruga no centro.\n     */\n    //% blockId=\"turtle_clear\" block=\"tartaruga limpar tela\"\n    //% group=\"Configuração\"\n    export function clear(): void {\n        screen.fill(0); // Ou a cor de fundo que você preferir\n        init(turtleSprite !== null); // Reinicializa para o centro\n    }\n}\n","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1749304215690,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"gamesetbackgroundcolor\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">9</field></shadow></value><next><block type=\"turtle_init\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"1\" _input_init=\"true\"></mutation><value name=\"showTurtleSprite\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><next><block type=\"turtle_set_pen_color\"><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">4</field></shadow></value><next><block type=\"turtle_pen_down\"><next><block type=\"turtle_forward\"><value name=\"steps\"><shadow xmlns=\"http://www.w3.org/1999/xhtml\" type=\"number_slider\"></shadow><block type=\"math_number\"><field name=\"NUM\">10</field></block></value></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"","README.md":" ","assets.json":"","turtle.ts":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://arcade.makecode.com/blocks/custom\n*/\n\n// Enum para facilitar a escolha da cor da caneta (opcional, mas bom para blocos)\nenum TurtlePenColors {\n    //% block=preto\n    Black = 1,\n    //% block=branco\n    White = 15,\n    //% block=vermelho\n    Red = 2,\n    //% block=azul\n    Blue = 8\n    // Adicione mais cores conforme o índice de cores do Arcade\n}\n\n// Define um namespace para sua extensão\n// Isso ajuda a evitar conflitos de nome com outras extensões ou o código do usuário\n// O comentário \"//% color=#0078D7 icon=\"\\uf188\"\" define a cor e o ícone da categoria de blocos\n// \\uf188 é um código de ícone (ex: um círculo, pode procurar em Font Awesome)\n// Você pode usar um ícone de tartaruga se encontrar um código unicode adequado ou usar uma imagem (mais avançado)\n\n/**\n * Blocos para simular gráficos Turtle.\n */\n//% weight=100 color=#0078D7 icon=\"\\uf14b\" block=\"Tartaruga\"\nnamespace turtle {\n    let currentX: number = screen.width / 2;\n    let currentY: number = screen.height / 2;\n    let currentAngle: number = 0; // 0 graus para a direita, 90 para cima (convenção do Arcade)\n    let penActive: boolean = true;\n    let penColor: number = 1; // Cor padrão (preto no Arcade)\n    let turtleSprite: Sprite = null; // Sprite opcional para visualizar a tartaruga\n\n    /**\n     * Inicializa a tartaruga, opcionalmente mostrando um sprite.\n     * @param showTurtleSprite se verdadeiro, mostra um sprite para a tartaruga, eg: true\n     */\n    //% blockId=\"turtle_init\" block=\"iniciar tartaruga || mostrar sprite %showTurtleSprite\"\n    //% showTurtleSprite.defl=false\n    //% group=\"Configuração\"\n    export function init(showTurtleSprite?: boolean): void {\n        currentX = screen.width / 2;\n        currentY = screen.height / 2;\n        currentAngle = 0; // Apontando para a direita\n        penActive = true;\n        penColor = 1; // Preto\n        screen.fill(0); // Limpa a tela com cor de fundo (ex: transparente ou outra)\n\n        if (showTurtleSprite) {\n            if (turtleSprite) {\n                turtleSprite.destroy();\n            }\n            // Crie uma imagem simples para a tartaruga (ex: um triângulo)\n            const turtleImg = img`\n                . . . . . . . .\n                . . . f . . . .\n                . . f f f . . .\n                . f f f f f . .\n                f f f f f f f .\n                . . . f . . . .\n                . . . f . . . .\n                . . . . . . . .\n            `;\n            turtleSprite = sprites.create(turtleImg, SpriteKind.Player); // Ou um novo SpriteKind\n            turtleSprite.setFlag(SpriteFlag.Ghost, true); // Para não interagir com física\n            updateTurtleSprite();\n        } else if (turtleSprite) {\n            turtleSprite.destroy();\n            turtleSprite = null;\n        }\n    }\n\n    function updateTurtleSprite(): void {\n        if (turtleSprite) {\n            turtleSprite.setPosition(currentX, currentY);\n            // A rotação de sprites no Arcade pode ser diferente da sua currentAngle.\n            // image.rotate() ou transformções podem ser necessárias se quiser rotação visual.\n            // Para simplificar, vamos apenas posicionar.\n        }\n    }\n\n    /**\n     * Move a tartaruga para frente pela distância especificada.\n     * @param steps número de pixels para mover, eg: 50\n     */\n    //% blockId=\"turtle_forward\" block=\"tartaruga avançar %steps passos\"\n    //% steps.shadow=\"number_slider\" steps.min=0 steps.max=100 steps.defl=10\n    //% group=\"Movimento\"\n    export function forward(steps: number): void {\n        const rad = currentAngle * Math.PI / 180;\n        const prevX = currentX;\n        const prevY = currentY;\n\n        currentX += steps * Math.cos(rad);\n        currentY += steps * Math.sin(rad); // No Arcade, Y positivo é para baixo\n\n        if (penActive) {\n            screen.drawLine(Math.round(prevX), Math.round(prevY), Math.round(currentX), Math.round(currentY), penColor);\n        }\n        updateTurtleSprite();\n    }\n\n    /**\n     * Gira a tartaruga para a direita pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_right\" block=\"tartaruga virar à direita %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function right(angle: number): void {\n        currentAngle = (currentAngle + angle) % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Gira a tartaruga para a esquerda pelo ângulo especificado.\n     * @param angle graus para girar, eg: 90\n     */\n    //% blockId=\"turtle_left\" block=\"tartaruga virar à esquerda %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=360 angle.defl=90\n    //% group=\"Movimento\"\n    export function left(angle: number): void {\n        currentAngle = (currentAngle - angle + 360) % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Levanta a caneta da tartaruga (para de desenhar).\n     */\n    //% blockId=\"turtle_pen_up\" block=\"tartaruga levantar caneta\"\n    //% group=\"Caneta\"\n    export function penUp(): void {\n        penActive = false;\n    }\n\n    /**\n     * Abaixa a caneta da tartaruga (começa a desenhar).\n     */\n    //% blockId=\"turtle_pen_down\" block=\"tartaruga abaixar caneta\"\n    //% group=\"Caneta\"\n    export function penDown(): void {\n        penActive = true;\n    }\n\n    /**\n     * Define a cor da caneta da tartaruga.\n     * @param color cor para usar, eg: TurtlePenColors.Red\n     */\n    //% blockId=\"turtle_set_pen_color\" block=\"tartaruga definir cor da caneta para %color\"\n    //% color.shadow=\"colorindexpicker\" color.defl=1\n    //% group=\"Caneta\"\n    export function setPenColor(color: number): void {\n        penColor = color;\n    }\n\n    /**\n     * Move a tartaruga para uma posição absoluta (x, y) sem desenhar uma linha.\n     * @param x coordenada x, eg: 80\n     * @param y coordenada y, eg: 60\n     */\n    //% blockId=\"turtle_go_to\" block=\"tartaruga ir para x %x y %y\"\n    //% x.shadow=\"position\"\n    //% y.shadow=\"position\"\n    //% group=\"Posição\"\n    export function goTo(x: number, y: number): void {\n        const wasPenActive = penActive;\n        penActive = false; // Temporariamente levanta a caneta para mover\n        currentX = x;\n        currentY = y;\n        updateTurtleSprite();\n        penActive = wasPenActive; // Restaura o estado da caneta\n    }\n\n    /**\n     * Define a direção absoluta da tartaruga.\n     * @param angle ângulo em graus (0 para direita), eg: 0\n     */\n    //% blockId=\"turtle_set_heading\" block=\"tartaruga definir direção para %angle graus\"\n    //% angle.shadow=\"number_slider\" angle.min=0 angle.max=359 angle.defl=0\n    //% group=\"Posição\"\n    export function setHeading(angle: number): void {\n        currentAngle = angle % 360;\n        updateTurtleSprite();\n    }\n\n    /**\n     * Limpa a tela e reposiciona a tartaruga no centro.\n     */\n    //% blockId=\"turtle_clear\" block=\"tartaruga limpar tela\"\n    //% group=\"Configuração\"\n    export function clear(): void {\n        screen.fill(0); // Ou a cor de fundo que você preferir\n        init(turtleSprite !== null); // Reinicializa para o centro\n    }\n}\n","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1749306499242,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"T=*C+ws+^6nEm/}ykYA!\">index</variable></variables><block type=\"pxt-on-start\" x=\"-83\" y=\"36\"><statement name=\"HANDLER\"><block type=\"myTurtle_start\"><comment pinned=\"false\" h=\"80\" w=\"160\">Em main.ts (JavaScript)\nDesenhe uma imagem simples para a tartaruga</comment><next><block type=\"myTurtle_setPenColor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"cor\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"myTurtle_forward\"><value name=\"distancia\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"myTurtle_turnRight\"><value name=\"angulo\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block></next></block></next></block></statement></block></xml>","main.ts":"","README.md":" ","assets.json":"","turtle.ts":"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Tartaruga\"\n// Usando uma cor verde mais escura e o mesmo ícone de tartaruga (bug)\nnamespace myTurtle {\n    let turtleSprite: Sprite = null;\n    let isPenDownFlag: boolean = true;\n    let penColor: number = 1; // Cor padrão (branco)\n    let currentAngle: number = 0; // 0 graus = para a direita\n\n    let turtleX: number = scene.screenWidth() / 2;\n    let turtleY: number = scene.screenHeight() / 2;\n\n    // --- Constantes de Animação ---\n    const ANIMATION_FRAME_DURATION = 150; // ms entre frames da caminhada\n    const PIXELS_PER_STEP = 4; // Quantos pixels a tartaruga anda por frame de animação\n\n    // --- Arte da Tartaruga (Frames) ---\n    // Direções para indexar os arrays de frames\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;\n\n    let currentVisualDirection = DIR_RIGHT;\n    let turtleIdleFrames: Image[];\n    let turtleWalkFrames: Image[][]; // [direção][frame_index]\n\n    // --- IMAGENS DA TARTARUGA ---\n    // (Estas são representações simplificadas, você pode desenhar as suas no editor de sprites do MakeCode e colar o código aqui)\n\n    // Direita\n    const turtle_R_idle = img`\n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . e . . . e . . . . . . \n        . . . . e . . . . . e . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n    const turtle_R_walk1 = img`\n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . . . . . e . . . . . . \n        . . . . . . . . . . e . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n    const turtle_R_walk2 = img`\n        . . . . . . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . 7 7 7 7 7 7 7 7 7 . . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . e e e 7 7 7 7 7 7 7 7 e . . . \n        . . e e 7 7 7 7 7 7 7 7 7 . . . \n        . . . . 7 7 7 7 7 7 7 . . . . . \n        . . . . . 7 7 7 7 7 . . . . . . \n        . . . . . . 7 7 7 . . . . . . . \n        . . . . . e . . . . . . . . . . \n        . . . . e . . . . . . . . . . . \n        . . . . . . . . . . . . . . . . \n        `;\n\n    // Cima (imagens giradas - idealmente seriam desenhadas especificamente)\n    // Para simplificar, vou usar as mesmas da direita por enquanto, mas idealmente você criaria/giraria estas:\n    const turtle_U_idle = turtle_R_idle.clone(); // Clone para não modificar a original\n    turtle_U_idle.flipY(); // Exemplo de transformação, não é rotação correta\n    const turtle_U_walk1 = turtle_R_walk1.clone();\n    turtle_U_walk1.flipY();\n    const turtle_U_walk2 = turtle_R_walk2.clone();\n    turtle_U_walk2.flipY();\n\n    // Esquerda\n    const turtle_L_idle = turtle_R_idle.clone();\n    turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone();\n    turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone();\n    turtle_L_walk2.flipX();\n\n    // Baixo\n    const turtle_D_idle = turtle_L_idle.clone(); // Clone da esquerda\n    turtle_D_idle.flipY(); // Exemplo de transformação\n    const turtle_D_walk1 = turtle_L_walk1.clone();\n    turtle_D_walk1.flipY();\n    const turtle_D_walk2 = turtle_L_walk2.clone();\n    turtle_D_walk2.flipY();\n\n\n    function _initializeTurtleFrames() {\n        turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n        turtleWalkFrames = [\n            [turtle_R_walk1, turtle_R_walk2], // Direita\n            [turtle_U_walk1, turtle_U_walk2], // Cima\n            [turtle_L_walk1, turtle_L_walk2], // Esquerda\n            [turtle_D_walk1, turtle_D_walk2]  // Baixo\n        ];\n    }\n\n    function _setVisualOrientation() {\n        if (!turtleSprite) return;\n        // Normaliza o ângulo para 0-359\n        let normalizedAngle = (currentAngle % 360 + 360) % 360;\n\n        if (normalizedAngle >= 315 || normalizedAngle < 45) { // Direita\n            currentVisualDirection = DIR_RIGHT;\n        } else if (normalizedAngle >= 45 && normalizedAngle < 135) { // Baixo\n            currentVisualDirection = DIR_DOWN;\n        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // Esquerda\n            currentVisualDirection = DIR_LEFT;\n        } else { // Cima (normalizedAngle >= 225 && normalizedAngle < 315)\n            currentVisualDirection = DIR_UP;\n        }\n        turtleSprite.setImage(turtleIdleFrames[currentVisualDirection]);\n    }\n\n    //% block=\"iniciar tartaruga\"\n    //% weight=100\n    export function start(): void {\n        _initializeTurtleFrames(); // Carrega as imagens nos arrays\n\n        if (turtleSprite) {\n            turtleSprite.destroy();\n        }\n        // Cria o sprite com a imagem inicial (parado, virado para a direita)\n        turtleSprite = sprites.create(turtleIdleFrames[DIR_RIGHT], SpriteKind.Player);\n        turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n\n        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n\n        currentAngle = 0; // Apontando para a direita\n        currentVisualDirection = DIR_RIGHT; // Sincroniza direção visual\n        _setVisualOrientation(); // Define a imagem correta\n\n        isPenDownFlag = true;\n        penColor = 1;\n        // scene.backgroundImage().fill(scene.backgroundColor()); // Limpa a tela\n    }\n\n    //% block=\"tartaruga para frente %distancia pixels\"\n    //% distancia.defl=50\n    //% weight=90\n    export function forward(distancia: number): void {\n        if (!turtleSprite) return;\n\n        const isMovingBackward = distancia < 0;\n        const absDistancia = Math.abs(distancia);\n\n        const radianos = currentAngle * Math.PI / 180;\n        // Se movendo para trás, invertemos a direção do delta\n        const directionMultiplier = isMovingBackward ? -1 : 1;\n        const totalDeltaX = Math.cos(radianos) * absDistancia * directionMultiplier;\n        const totalDeltaY = Math.sin(radianos) * absDistancia * directionMultiplier;\n\n        const numAnimationSteps = Math.max(1, Math.ceil(absDistancia / PIXELS_PER_STEP));\n        const stepDx = totalDeltaX / numAnimationSteps;\n        const stepDy = totalDeltaY / numAnimationSteps;\n\n        let currentWalkFrameIndex = 0;\n        const walkCycle = turtleWalkFrames[currentVisualDirection];\n\n        for (let i = 0; i < numAnimationSteps; i++) {\n            // Atualiza frame da animação\n            turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n            currentWalkFrameIndex = (currentWalkFrameIndex + 1) % walkCycle.length;\n\n            const prevX = turtleX;\n            const prevY = turtleY;\n\n            turtleX += stepDx;\n            turtleY += stepDy;\n\n            if (isPenDownFlag) {\n                scene.backgroundImage().drawLine(\n                    Math.round(prevX),\n                    Math.round(prevY),\n                    Math.round(turtleX),\n                    Math.round(turtleY),\n                    penColor\n                );\n            }\n            turtleSprite.setPosition(turtleX, turtleY);\n            pause(ANIMATION_FRAME_DURATION);\n        }\n        // Volta para o frame de idle ao terminar\n        turtleSprite.setImage(turtleIdleFrames[currentVisualDirection]);\n    }\n\n    //% block=\"tartaruga para trás %distancia pixels\"\n    //% distancia.defl=50\n    //% weight=85\n    export function backward(distancia: number): void {\n        forward(-distancia); // Reutiliza a lógica do forward com distância negativa\n    }\n\n    //% block=\"tartaruga virar à esquerda %angulo graus\"\n    //% angulo.defl=90\n    //% weight=80\n    export function turnLeft(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle -= angulo;\n        _setVisualOrientation();\n    }\n\n    //% block=\"tartaruga virar à direita %angulo graus\"\n    //% angulo.defl=90\n    //% weight=75\n    export function turnRight(angulo: number): void {\n        if (!turtleSprite) return;\n        currentAngle += angulo;\n        _setVisualOrientation();\n    }\n\n    //% block=\"levantar caneta da tartaruga\"\n    //% weight=70\n    export function penUp(): void {\n        isPenDownFlag = false;\n    }\n\n    //% block=\"abaixar caneta da tartaruga\"\n    //% weight=65\n    export function penDown(): void {\n        isPenDownFlag = true;\n    }\n\n    //% block=\"definir cor da caneta para %cor=colorindexpicker\"\n    //% weight=60\n    export function setPenColor(cor: number): void {\n        penColor = cor;\n    }\n\n    //% block=\"limpar desenhos da tartaruga\"\n    //% weight=55\n    export function clear(): void {\n        scene.backgroundImage().fill(scene.backgroundColor());\n    }\n\n    //% block=\"tartaruga ir para casa (centro)\"\n    //% weight=50\n    export function home(): void {\n        if (!turtleSprite) return;\n        turtleX = scene.screenWidth() / 2;\n        turtleY = scene.screenHeight() / 2;\n        turtleSprite.setPosition(turtleX, turtleY);\n        currentAngle = 0;\n        _setVisualOrientation();\n    }\n}\n","main.py":"# Em main.ts (JavaScript)\nmyTurtle.start()\n# Vermelho\nmyTurtle.set_pen_color(2)\nfor index in range(4):\n    myTurtle.forward(30)\n    myTurtle.turn_right(90)","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1749309778444,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Vermelho</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"turtle_forward\"><value name=\"distance\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value><next><block type=\"turtle_left\"><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block></next></block></statement></block></xml>","main.ts":"// Código de Teste para a Extensão Turtle\n// Coloque este código no seu main.ts\n\n// --- Início dos Testes ---\ngame.splash(\"Iniciando Testes da Turtle...\")\npause(1000)\n\n// 1. Setup Inicial e Quadrado\nturtle.reset()\nturtle.speed(6) // Velocidade média para observação\ngame.splash(\"Teste 1: Quadrado Vermelho\")\nturtle.pencolor(2) // Vermelho\nturtle.pendown()\nfor (let i = 0; i < 4; i++) {\n    turtle.forward(50)\n    turtle.right(90) // Deve virar à direita (horário)\n}\npause(1500)\n\n// 2. Mover sem Desenhar e Triângulo com heading\ngame.splash(\"Teste 2: Mover e Triângulo Azul\")\nturtle.penup()\nturtle.goto(20, 30)\nturtle.setheading(0) // Apontar para a direita\n\nturtle.pencolor(4) // Azul\nturtle.pendown()\nfor (let i = 0; i < 3; i++) {\n    turtle.forward(40)\n    turtle.left(120) // Deve virar à esquerda (anti-horário)\n}\npause(1500)\n\n// 3. Testar hideturtle e showturtle\ngame.splash(\"Teste 3: Esconder/Mostrar Tartaruga\")\nturtle.hideturtle()\ngame.splash(\"Tartaruga escondida, movendo...\")\nturtle.pencolor(14) // Amarelo escuro\nturtle.forward(25)\npause(1000)\n\nturtle.showturtle()\ngame.splash(\"Tartaruga visível, movendo para trás...\")\nturtle.backward(20)\npause(1500)\n\n// 4. Testar home e clear\ngame.splash(\"Teste 4: Home e Clear\")\nturtle.home() // Volta para o centro, heading 0\nturtle.pencolor(5) // Roxo\nturtle.forward(30)\npause(1000)\n\nturtle.clear() // Limpa o desenho, tartaruga permanece\ngame.splash(\"Desenhos limpos. Tartaruga no lugar.\")\nturtle.right(45)\nturtle.forward(20) // Desenha algo para confirmar\npause(1500)\n\n// 5. Testar reset\ngame.splash(\"Teste 5: Reset Total\")\nturtle.reset()\n// Tela limpa, tartaruga no centro, virada para direita, caneta branca/1, abaixada\nturtle.forward(25) // Deve desenhar uma linha branca/padrão\npause(1500)\n\n// 6. Testar diferentes velocidades\ngame.splash(\"Teste 6: Velocidades\")\nturtle.reset()\nturtle.pencolor(7) // Laranja\nturtle.goto(40, 60)\n\ngame.splash(\"Velocidade 1 (Lenta)\")\nturtle.speed(1)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 10 (Rápida)\")\nturtle.speed(10)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 0 (Instantânea)\")\nturtle.speed(0)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\nturtle.speed(6) // Volta para uma velocidade padrão\npause(1500)\n\n// 7. Testar pensize (chamada de função)\ngame.splash(\"Teste 7: Pensize (ver console)\")\nconsole.log(\"--- Teste Pensize ---\")\nconsole.log(\"Chamando turtle.pensize(5)\")\nturtle.pensize(5)\nturtle.pencolor(3) // Verde claro\nturtle.forward(15)\nconsole.log(\"Chamando turtle.pensize(1)\")\nturtle.pensize(1)\nturtle.backward(15) // Para ver a linha sobreposta se pensize funcionasse visualmente\npause(1500)\n\n// 8. Testar limites da tela e heading para todas as direções\ngame.splash(\"Teste 8: Direções Cardeais\")\nturtle.reset()\nturtle.speed(4)\n\n// Direita (0 graus)\nturtle.setheading(0)\nturtle.pencolor(2) // Vermelho\nturtle.forward(60)\npause(500)\n\n// Cima (90 graus)\nturtle.home()\nturtle.setheading(90)\nturtle.pencolor(4) // Azul\nturtle.forward(40)\npause(500)\n\n// Esquerda (180 graus)\nturtle.home()\nturtle.setheading(180)\nturtle.pencolor(3) // Verde\nturtle.forward(60)\npause(500)\n\n// Baixo (270 graus)\nturtle.home()\nturtle.setheading(270)\nturtle.pencolor(5) // Roxo\nturtle.forward(40)\npause(1000)\n\n// 9. Teste de \"estrela\" ou padrão radial\ngame.splash(\"Teste 9: Padrão Radial\")\nturtle.reset()\nturtle.speed(7)\nturtle.pencolor(10) // Rosa\nfor (let i = 0; i < 12; i++) {\n    turtle.forward(50)\n    turtle.backward(50) // Volta para o centro\n    turtle.right(30)    // Gira 30 graus\n}\npause(1500)\n\n// 10. Testar estado da caneta com isdown()\ngame.splash(\"Teste 10: Estado da Caneta (isdown)\")\nturtle.reset()\nturtle.speed(5)\nturtle.pencolor(1)\nconsole.log(\"--- Teste isdown ---\")\nconsole.log(\"Pen deve estar DOWN por padrão após reset: \" + turtle.isdown()) // True\nturtle.forward(20)\nturtle.penup()\nconsole.log(\"Pen deve estar UP: \" + turtle.isdown()) // False\nturtle.forward(20) // Não deve desenhar\nturtle.pendown()\nconsole.log(\"Pen deve estar DOWN: \" + turtle.isdown()) // True\nturtle.forward(20)\npause(1500)\n\n// 11. Testar informações de estado (heading, xcor, ycor, position)\ngame.splash(\"Teste 11: Info de Estado (ver console)\")\nturtle.reset()\nturtle.goto(10, 20)\nturtle.setheading(45)\nconsole.log(\"--- Teste Info Estado ---\")\nconsole.log(\"Heading esperado ~45: \" + turtle.heading())\nconsole.log(\"XCOR esperado ~10: \" + turtle.xcor())\nconsole.log(\"YCOR esperado ~20: \" + turtle.ycor())\nlet currentPos = turtle.position()\nconsole.log(\"Position esperada x:~10, y:~20 : x=\" + currentPos.x + \", y=\" + currentPos.y)\nturtle.forward(10)\nconsole.log(\"Novo Heading (ainda 45): \" + turtle.heading())\ncurrentPos = turtle.position()\nconsole.log(\"Nova Posição: x=\" + currentPos.x + \", y=\" + currentPos.y)\npause(1000)\n\n\ngame.splash(\"Testes Concluídos!\")","README.md":" ","assets.json":"","turtle.ts":"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Turtle\"\n// Namespace agora é \"turtle\" para corresponder ao Python\nnamespace turtle {\n    let _turtleSprite: Sprite = null;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1; // Cor padrão (branco no MakeCode)\n    let _currentHeading: number = 0; // 0 graus = para a direita (padrão do MakeCode e Turtle Python)\n\n    let _turtleX: number = scene.screenWidth() / 2;\n    let _turtleY: number = scene.screenHeight() / 2;\n    let _isTurtleVisible: boolean = true;\n\n    // --- Constantes de Animação ---\n    const ANIMATION_FRAME_DURATION = 150; // ms entre frames da caminhada\n    const PIXELS_PER_STEP = 4; // Quantos pixels a tartaruga anda por frame de animação\n    let _turtleSpeed = 6; // Padrão do Python (0-10, 0 é o mais rápido).\n\n    // --- Arte da Tartaruga (Frames) ---\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;    // Corresponde ao ângulo de -90 ou 270 graus (para cima na tela)\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;  // Corresponde ao ângulo de 90 graus (para baixo na tela)\n\n    let _currentVisualDirection = DIR_RIGHT;\n    let _turtleIdleFrames: Image[];\n    let _turtleWalkFrames: Image[][];\n\n    // --- IMAGENS DA TARTARUGA ---\n    // Você já forneceu a imagem base, vou usar uma similar para R_idle, R_walk1, R_walk2\n    // Por favor, substitua estas com as suas imagens exatas se forem diferentes.\n\n    const turtle_R_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo de tartaruga verde simples - substitua pela sua\n    const turtle_R_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . f f .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo - substitua pela sua\n    const turtle_R_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // Exemplo - substitua pela sua\n\n    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX();\n\n    // !!! IMPORTANTE: CRIE ESTAS IMAGENS MANUALMENTE NO EDITOR DE SPRITES !!!\n    // Copie a 'turtle_R_idle', cole como 'turtle_U_idle', abra no editor e rotacione.\n    // Repita para walk1, walk2 e para as versões _D_ (para baixo).\n    const turtle_U_idle = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA CIMA\n    const turtle_U_walk1 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA CIMA\n    const turtle_U_walk2 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA CIMA\n\n    const turtle_D_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA BAIXO\n    const turtle_D_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA BAIXO\n    const turtle_D_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA BAIXO\n\n\n    function _initializeTurtleFrames() {\n        _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n        _turtleWalkFrames = [\n            [turtle_R_walk1, turtle_R_walk2], // Direita (DIR_RIGHT = 0)\n            [turtle_U_walk1, turtle_U_walk2], // Cima    (DIR_UP = 1)\n            [turtle_L_walk1, turtle_L_walk2], // Esquerda(DIR_LEFT = 2)\n            [turtle_D_walk1, turtle_D_walk2]  // Baixo   (DIR_DOWN = 3)\n        ];\n    }\n\n    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0; // Mais rápido (quase instantâneo)\n        let duration = ANIMATION_FRAME_DURATION;\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            // Python: 1=slowest, 10=fast.\n            // MakeCode: vamos fazer speed 1 = mais lento (maior pausa), speed 10 = mais rápido (menor pausa)\n            duration = 25 + (10 - _turtleSpeed) * 25; // Ex: speed 1 -> 250ms, speed 10 -> 25ms\n        }\n        return duration;\n    }\n\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            _initializeTurtleFrames();\n            // Verifica se todas as imagens foram carregadas (simplesmente checando se não são nulas)\n            // Se alguma imagem estiver faltando (porque não foi colada), isso pode causar um erro aqui.\n            if (!_turtleIdleFrames[0] || !_turtleIdleFrames[1] || !_turtleIdleFrames[2] || !_turtleIdleFrames[3] ||\n                !_turtleWalkFrames[0][0] || !_turtleWalkFrames[1][0] || !_turtleWalkFrames[2][0] || !_turtleWalkFrames[3][0]) {\n                console.error(\"TURTLE EXTENSION: One or more turtle images are missing. Please define all idle and walk frames.\");\n                // Poderia lançar um erro ou usar uma imagem padrão de fallback\n                // Por agora, apenas loga e continua, o que pode levar a erros visuais.\n            }\n\n            _turtleSprite = sprites.create(_turtleIdleFrames[DIR_RIGHT], SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n            _turtleX = scene.screenWidth() / 2;\n            _turtleY = scene.screenHeight() / 2;\n            _turtleSprite.setPosition(_turtleX, _turtleY);\n            _currentHeading = 0; // Direita\n            _currentVisualDirection = DIR_RIGHT;\n            _isPenDown = true;\n            _penColor = 1; // Branco\n            _isTurtleVisible = true;\n            _setVisualOrientation();\n        }\n    }\n\n    function _setVisualOrientation() {\n        _ensureTurtleExists();\n        let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n\n        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo\n        // _currentVisualDirection: DIR_RIGHT=0, DIR_UP=1, DIR_LEFT=2, DIR_DOWN=3\n\n        if (normalizedAngle >= 315 || normalizedAngle < 45) {       // 0 graus +/- 45 -> Direita\n            _currentVisualDirection = DIR_RIGHT;\n        } else if (normalizedAngle >= 45 && normalizedAngle < 135) {  // 90 graus +/- 45 -> Cima\n            _currentVisualDirection = DIR_UP;\n        } else if (normalizedAngle >= 135 && normalizedAngle < 225) { // 180 graus +/- 45 -> Esquerda\n            _currentVisualDirection = DIR_LEFT;\n        } else { // (normalizedAngle >= 225 && normalizedAngle < 315) // 270 graus +/- 45 -> Baixo\n            _currentVisualDirection = DIR_DOWN;\n        }\n\n        if (_isTurtleVisible && _turtleIdleFrames[_currentVisualDirection]) {\n            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n        } else if (!_turtleIdleFrames[_currentVisualDirection]) {\n            console.warn(\"TURTLE: Idle frame missing for current visual direction: \" + _currentVisualDirection);\n        }\n    }\n\n    // --- Turtle Motion ---\n\n    //% block=\"forward %distance pixels\"\n    //% blockAlias=fd\n    //% distance.defl=50\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _ensureTurtleExists();\n        const isMovingBackward = distance < 0; // Não usado diretamente aqui, mas pode ser útil\n        const absDistance = Math.abs(distance);\n        const effectiveDistance = distance; // Usar a distância com sinal para direção\n\n        // _currentHeading: 0=Direita, 90=Cima, 180=Esquerda, 270=Baixo (Padrão Turtle Python)\n        const radians = _currentHeading * Math.PI / 180;\n\n        // MakeCode Y aumenta para baixo.\n        // Se heading é 90 (Cima), sin(90)=1. Queremos Y diminuindo. Então -sin().\n        const totalDeltaX = Math.cos(radians) * effectiveDistance;\n        const totalDeltaY = -Math.sin(radians) * effectiveDistance; // Y invertido para MakeCode\n\n        const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n        const stepDx = totalDeltaX / numAnimationSteps;\n        const stepDy = totalDeltaY / numAnimationSteps;\n\n        let currentWalkFrameIndex = 0;\n        // A direção visual já foi definida por _setVisualOrientation após left/right/seth\n        const walkCycle = _turtleWalkFrames[_currentVisualDirection];\n        const animDuration = _getAnimationDuration();\n\n        if (!walkCycle || walkCycle.length === 0 || !walkCycle[0]) {\n            console.warn(\"TURTLE: Walk cycle missing or empty for current visual direction: \" + _currentVisualDirection);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n            _turtleX += totalDeltaX;\n            _turtleY += totalDeltaY;\n            if (_isPenDown) {\n                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n            }\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            if (_isTurtleVisible) _setVisualOrientation();\n            return;\n        }\n\n        for (let i = 0; i < numAnimationSteps; i++) {\n            if (_isTurtleVisible) {\n                _turtleSprite.setImage(walkCycle[currentWalkFrameIndex]);\n            }\n            currentWalkFrameIndex = (currentWalkFrameIndex + 1) % walkCycle.length;\n\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n\n            _turtleX += stepDx;\n            _turtleY += stepDy;\n\n            if (_isPenDown) {\n                scene.backgroundImage().drawLine(Math.round(prevX), Math.round(prevY), Math.round(_turtleX), Math.round(_turtleY), _penColor);\n            }\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            if (animDuration > 0) {\n                pause(animDuration);\n            }\n        }\n        if (_isTurtleVisible) {\n            _setVisualOrientation();\n        }\n    }\n\n    //% block=\"fd %distance pixels\"\n    //% distance.defl=50\n    //% group=\"Movement\" weight=99\n    //% blockHidden=true\n    export function fd(distance: number): void {\n        forward(distance);\n    }\n\n    //% block=\"backward %distance pixels\"\n    //% blockAlias=bk,back\n    //% distance.defl=50\n    //% group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        forward(-distance); // forward já lida com distância negativa para animação\n    }\n    //% block=\"bk %distance pixels\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance pixels\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n\n    //% block=\"left %angle degrees\"\n    //% blockAlias=lt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading += angle; // CORREÇÃO: left aumenta o ângulo (gira anti-horário)\n        _setVisualOrientation();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\"\n    //% blockAlias=rt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading -= angle; // CORREÇÃO: right diminui o ângulo (gira horário)\n        _setVisualOrientation();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos,setposition\n    //% x.defl=80 y.defl=60\n    //% group=\"Movement\" weight=60\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        // Coordenadas MakeCode: (0,0) canto superior esquerdo.\n        // Turtle Python: (0,0) centro.\n        // Esta extensão usa coordenadas MakeCode para goto.\n        // Se quiser simular o centro, o usuário da extensão precisaria ajustar.\n\n        if (_isPenDown) { // Turtle Python não desenha em goto por padrão, mas alguns podem querer\n            // scene.backgroundImage().drawLine(Math.round(_turtleX), Math.round(_turtleY), Math.round(x), Math.round(y), _penColor);\n        }\n        _turtleX = x;\n        _turtleY = y;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=59 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=58 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n\n    //% block=\"set heading %to_angle degrees\"\n    //% blockAlias=seth\n    //% to_angle.defl=0\n    //% group=\"Movement\" weight=50\n    export function setheading(to_angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading = to_angle;\n        _setVisualOrientation();\n    }\n    //% block=\"seth %to_angle degrees\" group=\"Movement\" weight=49 blockHidden=true\n    export function seth(to_angle: number): void { setheading(to_angle); }\n\n    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists();\n        _turtleX = scene.screenWidth() / 2;\n        _turtleY = scene.screenHeight() / 2;\n        _turtleSprite.setPosition(_turtleX, _turtleY);\n        _currentHeading = 0; // Padrão Turtle Python: 0 é para a direita\n        _setVisualOrientation();\n        // Turtle Python também redefine a caneta para baixo e cor padrão, etc.\n        // pendown(); // Opcional, se quiser que home sempre baixe a caneta\n        // pencolor(1); // Opcional\n    }\n\n    //% block=\"speed %speedValue (0-10)\"\n    //% speedValue.min=0 speedValue.max=10 speedValue.defl=6\n    //% group=\"Movement\" weight=30\n    export function speed(speedValue: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, speedValue);\n    }\n\n    // --- Pen Control ---\n\n    //% block=\"pen down\"\n    //% blockAlias=pd,down\n    //% group=\"Pen Control\" weight=100\n    export function pendown(): void {\n        _ensureTurtleExists();\n        _isPenDown = true;\n    }\n    //% block=\"pd\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"pen up\"\n    //% blockAlias=pu,up\n    //% group=\"Pen Control\" weight=90\n    export function penup(): void {\n        _ensureTurtleExists();\n        _isPenDown = false;\n    }\n    //% block=\"pu\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n    }\n\n    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=70\n    export function isdown(): boolean {\n        _ensureTurtleExists();\n        return _isPenDown;\n    }\n\n    //% block=\"pen size %widthNum\"\n    //% blockAlias=width\n    //% widthNum.defl=1\n    //% group=\"Pen Control\" weight=60\n    export function pensize(widthNum: number): void {\n        _ensureTurtleExists();\n        // Implementação básica: por enquanto não afeta a linha visualmente.\n        // Para implementar, precisaríamos mudar a lógica de drawLine.\n        console.log(\"pensize (\" + widthNum + \") not fully implemented yet for visual line thickness.\");\n    }\n    //% block=\"width %widthNum\" group=\"Pen Control\" weight=59 blockHidden=true\n    export function width(w: number): void { pensize(w); }\n\n\n    // --- Turtle State ---\n\n    //% block=\"heading\"\n    //% group=\"Turtle State\" weight=100\n    export function heading(): number {\n        _ensureTurtleExists();\n        // Retorna o ângulo normalizado entre 0 e 360\n        return (_currentHeading % 360 + 360) % 360;\n    }\n\n    //% block=\"position\"\n    //% blockAlias=pos\n    //% group=\"Turtle State\" weight=90\n    export function position(): { x: number, y: number } {\n        _ensureTurtleExists();\n        return { x: Math.round(_turtleX), y: Math.round(_turtleY) };\n    }\n    //% block=\"pos\" group=\"Turtle State\" weight=89 blockHidden=true\n    export function pos(): { x: number, y: number } { return position(); }\n\n    //% block=\"x coordinate\"\n    //% group=\"Turtle State\" weight=80\n    export function xcor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleX);\n    }\n\n    //% block=\"y coordinate\"\n    //% group=\"Turtle State\" weight=70\n    export function ycor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleY);\n    }\n\n    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=60\n    export function showturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = true;\n        _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        _setVisualOrientation();\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=59 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=50\n    export function hideturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = false;\n        _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=49 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=40\n    export function isvisible(): boolean {\n        _ensureTurtleExists();\n        return _isTurtleVisible;\n    }\n\n    // --- Drawing Control ---\n    //% block=\"clear drawings\"\n    //% group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        // Limpa apenas os desenhos, não afeta a tartaruga\n        scene.backgroundImage().fill(scene.backgroundColor());\n    }\n\n    //% block=\"reset turtle\"\n    //% group=\"Drawing Control\" weight=90\n    export function reset(): void {\n        _ensureTurtleExists();\n        if (_turtleSprite) {\n            _turtleSprite.destroy();\n            _turtleSprite = null;\n        }\n        scene.backgroundImage().fill(scene.backgroundColor());\n        _ensureTurtleExists(); // Recria e redefine para os padrões\n        home();\n        pendown();\n        pencolor(1);\n        speed(6);\n        showturtle();\n    }\n\n    // Inicializa a tartaruga automaticamente para que os blocos funcionem sem um \"start\" explícito\n    _ensureTurtleExists();\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749311583671,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"D},(]p^ZMw))Q)Cq]myc\">s1</variable><variable id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"turtle_reset\"><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Red outline</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"turtle_fillcolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Yellow fill</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">14</field></shadow></value><next><block type=\"turtle_shape\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">circle</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Double size, 2px outline</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">100</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"turtle_shape\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">square</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">1x base width, 3x base height</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">3</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">80</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"turtle_clearstamp\"><value name=\"stampId\"><block type=\"variables_get\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><shadow type=\"text\"><field name=\"TEXT\">Hello from Turtle!</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_xcor\"></block></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_ycor\"></block></value><next><block type=\"turtle_write\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Score: 100</field></shadow></value><value name=\"move\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">FALSE</field></shadow></value><value name=\"align\"><shadow type=\"text\"><field name=\"TEXT\">center</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"turtle.reset()\n// Red outline\nturtle.pencolor(2)\n// Yellow fill\nturtle.fillcolor(14)\nturtle.shape(\"circle\")\n// Double size, 2px outline\nturtle.shapesize(2, 2, 2)\nturtle.goto(100, 40)\nlet s1 = turtle.stamp()\nturtle.shape(\"square\")\n// 1x base width, 3x base height\nturtle.shapesize(1, 3, 1)\nturtle.goto(80, 60)\nlet s2 = turtle.stamp()\npause(2000)\nturtle.clearstamp(s1)\npause(1000)\nturtle.print(\"Hello from Turtle!\")\nturtle.print(turtle.xcor())\nturtle.print(turtle.ycor())\nturtle.write(\n\"Score: 100\",\nfalse,\n\"center\"\n)\n","README.md":" ","assets.json":"","turtle.ts":"/**\n * Custom Turtle Graphics Extension\n */\n//% weight=100 color=#00A654 icon=\"\\uf188\" block=\"Turtle\"\n//% groups=['Movement', 'Pen Control', 'Drawing Control', 'Turtle State', 'Stamping', 'Animation', 'Screen Control', 'Utility']\nnamespace turtle {\n\n    // --- State Variables ---\n    let _turtleSprite: Sprite = null;\n    let _turtleX: number = 80;\n    let _turtleY: number = 60;\n    let _currentHeading: number = 0;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1;\n    let _turtleSpeed: number = 6;\n    let _turtleVisible: boolean = true;\n    let _penSize: number = 1;\n\n    enum VisualDirection { Right, Up, Left, Down }\n    let _currentVisualDirection: VisualDirection = VisualDirection.Right;\n    let _turtleIdleFrames: Image[] = [];\n    let _turtleWalkFrames: Image[][] = [];\n    let _turtleAnimState: \"idle\" | \"walk\" = \"idle\";\n    let _currentFrameIndex: number = 0;\n    let _lastAnimTime: number = 0;\n    const ANIM_INTERVAL = 150;\n\n    let _drawingImage: Image = null;\n    let _drawingSprite: Sprite = null;\n\n    let _fillColor: number = 1;\n    let _currentStampShape: string = \"turtle\";\n    let _stampStretchWidth: number = 1;\n    let _stampStretchLength: number = 1;\n    let _stampOutlineWidth: number = 1;\n\n    const STAMP_SPRITE_KIND = SpriteKind.create();\n    let _stamps: Sprite[] = [];\n    let _nextStampId: number = 0;\n\n    let _textFont: image.Font = image.font5;\n    enum TextAnchor { Left, Center, Right }\n\n    const TURTLE_SPRITE_KIND = SpriteKind.create();\n\n    // --- Helper Functions ---\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            if (!_drawingImage) {\n                _drawingImage = image.create(screen.width, screen.height);\n                _drawingImage.fill(0); // Transparent background for drawing layer\n                _drawingSprite = sprites.create(_drawingImage); // Create a normal sprite for the drawing canvas\n                _drawingSprite.z = 0; // Drawings are at base layer, above scene background\n            }\n\n            _turtleSprite = sprites.create(image.create(16, 16), TURTLE_SPRITE_KIND); // Placeholder image\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, false);\n            _turtleSprite.z = 10; // Turtle on top of drawings, stamps, and text\n\n            if (_turtleIdleFrames.length === 0) {\n                _turtleIdleFrames[VisualDirection.Right] = img`\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                `.clone();\n                _turtleIdleFrames[VisualDirection.Up] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Up].flipY();\n                _turtleIdleFrames[VisualDirection.Left] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Left].flipX();\n                _turtleIdleFrames[VisualDirection.Down] = _turtleIdleFrames[VisualDirection.Up].clone();\n                _turtleIdleFrames[VisualDirection.Down].flipY();\n            }\n            if (_turtleWalkFrames.length === 0) {\n                for (let i = 0; i < 4; i++) {\n                    _turtleWalkFrames[i] = [_turtleIdleFrames[i].clone()];\n                }\n            }\n            _updateTurtleImage();\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n        }\n    }\n\n    function _degreesToRadians(degrees: number): number {\n        return degrees * (Math.PI / 180);\n    }\n\n    function _normalizeAngle(degrees: number): number {\n        degrees = degrees % 360;\n        if (degrees < 0) {\n            degrees += 360;\n        }\n        return degrees;\n    }\n\n    function _updateTurtleImage() {\n        if (!_turtleSprite) return;\n        let frames: Image[];\n        if (_turtleAnimState === \"walk\" && _turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 0) {\n            frames = _turtleWalkFrames[_currentVisualDirection];\n        } else if (_turtleIdleFrames[_currentVisualDirection]) {\n            frames = [_turtleIdleFrames[_currentVisualDirection]];\n        } else { return; }\n        if (frames.length > 0) {\n            _currentFrameIndex = _currentFrameIndex % frames.length;\n            _turtleSprite.setImage(frames[_currentFrameIndex]);\n        }\n    }\n\n    function _setVisualOrientation() {\n        if (!_turtleSprite) return;\n        let normalizedHeading = _normalizeAngle(_currentHeading);\n        if (normalizedHeading >= 315 || normalizedHeading < 45) _currentVisualDirection = VisualDirection.Right;\n        else if (normalizedHeading >= 45 && normalizedHeading < 135) _currentVisualDirection = VisualDirection.Up;\n        else if (normalizedHeading >= 135 && normalizedHeading < 225) _currentVisualDirection = VisualDirection.Left;\n        else _currentVisualDirection = VisualDirection.Down;\n        _updateTurtleImage();\n    }\n\n    function _drawLine(x1: number, y1: number, x2: number, y2: number) {\n        if (_isPenDown && _drawingImage) {\n            _drawingImage.drawLine(Math.round(x1), Math.round(y1), Math.round(x2), Math.round(y2), _penColor);\n        }\n    }\n\n    let _targetX: number = _turtleX;\n    let _targetY: number = _turtleY;\n    let _isMoving: boolean = false;\n    let _stepsToTake: number = 0;\n    let _stepAngleRad: number = 0;\n    let _movePerFrame: number = 1;\n\n    game.onUpdate(function () {\n        if (!_turtleSprite) return;\n        if (game.runtime() - _lastAnimTime > ANIM_INTERVAL) {\n            if (_turtleAnimState === \"walk\" || (_turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 1)) {\n                _currentFrameIndex++;\n            }\n            _updateTurtleImage();\n            _lastAnimTime = game.runtime();\n        }\n        if (_isMoving && _stepsToTake > 0) {\n            _turtleAnimState = \"walk\";\n            let moveDistance = Math.min(_stepsToTake, _movePerFrame);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n            _turtleX += moveDistance * Math.cos(_stepAngleRad);\n            _turtleY -= moveDistance * Math.sin(_stepAngleRad);\n            _drawLine(prevX, prevY, _turtleX, _turtleY);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _stepsToTake -= moveDistance;\n            if (_stepsToTake <= 0.1) {\n                _stepsToTake = 0;\n                _isMoving = false;\n                _turtleX = _targetX;\n                _turtleY = _targetY;\n                _drawLine(prevX, prevY, _turtleX, _turtleY);\n                _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n                _turtleAnimState = \"idle\";\n                _updateTurtleImage();\n            }\n        } else if (_isMoving) {\n            _isMoving = false;\n            _turtleAnimState = \"idle\";\n            _updateTurtleImage();\n        }\n    });\n\n    // --- Custom print function ---\n    //% block=\"print %content\"\n    //% text.shadowOptions.toString=true\n    //% group=\"Utility\" weight=100\n    export function print(content: any): void {\n        console.log(content);\n    }\n\n    // --- Screen Control ---\n    //% block=\"background color %color=colorindexpicker\"\n    //% group=\"Screen Control\" weight=90\n    export function bgcolor(color: number): void {\n        scene.setBackgroundColor(color);\n    }\n\n    // --- Core Turtle API ---\n    //% block=\"reset\"\n    //% group=\"Turtle State\" weight=100\n    export function reset(): void {\n        _ensureTurtleExists();\n        _turtleX = screen.width / 2; _targetX = _turtleX;\n        _turtleY = screen.height / 2; _targetY = _turtleY;\n        _currentHeading = 0; _isPenDown = true; _penColor = 1;\n        _fillColor = 1; _turtleSpeed = 6; _turtleVisible = true;\n        _penSize = 1; _currentStampShape = \"turtle\";\n        _stampStretchWidth = 1; _stampStretchLength = 1; _stampOutlineWidth = 1;\n        _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n        _setVisualOrientation(); _turtleAnimState = \"idle\"; _updateTurtleImage();\n        if (_drawingImage) _drawingImage.fill(0);\n        for (let s of _stamps) s.destroy();\n        _stamps = []; _nextStampId = 0;\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"speed %speed\"\n    //% speed.min=0 speed.max=10 speed.defl=6\n    //% group=\"Turtle State\" weight=90\n    export function speed(s: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, s);\n        _movePerFrame = (_turtleSpeed === 0) ? 1000 : Math.max(1, _turtleSpeed / 2);\n    }\n\n    function _moveTurtle(distance: number): void {\n        _ensureTurtleExists();\n        _turtleAnimState = \"walk\"; _updateTurtleImage();\n        const startX = _turtleX, startY = _turtleY;\n        _stepAngleRad = _degreesToRadians(_currentHeading);\n        _targetX = startX + distance * Math.cos(_stepAngleRad);\n        _targetY = startY - distance * Math.sin(_stepAngleRad);\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleAnimState = \"idle\"; _updateTurtleImage();\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            _stepsToTake = Math.abs(distance); _isMoving = true;\n        }\n    }\n\n    //% block=\"forward %distance\" alias=fd\n    //% distance.defl=20 group=\"Movement\" weight=100\n    export function forward(distance: number): void { _moveTurtle(distance); }\n    //% block=\"fd %distance\" group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance\" alias=bk alias=back\n    //% distance.defl=20 group=\"Movement\" weight=90\n    export function backward(distance: number): void { _moveTurtle(-distance); }\n    //% block=\"bk %distance\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n    //% block=\"left %angle degrees\" alias=lt\n    //% angle.defl=90 group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists(); _currentHeading += angle; _setVisualOrientation();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\" alias=rt\n    //% angle.defl=90 group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists(); _currentHeading -= angle; _setVisualOrientation();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"pen up\" alias=pu alias=up\n    //% group=\"Pen Control\" weight=100\n    export function penup(): void { _ensureTurtleExists(); _isPenDown = false; }\n    //% block=\"pu\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen down\" alias=pd alias=down\n    //% group=\"Pen Control\" weight=90\n    export function pendown(): void { _ensureTurtleExists(); _isPenDown = true; }\n    //% block=\"pd\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"is pen down?\" group=\"Pen Control\" weight=60\n    export function isdown(): boolean { _ensureTurtleExists(); return _isPenDown; }\n\n    //% block=\"pen color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void { _ensureTurtleExists(); _penColor = color; }\n\n    //% block=\"fill color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=75\n    export function fillcolor(color: number): void { _ensureTurtleExists(); _fillColor = color; }\n\n    //% block=\"pen size %size\" alias=width\n    //% size.min=1 size.max=100 size.defl=1 group=\"Pen Control\" weight=70\n    export function pensize(size: number): void { _ensureTurtleExists(); _penSize = Math.max(1, size); }\n    //% block=\"width %size\" group=\"Pen Control\" weight=69 blockHidden=true\n    export function width(size: number): void { pensize(size); }\n\n    //% block=\"hide turtle\" alias=ht group=\"Turtle State\" weight=80\n    export function hideturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = false;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=79 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"show turtle\" alias=st group=\"Turtle State\" weight=70\n    export function showturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = true;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=69 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"is turtle visible?\" group=\"Turtle State\" weight=60\n    export function isvisible(): boolean { _ensureTurtleExists(); return _turtleVisible; }\n\n    //% block=\"set heading %angle degrees\" alias=seth\n    //% angle.defl=0 group=\"Movement\" weight=60\n    export function setheading(angle: number): void {\n        _ensureTurtleExists(); _currentHeading = angle; _setVisualOrientation();\n    }\n    //% block=\"seth %angle degrees\" group=\"Movement\" weight=59 blockHidden=true\n    export function seth(angle: number): void { setheading(angle); }\n\n    //% block=\"heading\" group=\"Turtle State\" weight=50\n    export function heading(): number { _ensureTurtleExists(); return _normalizeAngle(_currentHeading); }\n\n    //% block=\"go to x %x y %y\" alias=setpos alias=setposition\n    //% x.defl=80 y.defl=60 group=\"Movement\" weight=50\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        const startX = _turtleX, startY = _turtleY;\n        _targetX = x; _targetY = y;\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            const dx = _targetX - startX, dy = _targetY - startY;\n            _stepsToTake = Math.sqrt(dx * dx + dy * dy);\n            if (_stepsToTake < 0.1) { _isMoving = false; _stepsToTake = 0; return; }\n            _stepAngleRad = Math.atan2(-dy, dx); _isMoving = true;\n        }\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=49 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=48 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n    //% block=\"home\" group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists(); goto(screen.width / 2, screen.height / 2); setheading(0);\n    }\n\n    //% block=\"x coordinate\" group=\"Turtle State\" weight=40\n    export function xcor(): number { _ensureTurtleExists(); return _turtleX; }\n\n    //% block=\"y coordinate\" group=\"Turtle State\" weight=39\n    export function ycor(): number { _ensureTurtleExists(); return _turtleY; }\n\n    //% block=\"position\" group=\"Turtle State\" weight=38\n    export function position(): { x: number, y: number } { _ensureTurtleExists(); return { x: _turtleX, y: _turtleY }; }\n\n    //% block=\"set x %x\" group=\"Movement\" weight=35\n    export function setx(x: number): void {\n        _ensureTurtleExists(); _turtleX = x; _targetX = x;\n        _turtleSprite.x = Math.round(_turtleX);\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"set y %y\" group=\"Movement\" weight=34\n    export function sety(y: number): void {\n        _ensureTurtleExists(); _turtleY = y; _targetY = y;\n        _turtleSprite.y = Math.round(_turtleY);\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"distance to x %x y %y\" group=\"Turtle State\" weight=30\n    export function distance(x: number, y: number): number {\n        _ensureTurtleExists(); const dx = _turtleX - x, dy = _turtleY - y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    //% block=\"clear drawings\" group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        _ensureTurtleExists(); if (_drawingImage) _drawingImage.fill(0);\n    }\n\n    //% block=\"shape %name\"\n    //% name.options.defl=\"turtle\" name.options.enumValues=\"turtle,circle,square,arrow,triangle,classic\"\n    //% group=\"Stamping\" weight=100\n    export function shape(name: string): void {\n        _ensureTurtleExists(); let l = name.toLowerCase();\n        if ([\"turtle\", \"circle\", \"square\", \"arrow\", \"triangle\", \"classic\"].indexOf(l) > -1) _currentStampShape = l;\n        else { console.warn(\"Turtle: Unknown shape '\" + name + \"'. Defaulting to 'turtle'.\"); _currentStampShape = \"turtle\"; }\n    }\n\n    //% block=\"shape size width %sWidth || length %sLength outline %sOutline\"\n    //% sWidth.defl=1 sLength.defl=1 sOutline.defl=1 inlineInputMode=inline group=\"Stamping\" weight=90\n    export function shapesize(sW: number, sL?: number, sO?: number): void {\n        _ensureTurtleExists(); _stampStretchWidth = Math.max(0.1, sW);\n        _stampStretchLength = (sL === undefined || sL < 0.1) ? _stampStretchWidth : Math.max(0.1, sL);\n        _stampOutlineWidth = (sO === undefined || sO < 0) ? 1 : Math.max(0, sO);\n    }\n\n    //% block=\"stamp\" group=\"Stamping\" weight=80\n    export function stamp(): number {\n        _ensureTurtleExists(); let stampImage: Image; const BASE = 12;\n        let w = Math.round(BASE * _stampStretchWidth), h = Math.round(BASE * _stampStretchLength);\n        if (_currentStampShape === \"circle\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - 1, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _penColor);\n            }\n            stampImage.fillCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _fillColor);\n        } else if (_currentStampShape === \"square\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawRect(0, 0, w, h, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawRect(_stampOutlineWidth - 1, _stampOutlineWidth - 1, w - 2 * (_stampOutlineWidth - 1), h - 2 * (_stampOutlineWidth - 1), _penColor);\n            }\n            stampImage.fillRect(_stampOutlineWidth, _stampOutlineWidth, w - 2 * _stampOutlineWidth, h - 2 * _stampOutlineWidth, _fillColor);\n        } else {\n            let base = _turtleIdleFrames[_currentVisualDirection] || _turtleIdleFrames[0] || img`1`;\n            stampImage = base.clone();\n        }\n        let stampSprite = sprites.create(stampImage, STAMP_SPRITE_KIND);\n        stampSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        stampSprite.setFlag(SpriteFlag.Ghost, true);\n        stampSprite.z = _drawingSprite.z + 1; // Stamps above drawings\n        _nextStampId++; stampSprite.data[\"stampId\"] = _nextStampId;\n        _stamps.push(stampSprite); return _nextStampId;\n    }\n\n    //% block=\"clear stamp id %stampId\" group=\"Stamping\" weight=70\n    export function clearstamp(stampId: number): void {\n        _ensureTurtleExists();\n        for (let i = _stamps.length - 1; i >= 0; i--) {\n            if (_stamps[i].data[\"stampId\"] === stampId) {\n                _stamps[i].destroy(); _stamps.splice(i, 1); return;\n            }\n        }\n    }\n\n    //% block=\"write text %text || move %move align %align font size %fontSize\"\n    //% text.shadowOptions.toString=true move.defl=false align.defl=\"left\"\n    //% fontSize.min=5 fontSize.max=12 fontSize.defl=5 group=\"Drawing Control\" weight=70\n    export function write(text: string, move?: boolean, align?: string, fontSize?: number): void {\n        _ensureTurtleExists(); let font = image.font5;\n        if (fontSize === 8) font = image.font8;\n        else if (fontSize === 12) font = image.font12;\n        else if (fontSize && fontSize !== 5) font = image.scaledFont(image.font5, fontSize / 5);\n        let tw = text.length * font.charWidth, th = font.charHeight;\n        let pad = Math.ceil(font.charWidth / 2);\n        let img = image.create(tw + pad, th + pad); img.fill(0);\n        img.print(text, Math.floor(pad / 2), Math.floor(pad / 2), _penColor, font);\n        let textSprite = sprites.create(img, STAMP_SPRITE_KIND);\n        textSprite.setFlag(SpriteFlag.Ghost, true);\n        textSprite.z = _drawingSprite.z + 2; // Text above stamps\n        let sx = Math.round(_turtleX), sy = Math.round(_turtleY);\n        let alignStr = (align || \"left\").toLowerCase();\n        if (alignStr === \"center\") sx = Math.round(_turtleX);\n        else if (alignStr === \"right\") sx = Math.round(_turtleX - tw / 2);\n        else sx = Math.round(_turtleX + tw / 2);\n        sy = Math.round(_turtleY + th / 2);\n        textSprite.setPosition(sx, sy);\n        if (move) {\n            const md = tw, ma = _degreesToRadians(_currentHeading);\n            _turtleX += md * Math.cos(ma); _turtleY -= md * Math.sin(ma);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _targetX = _turtleX; _targetY = _turtleY;\n        }\n    }\n\n    //% block=\"set turtle idle image for %direction to %img=screen_image_picker\"\n    //% group=\"Animation\" weight=60\n    export function setTurtleImage(direction: VisualDirection, img: Image): void {\n        _ensureTurtleExists(); if (!img) return;\n        _turtleIdleFrames[direction] = img;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"idle\") _updateTurtleImage();\n    }\n\n    //% block=\"set turtle walk animation for %direction to %anim=animation_editor\"\n    //% group=\"Animation\" weight=50\n    export function setTurtleAnimation(direction: VisualDirection, anim: Image[]): void {\n        _ensureTurtleExists(); if (!anim || anim.length === 0) return;\n        _turtleWalkFrames[direction] = anim;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"walk\") {\n            _currentFrameIndex = 0; _updateTurtleImage();\n        }\n    }\n    reset(); // Initialize on load\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749316901934,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"D},(]p^ZMw))Q)Cq]myc\">s1</variable><variable id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"turtle_reset\"><next><block type=\"turtle_pencolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Red outline</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">2</field></shadow></value><next><block type=\"turtle_fillcolor\"><comment pinned=\"false\" h=\"80\" w=\"160\">Yellow fill</comment><value name=\"color\"><shadow type=\"colorindexpicker\"><field name=\"index\">14</field></shadow></value><next><block type=\"turtle_shape\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">circle</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Double size, 2px outline</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">2</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">100</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"turtle_shape\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">square</field></shadow></value><next><block type=\"turtle_shapesize\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">1x base width, 3x base height</comment><value name=\"sWidth\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><value name=\"sLength\"><shadow type=\"math_number\"><field name=\"NUM\">3</field></shadow></value><value name=\"sOutline\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value><next><block type=\"turtle_goto\"><data>{\"commentRefs\":[],\"fieldData\":{}}</data><value name=\"x\"><shadow type=\"math_number\"><field name=\"NUM\">80</field></shadow></value><value name=\"y\"><shadow type=\"math_number\"><field name=\"NUM\">60</field></shadow></value><next><block type=\"variables_set\"><field name=\"VAR\" id=\"+BdN)ZruuK4TyJ%%}mf^\">s2</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"turtle_stamp\"></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"turtle_clearstamp\"><value name=\"stampId\"><block type=\"variables_get\"><field name=\"VAR\" id=\"D},(]p^ZMw))Q)Cq]myc\">s1</field></block></value><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><shadow type=\"text\"><field name=\"TEXT\">Hello from Turtle!</field></shadow></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_xcor\"></block></value><next><block type=\"turtle_print\"><value name=\"content\"><block type=\"turtle_ycor\"></block></value><next><block type=\"turtle_write\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"2\" _input_init=\"true\"></mutation><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Score: 100</field></shadow></value><value name=\"move\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">FALSE</field></shadow></value><value name=\"align\"><shadow type=\"text\"><field name=\"TEXT\">center</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"turtle.reset()\n// Red outline\nturtle.pencolor(2)\n// Yellow fill\nturtle.fillcolor(14)\nturtle.shape(\"circle\")\n// Double size, 2px outline\nturtle.shapesize(2, 2, 2)\nturtle.goto(100, 40)\nlet s1 = turtle.stamp()\nturtle.shape(\"square\")\n// 1x base width, 3x base height\nturtle.shapesize(1, 3, 1)\nturtle.goto(80, 60)\nlet s2 = turtle.stamp()\npause(2000)\nturtle.clearstamp(s1)\npause(1000)\nturtle.print(\"Hello from Turtle!\")\nturtle.print(turtle.xcor())\nturtle.print(turtle.ycor())\nturtle.write(\n\"Score: 100\",\nfalse,\n\"center\"\n)\n","README.md":" ","assets.json":"","turtle.ts":"/**\n * Custom Turtle Graphics Extension\n */\n//% weight=100 color=#00A654 icon=\"\\uf188\" block=\"Turtle\"\n//% groups=['Movement', 'Pen Control', 'Drawing Control', 'Turtle State', 'Stamping', 'Animation', 'Screen Control', 'Utility']\nnamespace turtle {\n\n    // --- State Variables ---\n    let _turtleSprite: Sprite = null;\n    let _turtleX: number = 80;\n    let _turtleY: number = 60;\n    let _currentHeading: number = 0;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1;\n    let _turtleSpeed: number = 6;\n    let _turtleVisible: boolean = true;\n    let _penSize: number = 1;\n\n    enum VisualDirection { Right, Up, Left, Down }\n    let _currentVisualDirection: VisualDirection = VisualDirection.Right;\n    let _turtleIdleFrames: Image[] = [];\n    let _turtleWalkFrames: Image[][] = [];\n    let _turtleAnimState: \"idle\" | \"walk\" = \"idle\";\n    let _currentFrameIndex: number = 0;\n    let _lastAnimTime: number = 0;\n    const ANIM_INTERVAL = 150;\n\n    let _drawingImage: Image = null;\n    let _drawingSprite: Sprite = null;\n\n    let _fillColor: number = 1;\n    let _currentStampShape: string = \"turtle\";\n    let _stampStretchWidth: number = 1;\n    let _stampStretchLength: number = 1;\n    let _stampOutlineWidth: number = 1;\n\n    const STAMP_SPRITE_KIND = SpriteKind.create();\n    let _stamps: Sprite[] = [];\n    let _nextStampId: number = 0;\n\n    let _textFont: image.Font = image.font5;\n    enum TextAnchor { Left, Center, Right }\n\n    const TURTLE_SPRITE_KIND = SpriteKind.create();\n\n    // --- Helper Functions ---\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            if (!_drawingImage) {\n                _drawingImage = image.create(screen.width, screen.height);\n                _drawingImage.fill(0); // Transparent background for drawing layer\n                _drawingSprite = sprites.create(_drawingImage); // Create a normal sprite for the drawing canvas\n                _drawingSprite.z = 0; // Drawings are at base layer, above scene background\n            }\n\n            _turtleSprite = sprites.create(image.create(16, 16), TURTLE_SPRITE_KIND); // Placeholder image\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, false);\n            _turtleSprite.z = 10; // Turtle on top of drawings, stamps, and text\n\n            if (_turtleIdleFrames.length === 0) {\n                _turtleIdleFrames[VisualDirection.Right] = img`\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 1 1 1 9 f . . . . . . .\n                    . . . f 9 1 1 9 f . . . . . . .\n                    . . . . f 9 9 f f . . . . . . .\n                    . . . . . f f f . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                    . . . . . . . . . . . . . . . .\n                `.clone();\n                _turtleIdleFrames[VisualDirection.Up] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Up].flipY();\n                _turtleIdleFrames[VisualDirection.Left] = _turtleIdleFrames[VisualDirection.Right].clone();\n                _turtleIdleFrames[VisualDirection.Left].flipX();\n                _turtleIdleFrames[VisualDirection.Down] = _turtleIdleFrames[VisualDirection.Up].clone();\n                _turtleIdleFrames[VisualDirection.Down].flipY();\n            }\n            if (_turtleWalkFrames.length === 0) {\n                for (let i = 0; i < 4; i++) {\n                    _turtleWalkFrames[i] = [_turtleIdleFrames[i].clone()];\n                }\n            }\n            _updateTurtleImage();\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n        }\n    }\n\n    function _degreesToRadians(degrees: number): number {\n        return degrees * (Math.PI / 180);\n    }\n\n    function _normalizeAngle(degrees: number): number {\n        degrees = degrees % 360;\n        if (degrees < 0) {\n            degrees += 360;\n        }\n        return degrees;\n    }\n\n    function _updateTurtleImage() {\n        if (!_turtleSprite) return;\n        let frames: Image[];\n        if (_turtleAnimState === \"walk\" && _turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 0) {\n            frames = _turtleWalkFrames[_currentVisualDirection];\n        } else if (_turtleIdleFrames[_currentVisualDirection]) {\n            frames = [_turtleIdleFrames[_currentVisualDirection]];\n        } else { return; }\n        if (frames.length > 0) {\n            _currentFrameIndex = _currentFrameIndex % frames.length;\n            _turtleSprite.setImage(frames[_currentFrameIndex]);\n        }\n    }\n\n    function _setVisualOrientation() {\n        if (!_turtleSprite) return;\n        let normalizedHeading = _normalizeAngle(_currentHeading);\n        if (normalizedHeading >= 315 || normalizedHeading < 45) _currentVisualDirection = VisualDirection.Right;\n        else if (normalizedHeading >= 45 && normalizedHeading < 135) _currentVisualDirection = VisualDirection.Up;\n        else if (normalizedHeading >= 135 && normalizedHeading < 225) _currentVisualDirection = VisualDirection.Left;\n        else _currentVisualDirection = VisualDirection.Down;\n        _updateTurtleImage();\n    }\n\n    function _drawLine(x1: number, y1: number, x2: number, y2: number) {\n        if (_isPenDown && _drawingImage) {\n            _drawingImage.drawLine(Math.round(x1), Math.round(y1), Math.round(x2), Math.round(y2), _penColor);\n        }\n    }\n\n    let _targetX: number = _turtleX;\n    let _targetY: number = _turtleY;\n    let _isMoving: boolean = false;\n    let _stepsToTake: number = 0;\n    let _stepAngleRad: number = 0;\n    let _movePerFrame: number = 1;\n\n    game.onUpdate(function () {\n        if (!_turtleSprite) return;\n        if (game.runtime() - _lastAnimTime > ANIM_INTERVAL) {\n            if (_turtleAnimState === \"walk\" || (_turtleWalkFrames[_currentVisualDirection] && _turtleWalkFrames[_currentVisualDirection].length > 1)) {\n                _currentFrameIndex++;\n            }\n            _updateTurtleImage();\n            _lastAnimTime = game.runtime();\n        }\n        if (_isMoving && _stepsToTake > 0) {\n            _turtleAnimState = \"walk\";\n            let moveDistance = Math.min(_stepsToTake, _movePerFrame);\n            const prevX = _turtleX;\n            const prevY = _turtleY;\n            _turtleX += moveDistance * Math.cos(_stepAngleRad);\n            _turtleY -= moveDistance * Math.sin(_stepAngleRad);\n            _drawLine(prevX, prevY, _turtleX, _turtleY);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _stepsToTake -= moveDistance;\n            if (_stepsToTake <= 0.1) {\n                _stepsToTake = 0;\n                _isMoving = false;\n                _turtleX = _targetX;\n                _turtleY = _targetY;\n                _drawLine(prevX, prevY, _turtleX, _turtleY);\n                _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n                _turtleAnimState = \"idle\";\n                _updateTurtleImage();\n            }\n        } else if (_isMoving) {\n            _isMoving = false;\n            _turtleAnimState = \"idle\";\n            _updateTurtleImage();\n        }\n    });\n\n    // --- Custom print function ---\n    //% block=\"print %content\"\n    //% text.shadowOptions.toString=true\n    //% group=\"Utility\" weight=100\n    export function print(content: any): void {\n        console.log(content);\n    }\n\n    // --- Screen Control ---\n    //% block=\"background color %color=colorindexpicker\"\n    //% group=\"Screen Control\" weight=90\n    export function bgcolor(color: number): void {\n        scene.setBackgroundColor(color);\n    }\n\n    // --- Core Turtle API ---\n    //% block=\"reset\"\n    //% group=\"Turtle State\" weight=100\n    export function reset(): void {\n        _ensureTurtleExists();\n        _turtleX = screen.width / 2; _targetX = _turtleX;\n        _turtleY = screen.height / 2; _targetY = _turtleY;\n        _currentHeading = 0; _isPenDown = true; _penColor = 1;\n        _fillColor = 1; _turtleSpeed = 6; _turtleVisible = true;\n        _penSize = 1; _currentStampShape = \"turtle\";\n        _stampStretchWidth = 1; _stampStretchLength = 1; _stampOutlineWidth = 1;\n        _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        _turtleSprite.setFlag(SpriteFlag.Invisible, !_turtleVisible);\n        _setVisualOrientation(); _turtleAnimState = \"idle\"; _updateTurtleImage();\n        if (_drawingImage) _drawingImage.fill(0);\n        for (let s of _stamps) s.destroy();\n        _stamps = []; _nextStampId = 0;\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"speed %speed\"\n    //% speed.min=0 speed.max=10 speed.defl=6\n    //% group=\"Turtle State\" weight=90\n    export function speed(s: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, s);\n        _movePerFrame = (_turtleSpeed === 0) ? 1000 : Math.max(1, _turtleSpeed / 2);\n    }\n\n    function _moveTurtle(distance: number): void {\n        _ensureTurtleExists();\n        _turtleAnimState = \"walk\"; _updateTurtleImage();\n        const startX = _turtleX, startY = _turtleY;\n        _stepAngleRad = _degreesToRadians(_currentHeading);\n        _targetX = startX + distance * Math.cos(_stepAngleRad);\n        _targetY = startY - distance * Math.sin(_stepAngleRad);\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _turtleAnimState = \"idle\"; _updateTurtleImage();\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            _stepsToTake = Math.abs(distance); _isMoving = true;\n        }\n    }\n\n    //% block=\"forward %distance\" alias=fd\n    //% distance.defl=20 group=\"Movement\" weight=100\n    export function forward(distance: number): void { _moveTurtle(distance); }\n    //% block=\"fd %distance\" group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance\" alias=bk alias=back\n    //% distance.defl=20 group=\"Movement\" weight=90\n    export function backward(distance: number): void { _moveTurtle(-distance); }\n    //% block=\"bk %distance\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n    //% block=\"left %angle degrees\" alias=lt\n    //% angle.defl=90 group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists(); _currentHeading += angle; _setVisualOrientation();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\" alias=rt\n    //% angle.defl=90 group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists(); _currentHeading -= angle; _setVisualOrientation();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"pen up\" alias=pu alias=up\n    //% group=\"Pen Control\" weight=100\n    export function penup(): void { _ensureTurtleExists(); _isPenDown = false; }\n    //% block=\"pu\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen down\" alias=pd alias=down\n    //% group=\"Pen Control\" weight=90\n    export function pendown(): void { _ensureTurtleExists(); _isPenDown = true; }\n    //% block=\"pd\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"is pen down?\" group=\"Pen Control\" weight=60\n    export function isdown(): boolean { _ensureTurtleExists(); return _isPenDown; }\n\n    //% block=\"pen color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void { _ensureTurtleExists(); _penColor = color; }\n\n    //% block=\"fill color %color=colorindexpicker\" color.defl=1 group=\"Pen Control\" weight=75\n    export function fillcolor(color: number): void { _ensureTurtleExists(); _fillColor = color; }\n\n    //% block=\"pen size %size\" alias=width\n    //% size.min=1 size.max=100 size.defl=1 group=\"Pen Control\" weight=70\n    export function pensize(size: number): void { _ensureTurtleExists(); _penSize = Math.max(1, size); }\n    //% block=\"width %size\" group=\"Pen Control\" weight=69 blockHidden=true\n    export function width(size: number): void { pensize(size); }\n\n    //% block=\"hide turtle\" alias=ht group=\"Turtle State\" weight=80\n    export function hideturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = false;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=79 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"show turtle\" alias=st group=\"Turtle State\" weight=70\n    export function showturtle(): void {\n        _ensureTurtleExists(); _turtleVisible = true;\n        if (_turtleSprite) _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=69 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"is turtle visible?\" group=\"Turtle State\" weight=60\n    export function isvisible(): boolean { _ensureTurtleExists(); return _turtleVisible; }\n\n    //% block=\"set heading %angle degrees\" alias=seth\n    //% angle.defl=0 group=\"Movement\" weight=60\n    export function setheading(angle: number): void {\n        _ensureTurtleExists(); _currentHeading = angle; _setVisualOrientation();\n    }\n    //% block=\"seth %angle degrees\" group=\"Movement\" weight=59 blockHidden=true\n    export function seth(angle: number): void { setheading(angle); }\n\n    //% block=\"heading\" group=\"Turtle State\" weight=50\n    export function heading(): number { _ensureTurtleExists(); return _normalizeAngle(_currentHeading); }\n\n    //% block=\"go to x %x y %y\" alias=setpos alias=setposition\n    //% x.defl=80 y.defl=60 group=\"Movement\" weight=50\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        const startX = _turtleX, startY = _turtleY;\n        _targetX = x; _targetY = y;\n        if (_turtleSpeed === 0) {\n            _drawLine(startX, startY, _targetX, _targetY);\n            _turtleX = _targetX; _turtleY = _targetY;\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _isMoving = false; _stepsToTake = 0;\n        } else {\n            const dx = _targetX - startX, dy = _targetY - startY;\n            _stepsToTake = Math.sqrt(dx * dx + dy * dy);\n            if (_stepsToTake < 0.1) { _isMoving = false; _stepsToTake = 0; return; }\n            _stepAngleRad = Math.atan2(-dy, dx); _isMoving = true;\n        }\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=49 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=48 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n    //% block=\"home\" group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists(); goto(screen.width / 2, screen.height / 2); setheading(0);\n    }\n\n    //% block=\"x coordinate\" group=\"Turtle State\" weight=40\n    export function xcor(): number { _ensureTurtleExists(); return _turtleX; }\n\n    //% block=\"y coordinate\" group=\"Turtle State\" weight=39\n    export function ycor(): number { _ensureTurtleExists(); return _turtleY; }\n\n    //% block=\"position\" group=\"Turtle State\" weight=38\n    export function position(): { x: number, y: number } { _ensureTurtleExists(); return { x: _turtleX, y: _turtleY }; }\n\n    //% block=\"set x %x\" group=\"Movement\" weight=35\n    export function setx(x: number): void {\n        _ensureTurtleExists(); _turtleX = x; _targetX = x;\n        _turtleSprite.x = Math.round(_turtleX);\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"set y %y\" group=\"Movement\" weight=34\n    export function sety(y: number): void {\n        _ensureTurtleExists(); _turtleY = y; _targetY = y;\n        _turtleSprite.y = Math.round(_turtleY);\n        _isMoving = false; _stepsToTake = 0;\n    }\n\n    //% block=\"distance to x %x y %y\" group=\"Turtle State\" weight=30\n    export function distance(x: number, y: number): number {\n        _ensureTurtleExists(); const dx = _turtleX - x, dy = _turtleY - y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    //% block=\"clear drawings\" group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        _ensureTurtleExists(); if (_drawingImage) _drawingImage.fill(0);\n    }\n\n    //% block=\"shape %name\"\n    //% name.options.defl=\"turtle\" name.options.enumValues=\"turtle,circle,square,arrow,triangle,classic\"\n    //% group=\"Stamping\" weight=100\n    export function shape(name: string): void {\n        _ensureTurtleExists(); let l = name.toLowerCase();\n        if ([\"turtle\", \"circle\", \"square\", \"arrow\", \"triangle\", \"classic\"].indexOf(l) > -1) _currentStampShape = l;\n        else { console.warn(\"Turtle: Unknown shape '\" + name + \"'. Defaulting to 'turtle'.\"); _currentStampShape = \"turtle\"; }\n    }\n\n    //% block=\"shape size width %sWidth || length %sLength outline %sOutline\"\n    //% sWidth.defl=1 sLength.defl=1 sOutline.defl=1 inlineInputMode=inline group=\"Stamping\" weight=90\n    export function shapesize(sW: number, sL?: number, sO?: number): void {\n        _ensureTurtleExists(); _stampStretchWidth = Math.max(0.1, sW);\n        _stampStretchLength = (sL === undefined || sL < 0.1) ? _stampStretchWidth : Math.max(0.1, sL);\n        _stampOutlineWidth = (sO === undefined || sO < 0) ? 1 : Math.max(0, sO);\n    }\n\n    //% block=\"stamp\" group=\"Stamping\" weight=80\n    export function stamp(): number {\n        _ensureTurtleExists(); let stampImage: Image; const BASE = 12;\n        let w = Math.round(BASE * _stampStretchWidth), h = Math.round(BASE * _stampStretchLength);\n        if (_currentStampShape === \"circle\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - 1, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _penColor);\n            }\n            stampImage.fillCircle(w / 2, h / 2, Math.min(w, h) / 2 - _stampOutlineWidth, _fillColor);\n        } else if (_currentStampShape === \"square\") {\n            stampImage = image.create(w, h); stampImage.fill(0);\n            if (_stampOutlineWidth > 0) {\n                stampImage.drawRect(0, 0, w, h, _penColor);\n                if (_stampOutlineWidth > 1) stampImage.drawRect(_stampOutlineWidth - 1, _stampOutlineWidth - 1, w - 2 * (_stampOutlineWidth - 1), h - 2 * (_stampOutlineWidth - 1), _penColor);\n            }\n            stampImage.fillRect(_stampOutlineWidth, _stampOutlineWidth, w - 2 * _stampOutlineWidth, h - 2 * _stampOutlineWidth, _fillColor);\n        } else {\n            let base = _turtleIdleFrames[_currentVisualDirection] || _turtleIdleFrames[0] || img`1`;\n            stampImage = base.clone();\n        }\n        let stampSprite = sprites.create(stampImage, STAMP_SPRITE_KIND);\n        stampSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n        stampSprite.setFlag(SpriteFlag.Ghost, true);\n        stampSprite.z = _drawingSprite.z + 1; // Stamps above drawings\n        _nextStampId++; stampSprite.data[\"stampId\"] = _nextStampId;\n        _stamps.push(stampSprite); return _nextStampId;\n    }\n\n    //% block=\"clear stamp id %stampId\" group=\"Stamping\" weight=70\n    export function clearstamp(stampId: number): void {\n        _ensureTurtleExists();\n        for (let i = _stamps.length - 1; i >= 0; i--) {\n            if (_stamps[i].data[\"stampId\"] === stampId) {\n                _stamps[i].destroy(); _stamps.splice(i, 1); return;\n            }\n        }\n    }\n\n    //% block=\"write text %text || move %move align %align font size %fontSize\"\n    //% text.shadowOptions.toString=true move.defl=false align.defl=\"left\"\n    //% fontSize.min=5 fontSize.max=12 fontSize.defl=5 group=\"Drawing Control\" weight=70\n    export function write(text: string, move?: boolean, align?: string, fontSize?: number): void {\n        _ensureTurtleExists(); let font = image.font5;\n        if (fontSize === 8) font = image.font8;\n        else if (fontSize === 12) font = image.font12;\n        else if (fontSize && fontSize !== 5) font = image.scaledFont(image.font5, fontSize / 5);\n        let tw = text.length * font.charWidth, th = font.charHeight;\n        let pad = Math.ceil(font.charWidth / 2);\n        let img = image.create(tw + pad, th + pad); img.fill(0);\n        img.print(text, Math.floor(pad / 2), Math.floor(pad / 2), _penColor, font);\n        let textSprite = sprites.create(img, STAMP_SPRITE_KIND);\n        textSprite.setFlag(SpriteFlag.Ghost, true);\n        textSprite.z = _drawingSprite.z + 2; // Text above stamps\n        let sx = Math.round(_turtleX), sy = Math.round(_turtleY);\n        let alignStr = (align || \"left\").toLowerCase();\n        if (alignStr === \"center\") sx = Math.round(_turtleX);\n        else if (alignStr === \"right\") sx = Math.round(_turtleX - tw / 2);\n        else sx = Math.round(_turtleX + tw / 2);\n        sy = Math.round(_turtleY + th / 2);\n        textSprite.setPosition(sx, sy);\n        if (move) {\n            const md = tw, ma = _degreesToRadians(_currentHeading);\n            _turtleX += md * Math.cos(ma); _turtleY -= md * Math.sin(ma);\n            _turtleSprite.setPosition(Math.round(_turtleX), Math.round(_turtleY));\n            _targetX = _turtleX; _targetY = _turtleY;\n        }\n    }\n\n    //% block=\"set turtle idle image for %direction to %img=screen_image_picker\"\n    //% group=\"Animation\" weight=60\n    export function setTurtleImage(direction: VisualDirection, img: Image): void {\n        _ensureTurtleExists(); if (!img) return;\n        _turtleIdleFrames[direction] = img;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"idle\") _updateTurtleImage();\n    }\n\n    //% block=\"set turtle walk animation for %direction to %anim=animation_editor\"\n    //% group=\"Animation\" weight=50\n    export function setTurtleAnimation(direction: VisualDirection, anim: Image[]): void {\n        _ensureTurtleExists(); if (!anim || anim.length === 0) return;\n        _turtleWalkFrames[direction] = anim;\n        if (_currentVisualDirection === direction && _turtleAnimState === \"walk\") {\n            _currentFrameIndex = 0; _updateTurtleImage();\n        }\n    }\n    reset(); // Initialize on load\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749318705633,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"36\" y=\"52\"></block></xml>","main.ts":"\n// Código de Teste para a Extensão Turtle\n// Coloque este código no seu main.ts\n\n// --- Início dos Testes ---\ngame.splash(\"Iniciando Testes da Turtle...\")\npause(1000)\n\n// 1. Setup Inicial e Quadrado\nturtle.reset()\nturtle.speed(6) // Velocidade média para observação\ngame.splash(\"Teste 1: Quadrado Vermelho\")\nturtle.pencolor(2) // Vermelho\nturtle.pendown()\nfor (let i = 0; i < 4; i++) {\n    turtle.forward(50)\n    turtle.right(90) // Deve virar à direita (horário)\n}\npause(1500)\n\n// 2. Mover sem Desenhar e Triângulo com heading\ngame.splash(\"Teste 2: Mover e Triângulo Azul\")\nturtle.penup()\nturtle.goto(20, 30)\nturtle.setheading(0) // Apontar para a direita\n\nturtle.pencolor(4) // Azul\nturtle.pendown()\nfor (let i = 0; i < 3; i++) {\n    turtle.forward(40)\n    turtle.left(120) // Deve virar à esquerda (anti-horário)\n}\npause(1500)\n\n// 3. Testar hideturtle e showturtle\ngame.splash(\"Teste 3: Esconder/Mostrar Tartaruga\")\nturtle.hideturtle()\ngame.splash(\"Tartaruga escondida, movendo...\")\nturtle.pencolor(14) // Amarelo escuro\nturtle.forward(25)\npause(1000)\n\nturtle.showturtle()\ngame.splash(\"Tartaruga visível, movendo para trás...\")\nturtle.backward(20)\npause(1500)\n\n// 4. Testar home e clear\ngame.splash(\"Teste 4: Home e Clear\")\nturtle.home() // Volta para o centro, heading 0\nturtle.pencolor(5) // Roxo\nturtle.forward(30)\npause(1000)\n\nturtle.clear() // Limpa o desenho, tartaruga permanece\ngame.splash(\"Desenhos limpos. Tartaruga no lugar.\")\nturtle.right(45)\nturtle.forward(20) // Desenha algo para confirmar\npause(1500)\n\n// 5. Testar reset\ngame.splash(\"Teste 5: Reset Total\")\nturtle.reset()\n// Tela limpa, tartaruga no centro, virada para direita, caneta branca/1, abaixada\nturtle.forward(25) // Deve desenhar uma linha branca/padrão\npause(1500)\n\n// 6. Testar diferentes velocidades\ngame.splash(\"Teste 6: Velocidades\")\nturtle.reset()\nturtle.pencolor(7) // Laranja\nturtle.goto(40, 60)\n\ngame.splash(\"Velocidade 1 (Lenta)\")\nturtle.speed(1)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 10 (Rápida)\")\nturtle.speed(10)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\ngame.splash(\"Velocidade 0 (Instantânea)\")\nturtle.speed(0)\nturtle.forward(40)\nturtle.right(90)\npause(500)\n\nturtle.speed(6) // Volta para uma velocidade padrão\npause(1500)\n\n// 7. Testar pensize (chamada de função)\ngame.splash(\"Teste 7: Pensize (ver console)\")\nconsole.log(\"--- Teste Pensize ---\")\nconsole.log(\"Chamando turtle.pensize(5)\")\nturtle.pensize(5)\nturtle.pencolor(3) // Verde claro\nturtle.forward(15)\nconsole.log(\"Chamando turtle.pensize(1)\")\nturtle.pensize(1)\nturtle.backward(15) // Para ver a linha sobreposta se pensize funcionasse visualmente\npause(1500)\n\n// 8. Testar limites da tela e heading para todas as direções\ngame.splash(\"Teste 8: Direções Cardeais\")\nturtle.reset()\nturtle.speed(4)\n\n// Direita (0 graus)\nturtle.setheading(0)\nturtle.pencolor(2) // Vermelho\nturtle.forward(60)\npause(500)\n\n// Cima (90 graus)\nturtle.home()\nturtle.setheading(90)\nturtle.pencolor(4) // Azul\nturtle.forward(40)\npause(500)\n\n// Esquerda (180 graus)\nturtle.home()\nturtle.setheading(180)\nturtle.pencolor(3) // Verde\nturtle.forward(60)\npause(500)\n\n// Baixo (270 graus)\nturtle.home()\nturtle.setheading(270)\nturtle.pencolor(5) // Roxo\nturtle.forward(40)\npause(1000)\n\n// 9. Teste de \"estrela\" ou padrão radial\ngame.splash(\"Teste 9: Padrão Radial\")\nturtle.reset()\nturtle.speed(7)\nturtle.pencolor(10) // Rosa\nfor (let i = 0; i < 12; i++) {\n    turtle.forward(50)\n    turtle.backward(50) // Volta para o centro\n    turtle.right(30)    // Gira 30 graus\n}\npause(1500)\n\n// 10. Testar estado da caneta com isdown()\ngame.splash(\"Teste 10: Estado da Caneta (isdown)\")\nturtle.reset()\nturtle.speed(5)\nturtle.pencolor(1)\nconsole.log(\"--- Teste isdown ---\")\nconsole.log(\"Pen deve estar DOWN por padrão após reset: \" + turtle.isdown()) // True\nturtle.forward(20)\nturtle.penup()\nconsole.log(\"Pen deve estar UP: \" + turtle.isdown()) // False\nturtle.forward(20) // Não deve desenhar\nturtle.pendown()\nconsole.log(\"Pen deve estar DOWN: \" + turtle.isdown()) // True\nturtle.forward(20)\npause(1500)\n\n// 11. Testar informações de estado (heading, xcor, ycor, position)\ngame.splash(\"Teste 11: Info de Estado (ver console)\")\nturtle.reset()\nturtle.goto(10, 20)\nturtle.setheading(45)\nconsole.log(\"--- Teste Info Estado ---\")\nconsole.log(\"Heading esperado ~45: \" + turtle.heading())\nconsole.log(\"XCOR esperado ~10: \" + turtle.xcor())\nconsole.log(\"YCOR esperado ~20: \" + turtle.ycor())\nlet currentPos = turtle.position()\nconsole.log(\"Position esperada x:~10, y:~20 : x=\" + currentPos.x + \", y=\" + currentPos.y)\nturtle.forward(10)\nconsole.log(\"Novo Heading (ainda 45): \" + turtle.heading())\ncurrentPos = turtle.position()\nconsole.log(\"Nova Posição: x=\" + currentPos.x + \", y=\" + currentPos.y)\npause(1000)\n\n\ngame.splash(\"Testes Concluídos!\")","README.md":" ","assets.json":"","turtle.ts":"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Turtle\"\n// Namespace agora é \"turtle\" para corresponder ao Python\nnamespace turtle {\n    let _turtleSprite: Sprite = null;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1; // Cor padrão (branco no MakeCode)\n    let _penThickness: number = 1; // Nova variável para espessura da caneta\n    let _currentHeading: number = 0; // 0 graus = para a direita (padrão do MakeCode e Turtle Python)\n\n    // Coordenadas da tartaruga (sistema Turtle: 0,0 no centro, Y aumenta para cima)\n    // Internamente, armazenamos como coordenadas Turtle e convertemos para/de MakeCode quando necessário.\n    let _turtleRawX: number = 0;\n    let _turtleRawY: number = 0;\n    let _isTurtleVisible: boolean = true;\n    let _currentShape: string = \"turtle\"; // Formas: \"turtle\", \"arrow\", \"circle\", \"square\", \"triangle\", \"classic\"\n\n    // --- Constantes de Animação ---\n    const ANIMATION_FRAME_DURATION = 150; // ms entre frames da caminhada\n    const PIXELS_PER_STEP = 4; // Quantos pixels a tartaruga anda por frame de animação\n    let _turtleSpeed = 6; // Padrão do Python (0-10, 0 é o mais rápido).\n\n    // --- Arte da Tartaruga (Frames) ---\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;\n\n    let _currentVisualDirection = DIR_RIGHT; // Apenas para a forma \"turtle\"\n    let _turtleIdleFrames: Image[];\n    let _turtleWalkFrames: Image[][];\n\n    // --- IMAGENS DA TARTARUGA (para _currentShape === \"turtle\") ---\n    // !!! COLE SUAS IMAGENS AQUI !!!\n    const turtle_R_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `;\n    const turtle_R_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . f f .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `;\n    const turtle_R_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . f 7 7 7 7 7 7 7 7 f f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f . .\n    . . f 7 7 7 7 7 7 7 7 7 7 f f .\n    . . . f 7 7 7 7 7 7 7 7 f . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `;\n\n    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_L_walk1 = turtle_R_walk1.clone(); turtle_L_walk1.flipX();\n    const turtle_L_walk2 = turtle_R_walk2.clone(); turtle_L_walk2.flipX();\n\n    // !!! IMPORTANTE: CRIE ESTAS IMAGENS MANUALMENTE NO EDITOR DE SPRITES !!!\n    const turtle_U_idle = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA CIMA\n    const turtle_U_walk1 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA CIMA\n    const turtle_U_walk2 = img`\n    . . . . . . . f f . . . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA CIMA\n\n    const turtle_D_idle = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'IDLE' VIRADA PARA BAIXO\n    const turtle_D_walk1 = img`\n    . . . . . . . . . . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK1' VIRADA PARA BAIXO\n    const turtle_D_walk2 = img`\n    . . . . . . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . f f . . . . . . . . . . .\n    . . . . . f f f f f f . . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . f 7 7 7 7 7 7 f . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . f 7 7 7 7 f . . . . .\n    . . . . . . f 7 7 f . . . . . .\n    . . . . . . . f f . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    . . . . . . . . . . . . . . . .\n    `; // <<< COLE AQUI A SUA IMAGEM DA TARTARUGA 'WALK2' VIRADA PARA BAIXO\n\n    // --- Funções Auxiliares de Coordenadas ---\n    function _turtleToScreenX(turtleX: number): number {\n        return scene.screenWidth() / 2 + turtleX;\n    }\n    function _turtleToScreenY(turtleY: number): number {\n        return scene.screenHeight() / 2 - turtleY; // Y invertido\n    }\n    function _screenToTurtleX(screenX: number): number {\n        return screenX - scene.screenWidth() / 2;\n    }\n    function _screenToTurtleY(screenY: number): number {\n        return scene.screenHeight() / 2 - screenY; // Y invertido\n    }\n\n\n    function _initializeTurtleFrames() {\n        // Só inicializa se não tiver sido feito ou se as imagens forem nulas\n        if (!_turtleIdleFrames || !_turtleIdleFrames[0]) {\n            _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n            _turtleWalkFrames = [\n                [turtle_R_walk1, turtle_R_walk2],\n                [turtle_U_walk1, turtle_U_walk2],\n                [turtle_L_walk1, turtle_L_walk2],\n                [turtle_D_walk1, turtle_D_walk2]\n            ];\n\n            // Validação simples\n            for (let i = 0; i < 4; i++) {\n                if (!_turtleIdleFrames[i] || !_turtleWalkFrames[i] || !_turtleWalkFrames[i][0] || !_turtleWalkFrames[i][1]) {\n                    console.warn(`TURTLE: Missing image frames for 'turtle' shape, direction ${i}. Animation may not work correctly.`);\n                    // Usar uma imagem de fallback se alguma estiver faltando para evitar crash\n                    const fallbackImg = image.create(16, 16); fallbackImg.fill(1); fallbackImg.drawRect(0, 0, 16, 16, 7);\n                    if (!_turtleIdleFrames[i]) _turtleIdleFrames[i] = fallbackImg;\n                    if (!_turtleWalkFrames[i] || !_turtleWalkFrames[i][0]) _turtleWalkFrames[i] = [fallbackImg, fallbackImg];\n                    if (!_turtleWalkFrames[i][1]) _turtleWalkFrames[i][1] = fallbackImg;\n                }\n            }\n        }\n    }\n\n    function _createShapeImage(shapeName: string, size: number = 16, color: number = _penColor): Image {\n        let img = image.create(size, size);\n        // Centralizar a forma na imagem para melhor rotação\n        let s2 = Math.floor(size / 2);\n        let s4 = Math.floor(size / 4);\n        let s34 = Math.floor(size * 3 / 4);\n\n        switch (shapeName.toLowerCase()) {\n            case \"circle\":\n                img.drawCircle(s2, s2, s2 - 2, color); // Contorno\n                img.fillCircle(s2, s2, s2 - 3, color); // Preenchimento\n                break;\n            case \"square\":\n                img.fillRect(s4, s4, s2, s2, color);\n                break;\n            case \"arrow\": // Triângulo apontando para a direita\n                img.drawLine(s34, s2, s4, s4, color);       // Top\n                img.drawLine(s4, s4, s4, s34, color);       // Left base\n                img.drawLine(s4, s34, s34, s2, color);      // Bottom\n                // Preenchimento simples (pode não ser perfeito para todos os tamanhos)\n                for (let y = s4 + 1; y < s34; y++) {\n                    let x_start = s4;\n                    let x_end = s4 + Math.floor(((y - s4) / (s2 - s4)) * (s34 - s4));\n                    if (y > s2) {\n                        x_end = s4 + Math.floor(((s34 - y) / (s34 - s2)) * (s34 - s4));\n                    }\n                    img.drawLine(x_start, y, x_end, y, color);\n                }\n                break;\n            case \"triangle\": // Similar ao arrow\n                img.drawLine(s2, s4, s4, s34, color);       // Left\n                img.drawLine(s4, s34, s34, s34, color);     // Bottom\n                img.drawLine(s34, s34, s2, s4, color);      // Right\n                // Preenchimento\n                for (let y = s4; y <= s34; y++) {\n                    let prog = (y - s4) / (s34 - s4);\n                    let x_start = s2 - Math.floor(prog * (s2 - s4));\n                    let x_end = s2 + Math.floor(prog * (s34 - s2));\n                    img.drawLine(x_start, y, x_end, y, color);\n                }\n                break;\n            case \"classic\": // Uma seta mais fina, como a do Python Turtle\n                // Pontos para \"classic\" (0,0), (-5,-9), (0,-7), (5,-9) - adaptado e escalado\n                // Nariz em (s2, s2 + s4/2), corpo para baixo\n                let classic_pts = [\n                    s2, s4,             // Ponto superior (nariz)\n                    s2 - s4, s2 + s4,   // Inferior esquerdo\n                    s2, s2 + s4 / 2,      // Meio (entalhe)\n                    s2 + s4, s2 + s4    // Inferior direito\n                ];\n                // Desenha o polígono (contorno)\n                img.drawLine(classic_pts[0], classic_pts[1], classic_pts[2], classic_pts[3], color);\n                img.drawLine(classic_pts[2], classic_pts[3], classic_pts[4], classic_pts[5], color);\n                img.drawLine(classic_pts[4], classic_pts[5], classic_pts[6], classic_pts[7], color);\n                img.drawLine(classic_pts[6], classic_pts[7], classic_pts[0], classic_pts[1], color);\n                // Preenchimento seria mais complexo, deixar como contorno por enquanto ou usar uma imagem pré-feita.\n                // Para simplificar, usar a mesma imagem do \"arrow\" por enquanto.\n                return _createShapeImage(\"arrow\", size, color);\n\n            default: // Fallback para um quadrado se a forma não for reconhecida\n                img.fillRect(s4, s4, s2, s2, 15); // Cor diferente para indicar fallback\n                break;\n        }\n        return img;\n    }\n\n\n    function _updateSpriteAppearance() {\n        if (!_turtleSprite) return;\n\n        let finalImage: Image = null;\n\n        if (_currentShape === \"turtle\") {\n            _initializeTurtleFrames(); // Garante que os frames da tartaruga estão carregados\n            let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n            if (normalizedAngle >= 315 || normalizedAngle < 45) { _currentVisualDirection = DIR_RIGHT; }\n            else if (normalizedAngle >= 45 && normalizedAngle < 135) { _currentVisualDirection = DIR_UP; }\n            else if (normalizedAngle >= 135 && normalizedAngle < 225) { _currentVisualDirection = DIR_LEFT; }\n            else { _currentVisualDirection = DIR_DOWN; }\n\n            if (_turtleIdleFrames && _turtleIdleFrames[_currentVisualDirection]) {\n                finalImage = _turtleIdleFrames[_currentVisualDirection];\n            } else { // Fallback se a imagem da tartaruga estiver faltando\n                finalImage = _createShapeImage(\"square\", 16, 7); // Quadrado amarelo\n            }\n        } else {\n            let baseImage = _createShapeImage(_currentShape);\n            if (baseImage) {\n                finalImage = baseImage.clone();\n                // Rotaciona a imagem. image.rotate é no sentido horário.\n                // _currentHeading: 0=Direita, 90=Cima.\n                // Para imagem: 0=original, 90=rotacionada 90° horário (Baixo no nosso sistema de heading)\n                // Então, rotação da imagem = -_currentHeading.\n                finalImage.rotate(-_currentHeading);\n            } else { // Fallback se _createShapeImage falhar\n                finalImage = _createShapeImage(\"square\", 16, 7); // Quadrado amarelo\n            }\n        }\n\n        if (_isTurtleVisible && finalImage) {\n            _turtleSprite.setImage(finalImage);\n            _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        } else if (!_isTurtleVisible) {\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        }\n    }\n\n\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            _turtleRawX = 0;\n            _turtleRawY = 0;\n            _currentHeading = 0;\n            _isPenDown = true;\n            _penColor = 1;\n            _penThickness = 1;\n            _isTurtleVisible = true;\n            _turtleSpeed = 6;\n            _currentShape = \"turtle\"; // Padrão inicial\n\n            // Cria o sprite com uma imagem temporária ou baseada na forma inicial\n            let initialImage: Image;\n            if (_currentShape === \"turtle\") {\n                _initializeTurtleFrames();\n                initialImage = (_turtleIdleFrames && _turtleIdleFrames[DIR_RIGHT]) ? _turtleIdleFrames[DIR_RIGHT] : _createShapeImage(\"square\", 16, 7);\n            } else {\n                initialImage = _createShapeImage(_currentShape);\n            }\n            _turtleSprite = sprites.create(initialImage, SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n\n            _updateSpriteAppearance(); // Define a imagem correta e visibilidade\n        }\n    }\n\n    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0;\n        let duration = ANIMATION_FRAME_DURATION; // Default\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            // Python: 1=slowest, 10=fast.\n            // Esta fórmula: speed 1 -> 250ms, speed 10 -> 25ms\n            duration = 25 + (10 - _turtleSpeed) * 25;\n        } else if (_turtleSpeed > 10) {\n            duration = 25; // Mais rápido\n        }\n        return duration;\n    }\n\n    // Função de desenho de linha com espessura\n    function _drawLineWithThickness(screenX0: number, screenY0: number, screenX1: number, screenY1: number, color: number, thickness: number) {\n        if (thickness <= 1) {\n            scene.backgroundImage().drawLine(Math.round(screenX0), Math.round(screenY0), Math.round(screenX1), Math.round(screenY1), color);\n        } else {\n            // Algoritmo de Bresenham para iterar pelos pontos da linha\n            // e desenhar círculos em cada ponto.\n            let r = Math.max(0, Math.floor((thickness - 1) / 2));\n            let x0 = Math.round(screenX0);\n            let y0 = Math.round(screenY0);\n            let x1 = Math.round(screenX1);\n            let y1 = Math.round(screenY1);\n\n            let dx = Math.abs(x1 - x0);\n            let dy = Math.abs(y1 - y0);\n            let sx = (x0 < x1) ? 1 : -1;\n            let sy = (y0 < y1) ? 1 : -1;\n            let err = dx - dy;\n\n            while (true) {\n                scene.backgroundImage().fillCircle(x0, y0, r, color);\n                if ((x0 === x1) && (y0 === y1)) break;\n                let e2 = 2 * err;\n                if (e2 > -dy) { err -= dy; x0 += sx; }\n                if (e2 < dx) { err += dx; y0 += sy; }\n            }\n        }\n    }\n\n    // --- Turtle Motion ---\n\n    //% block=\"forward %distance pixels\"\n    //% blockAlias=fd\n    //% distance.defl=50\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _ensureTurtleExists();\n        const absDistance = Math.abs(distance);\n        const effectiveDistance = distance;\n\n        const radians = _currentHeading * Math.PI / 180;\n        const totalDeltaX = Math.cos(radians) * effectiveDistance;\n        const totalDeltaY = Math.sin(radians) * effectiveDistance; // Y da Turtle aumenta para cima\n\n        const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n        const stepDx = totalDeltaX / numAnimationSteps;\n        const stepDy = totalDeltaY / numAnimationSteps;\n\n        let currentWalkFrameIndex = 0;\n        const animDuration = _getAnimationDuration();\n\n        for (let i = 0; i < numAnimationSteps; i++) {\n            const prevRawX = _turtleRawX;\n            const prevRawY = _turtleRawY;\n\n            _turtleRawX += stepDx;\n            _turtleRawY += stepDy;\n\n            if (_isPenDown) {\n                _drawLineWithThickness(\n                    _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                    _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                    _penColor, _penThickness\n                );\n            }\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n\n            if (_currentShape === \"turtle\" && _isTurtleVisible && _turtleWalkFrames && _turtleWalkFrames[_currentVisualDirection]) {\n                if (_turtleWalkFrames[_currentVisualDirection].length > 0) {\n                    _turtleSprite.setImage(_turtleWalkFrames[_currentVisualDirection][currentWalkFrameIndex]);\n                    currentWalkFrameIndex = (currentWalkFrameIndex + 1) % _turtleWalkFrames[_currentVisualDirection].length;\n                }\n            } // Para outras formas, a imagem já está rotacionada por _updateSpriteAppearance\n\n            if (animDuration > 0) {\n                pause(animDuration);\n            }\n        }\n        if (_isTurtleVisible) {\n            _updateSpriteAppearance(); // Retorna à imagem \"idle\" ou orientação correta\n        }\n    }\n\n    //% block=\"fd %distance pixels\"\n    //% distance.defl=50\n    //% group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance pixels\"\n    //% blockAlias=bk,back\n    //% distance.defl=50\n    //% group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        forward(-distance);\n    }\n    //% block=\"bk %distance pixels\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance pixels\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n\n    //% block=\"left %angle degrees\"\n    //% blockAlias=lt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading += angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\"\n    //% blockAlias=rt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading -= angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos,setposition\n    //% x.defl=0 y.defl=0\n    //% group=\"Movement\" weight=60\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        // x, y são coordenadas Turtle (0,0 é centro)\n        // Turtle Python não desenha em goto por padrão.\n        // Se quiser desenhar, precisaria de uma lógica similar a forward()\n        _turtleRawX = x;\n        _turtleRawY = y;\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        // _updateSpriteAppearance(); // A orientação não muda com goto\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=59 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=58 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n\n    //% block=\"set heading %to_angle degrees\"\n    //% blockAlias=seth\n    //% to_angle.defl=0\n    //% group=\"Movement\" weight=50\n    export function setheading(to_angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading = to_angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"seth %to_angle degrees\" group=\"Movement\" weight=49 blockHidden=true\n    export function seth(to_angle: number): void { setheading(to_angle); }\n\n    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists();\n        _turtleRawX = 0;\n        _turtleRawY = 0;\n        _currentHeading = 0; // Direita\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        _updateSpriteAppearance();\n        // pendown(); // Opcional, se quiser que home sempre baixe a caneta\n    }\n\n    //% block=\"speed %speedValue (0-10)\"\n    //% speedValue.min=0 speedValue.max=10 speedValue.defl=6\n    //% group=\"Movement\" weight=30\n    export function speed(speedValue: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, Math.round(speedValue));\n    }\n\n    // --- Pen Control ---\n\n    //% block=\"pen down\"\n    //% blockAlias=pd,down\n    //% group=\"Pen Control\" weight=100\n    export function pendown(): void {\n        _ensureTurtleExists();\n        _isPenDown = true;\n    }\n    //% block=\"pd\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"pen up\"\n    //% blockAlias=pu,up\n    //% group=\"Pen Control\" weight=90\n    export function penup(): void {\n        _ensureTurtleExists();\n        _isPenDown = false;\n    }\n    //% block=\"pu\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n        // Se a forma não for \"turtle\", podemos querer atualizar a cor da forma também\n        if (_currentShape !== \"turtle\") {\n            _updateSpriteAppearance();\n        }\n    }\n\n    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=70\n    export function isdown(): boolean {\n        _ensureTurtleExists();\n        return _isPenDown;\n    }\n\n    //% block=\"pen size %widthNum\"\n    //% blockAlias=width\n    //% widthNum.min=1 widthNum.defl=1\n    //% group=\"Pen Control\" weight=60\n    export function pensize(widthNum: number): void {\n        _ensureTurtleExists();\n        _penThickness = Math.max(1, Math.round(widthNum));\n    }\n    //% block=\"width %widthNum\" group=\"Pen Control\" weight=59 blockHidden=true\n    export function width(w: number): void { pensize(w); }\n\n\n    // --- Turtle State ---\n\n    //% block=\"shape %name\"\n    //% name.fieldEditor=dropdown\n    //% name.fieldOptions.items='[[\"turtle\", \"turtle\"], [\"arrow\", \"arrow\"], [\"circle\", \"circle\"], [\"square\", \"square\"], [\"triangle\", \"triangle\"], [\"classic\", \"classic\"]]'\n    //% name.defl=\"turtle\"\n    //% group=\"Turtle State\" weight=65\n    export function shape(name: string): void {\n        _ensureTurtleExists();\n        const lowerName = name.toLowerCase();\n        const supportedShapes = [\"turtle\", \"arrow\", \"circle\", \"square\", \"triangle\", \"classic\"];\n        if (supportedShapes.indexOf(lowerName) !== -1) {\n            _currentShape = lowerName;\n            _updateSpriteAppearance();\n        } else {\n            console.warn(`TURTLE: Shape \"${name}\" not recognized.`);\n        }\n    }\n\n    //% block=\"heading\"\n    //% group=\"Turtle State\" weight=100\n    export function heading(): number {\n        _ensureTurtleExists();\n        return (_currentHeading % 360 + 360) % 360;\n    }\n\n    //% block=\"position\"\n    //% blockAlias=pos\n    //% group=\"Turtle State\" weight=90\n    export function position(): { x: number, y: number } {\n        _ensureTurtleExists();\n        return { x: Math.round(_turtleRawX), y: Math.round(_turtleRawY) };\n    }\n    //% block=\"pos\" group=\"Turtle State\" weight=89 blockHidden=true\n    export function pos(): { x: number, y: number } { return position(); }\n\n    //% block=\"x coordinate\"\n    //% group=\"Turtle State\" weight=80\n    export function xcor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawX);\n    }\n\n    //% block=\"y coordinate\"\n    //% group=\"Turtle State\" weight=70\n    export function ycor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawY);\n    }\n\n    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=60\n    export function showturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = true;\n        _updateSpriteAppearance(); // Atualiza a imagem e remove o flag Invisible\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=59 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=50\n    export function hideturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = false;\n        if (_turtleSprite) { // Garante que o sprite existe antes de tentar mudar o flag\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        }\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=49 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=40\n    export function isvisible(): boolean {\n        _ensureTurtleExists();\n        return _isTurtleVisible;\n    }\n\n    // --- Drawing Control ---\n    //% block=\"clear drawings\"\n    //% group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        scene.backgroundImage().fill(scene.backgroundColor());\n    }\n\n    //% block=\"reset turtle\"\n    //% group=\"Drawing Control\" weight=90\n    export function reset(): void {\n        if (_turtleSprite) {\n            _turtleSprite.destroy();\n            _turtleSprite = null; // Força a recriação em _ensureTurtleExists\n        }\n        scene.backgroundImage().fill(scene.backgroundColor()); // Limpa desenhos\n        // _ensureTurtleExists será chamado por qualquer comando subsequente,\n        // ou podemos chamá-lo aqui para garantir o estado inicial.\n        // As variáveis de estado globais já são redefinidas em _ensureTurtleExists\n        // quando _turtleSprite é nulo.\n        _currentShape = \"turtle\"; // Redefine a forma para o padrão\n        _ensureTurtleExists(); // Recria e redefine para os padrões\n        // home(); // home() já está implícito na recriação\n        // pendown(); // pendown() já está implícito\n        // pencolor(1); // pencolor() já está implícito\n        // speed(6); // speed() já está implícito\n        // showturtle(); // showturtle() já está implícito\n    }\n\n    // Inicializa a tartaruga automaticamente para que os blocos funcionem sem um \"start\" explícito\n    // Isso garante que _turtleSprite seja criado na primeira vez que o namespace é carregado.\n    // No entanto, _ensureTurtleExists() é chamado no início de cada função pública,\n    // o que é uma prática mais robusta.\n    // Não é estritamente necessário chamar aqui se todas as funções públicas chamam _ensureTurtleExists().\n    // Mas pode ser bom para configurar o estado inicial assim que o jogo começa.\n    // control.runInParallel(() => _ensureTurtleExists()); // Executa uma vez no início\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749320535509,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"\n","README.md":" ","assets.json":"","turtle.ts":"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Turtle\"\nnamespace turtle {\n    let _turtleSprite: Sprite = null;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1;\n    let _penThickness: number = 1;\n    let _currentHeading: number = 0; // 0 graus = para a direita\n\n    // Coordenadas da tartaruga (sistema Turtle: 0,0 no centro, Y aumenta para cima)\n    let _turtleRawX: number = 0;\n    let _turtleRawY: number = 0;\n    let _isTurtleVisible: boolean = true;\n\n    const ANIMATION_FRAME_DURATION = 150; // Usado para a pausa entre os \"saltos\" da tartaruga\n    const PIXELS_PER_STEP = 4;      // Distância de cada \"salto\" para controle de velocidade\n    let _turtleSpeed = 6;           // Padrão Python (0-10, 0 é o mais rápido)\n\n    // --- Arte da Tartaruga (Frames) ---\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;\n\n    let _currentVisualDirection = DIR_RIGHT;\n    let _turtleIdleFrames: Image[];\n\n    // --- IMAGENS DA TARTARUGA (APENAS IDLE) ---\n    // !!! COLE SUAS IMAGENS AQUI ou garanta que os assets existem !!!\n    // Se assets.image`nome` não existir, causará erro de compilação.\n    const turtle_R_idle = assets.image`turtleRight`;\n    const turtle_L_idle = turtle_R_idle.clone(); turtle_L_idle.flipX();\n    const turtle_U_idle = assets.image`turtleUp`;\n    const turtle_D_idle = assets.image`turtleDown`;\n\n    // --- Funções Auxiliares de Coordenadas ---\n    function _turtleToScreenX(turtleX: number): number {\n        return scene.screenWidth() / 2 + turtleX;\n    }\n    function _turtleToScreenY(turtleY: number): number {\n        return scene.screenHeight() / 2 - turtleY; // Y invertido\n    }\n\n    function _initializeTurtleFrames() {\n        if (!_turtleIdleFrames || !_turtleIdleFrames[0]) { // Evita reinicialização desnecessária\n            _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n\n            // Validação e fallback para imagens idle ausentes\n            const fallbackImg = image.create(16, 16); fallbackImg.fill(1); fallbackImg.drawRect(0, 0, 16, 16, 7);\n            for (let i = 0; i < 4; i++) {\n                if (!_turtleIdleFrames[i]) {\n                    console.warn(`TURTLE: Missing idle frame for direction ${i}. Using fallback.`);\n                    _turtleIdleFrames[i] = fallbackImg.clone();\n                }\n            }\n        }\n    }\n\n    function _updateSpriteAppearance() {\n        if (!_turtleSprite) return;\n        _initializeTurtleFrames(); // Garante que os frames idle estão carregados\n\n        let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n        if (normalizedAngle >= 315 || normalizedAngle < 45) { _currentVisualDirection = DIR_RIGHT; }\n        else if (normalizedAngle >= 45 && normalizedAngle < 135) { _currentVisualDirection = DIR_UP; }\n        else if (normalizedAngle >= 135 && normalizedAngle < 225) { _currentVisualDirection = DIR_LEFT; }\n        else { _currentVisualDirection = DIR_DOWN; }\n\n        if (_isTurtleVisible && _turtleIdleFrames[_currentVisualDirection]) {\n            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n            _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        } else if (!_isTurtleVisible) {\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        } else if (!_turtleIdleFrames[_currentVisualDirection]) {\n            console.warn(\"TURTLE: Idle frame missing for current visual direction: \" + _currentVisualDirection);\n            // Poderia definir uma imagem de fallback aqui se a validação em _initializeTurtleFrames falhar\n        }\n    }\n\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            _initializeTurtleFrames(); // Carrega as imagens idle da tartaruga\n\n            _turtleRawX = 0;\n            _turtleRawY = 0;\n            _currentHeading = 0;\n            _isPenDown = true;\n            _penColor = 1; // Branco por padrão no MakeCode\n            _penThickness = 1;\n            _isTurtleVisible = true;\n            _turtleSpeed = 6;\n            _currentVisualDirection = DIR_RIGHT;\n\n            let initialImage = _turtleIdleFrames[DIR_RIGHT];\n            if (!initialImage) { // Fallback extremo se tudo falhar\n                initialImage = image.create(16, 16); initialImage.fill(7); // Cinza escuro\n                console.error(\"TURTLE: Critical failure loading initial turtle image.\");\n            }\n\n            _turtleSprite = sprites.create(initialImage, SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true); // Mantém a tartaruga na tela\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n\n            _updateSpriteAppearance(); // Define a imagem correta e visibilidade\n        }\n    }\n\n    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0; // Movimento instantâneo\n        let duration = ANIMATION_FRAME_DURATION;\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            duration = 25 + (10 - _turtleSpeed) * 25;\n        } else if (_turtleSpeed > 10) {\n            duration = 25;\n        }\n        return duration;\n    }\n\n    function _drawLineWithThickness(screenX0: number, screenY0: number, screenX1: number, screenY1: number, color: number, thickness: number) {\n        if (thickness <= 1) {\n            scene.backgroundImage().drawLine(Math.round(screenX0), Math.round(screenY0), Math.round(screenX1), Math.round(screenY1), color);\n        } else {\n            // Desenha uma linha mais grossa preenchendo círculos ao longo do caminho\n            let r = Math.max(0, Math.floor((thickness - 1) / 2));\n            let x0 = Math.round(screenX0);\n            let y0 = Math.round(screenY0);\n            let x1 = Math.round(screenX1);\n            let y1 = Math.round(screenY1);\n\n            let dx = Math.abs(x1 - x0);\n            let dy = Math.abs(y1 - y0);\n            let sx = (x0 < x1) ? 1 : -1;\n            let sy = (y0 < y1) ? 1 : -1;\n            let err = dx - dy;\n\n            while (true) {\n                scene.backgroundImage().fillCircle(x0, y0, r, color);\n                if ((x0 === x1) && (y0 === y1)) break;\n                let e2 = 2 * err;\n                if (e2 > -dy) { err -= dy; x0 += sx; }\n                if (e2 < dx) { err += dx; y0 += sy; }\n            }\n        }\n    }\n\n    // --- Turtle Motion ---\n\n    //% block=\"forward %distance pixels\"\n    //% blockAlias=fd\n    //% distance.defl=50\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _ensureTurtleExists();\n        const absDistance = Math.abs(distance);\n        const effectiveDistance = distance;\n\n        const radians = _currentHeading * Math.PI / 180;\n        const totalDeltaX = Math.cos(radians) * effectiveDistance;\n        const totalDeltaY = Math.sin(radians) * effectiveDistance; // Y positivo é para cima no sistema Turtle\n\n        const animDuration = _getAnimationDuration();\n\n        if (animDuration === 0) { // Movimento instantâneo se speed for 0\n            const prevRawX = _turtleRawX;\n            const prevRawY = _turtleRawY;\n            _turtleRawX += totalDeltaX;\n            _turtleRawY += totalDeltaY;\n            if (_isPenDown) {\n                _drawLineWithThickness(\n                    _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                    _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                    _penColor, _penThickness\n                );\n            }\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        } else {\n            // Movimento em passos para simular velocidade\n            const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n            const stepDx = totalDeltaX / numAnimationSteps;\n            const stepDy = totalDeltaY / numAnimationSteps;\n\n            for (let i = 0; i < numAnimationSteps; i++) {\n                const prevRawX = _turtleRawX;\n                const prevRawY = _turtleRawY;\n\n                _turtleRawX += stepDx;\n                _turtleRawY += stepDy;\n\n                if (_isPenDown) {\n                    _drawLineWithThickness(\n                        _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                        _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                        _penColor, _penThickness\n                    );\n                }\n                _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n\n                // A imagem da tartaruga (idle) NÃO muda durante os passos.\n                // Ela já foi definida por _updateSpriteAppearance() para a direção atual.\n\n                if (animDuration > 0) { // Pausa entre os \"saltos\"\n                    pause(animDuration);\n                }\n            }\n        }\n\n        // Garante que a aparência (direção visual) esteja correta no final do movimento.\n        if (_isTurtleVisible) {\n            _updateSpriteAppearance();\n        }\n    }\n\n    //% block=\"fd %distance pixels\"\n    //% distance.defl=50\n    //% group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance pixels\"\n    //% blockAlias=bk,back\n    //% distance.defl=50\n    //% group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        forward(-distance);\n    }\n    //% block=\"bk %distance pixels\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance pixels\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n\n    //% block=\"left %angle degrees\"\n    //% blockAlias=lt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading += angle; // No Turtle padrão, esquerda é anti-horário (aumenta o ângulo)\n        _updateSpriteAppearance();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\"\n    //% blockAlias=rt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading -= angle; // No Turtle padrão, direita é horário (diminui o ângulo)\n        _updateSpriteAppearance();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos,setposition\n    //% x.defl=0 y.defl=0\n    //% group=\"Movement\" weight=60\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        // O Turtle do Python não desenha em goto, mesmo com a caneta abaixada.\n        _turtleRawX = x;\n        _turtleRawY = y;\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        _updateSpriteAppearance();\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=59 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=58 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n\n    //% block=\"set heading %to_angle degrees\"\n    //% blockAlias=seth\n    //% to_angle.defl=0\n    //% group=\"Movement\" weight=50\n    export function setheading(to_angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading = to_angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"seth %to_angle degrees\" group=\"Movement\" weight=49 blockHidden=true\n    export function seth(to_angle: number): void { setheading(to_angle); }\n\n    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists();\n        _turtleRawX = 0;\n        _turtleRawY = 0;\n        _currentHeading = 0;\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        _updateSpriteAppearance();\n    }\n\n    //% block=\"speed %speedValue (0-10)\"\n    //% speedValue.min=0 speedValue.max=10 speedValue.defl=6\n    //% group=\"Movement\" weight=30\n    export function speed(speedValue: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, Math.round(speedValue));\n    }\n\n    // --- Pen Control ---\n\n    //% block=\"pen down\"\n    //% blockAlias=pd,down\n    //% group=\"Pen Control\" weight=100\n    export function pendown(): void {\n        _ensureTurtleExists();\n        _isPenDown = true;\n    }\n    //% block=\"pd\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"pen up\"\n    //% blockAlias=pu,up\n    //% group=\"Pen Control\" weight=90\n    export function penup(): void {\n        _ensureTurtleExists();\n        _isPenDown = false;\n    }\n    //% block=\"pu\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n    }\n\n    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=70\n    export function isdown(): boolean {\n        _ensureTurtleExists();\n        return _isPenDown;\n    }\n\n    //% block=\"pen size %widthNum\"\n    //% blockAlias=width\n    //% widthNum.min=1 widthNum.defl=1\n    //% group=\"Pen Control\" weight=60\n    export function pensize(widthNum: number): void {\n        _ensureTurtleExists();\n        _penThickness = Math.max(1, Math.round(widthNum));\n    }\n    //% block=\"width %widthNum\" group=\"Pen Control\" weight=59 blockHidden=true\n    export function width(w: number): void { pensize(w); }\n\n\n    // --- Turtle State ---\n\n    //% block=\"heading\"\n    //% group=\"Turtle State\" weight=100\n    export function heading(): number {\n        _ensureTurtleExists();\n        return (_currentHeading % 360 + 360) % 360;\n    }\n\n    //% block=\"position\"\n    //% blockAlias=pos\n    //% group=\"Turtle State\" weight=90\n    export function position(): { x: number, y: number } {\n        _ensureTurtleExists();\n        return { x: Math.round(_turtleRawX), y: Math.round(_turtleRawY) };\n    }\n    //% block=\"pos\" group=\"Turtle State\" weight=89 blockHidden=true\n    export function pos(): { x: number, y: number } { return position(); }\n\n    //% block=\"x coordinate\"\n    //% group=\"Turtle State\" weight=80\n    export function xcor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawX);\n    }\n\n    //% block=\"y coordinate\"\n    //% group=\"Turtle State\" weight=70\n    export function ycor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawY);\n    }\n\n    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=60\n    export function showturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = true;\n        _updateSpriteAppearance();\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=59 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=50\n    export function hideturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = false;\n        if (_turtleSprite) { // Garante que o sprite existe antes de tentar modificar\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        }\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=49 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=40\n    export function isvisible(): boolean {\n        _ensureTurtleExists();\n        return _isTurtleVisible;\n    }\n\n    // --- Drawing Control ---\n    //% block=\"clear drawings\"\n    //% group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        // Não precisa de _ensureTurtleExists() pois só mexe no background\n        scene.backgroundImage().fill(scene.backgroundColor());\n    }\n\n    //% block=\"reset turtle\"\n    //% group=\"Drawing Control\" weight=90\n    export function reset(): void {\n        if (_turtleSprite) {\n            _turtleSprite.destroy();\n            _turtleSprite = null;\n        }\n        scene.backgroundImage().fill(scene.backgroundColor());\n        _ensureTurtleExists(); // Recria e redefine para os padrões\n    }\n\n    // Inicializa a tartaruga para que ela apareça na tela ao iniciar o programa.\n    _ensureTurtleExists();\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQPABAAAAAAAAB3AAAAAAAAcHcAAHAHAAB3AAAAdwcAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwcAAHB3AABwBwAAAHcAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp\"\n    },\n    \"image2\": {\n        \"data\": \"hwQPABAAAAAAAAAAdwAAAHAHAAB3BwAAcHcAAAB3AAAAd2dmZncAAABwZmZmBgAAAGBmZmZmcAcAZ2ZmZmZ3dwBnZmZmZnd3AGBmZmZmcAcAcGZmZgYAAAB3Z2ZmdwAAcHcAAAB3AABwBwAAdwcAAAAAAAB3AAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleDown\"\n    },\n    \"image3\": {\n        \"data\": \"hwQQAA8AAAAAAAAAAAAAAHAHAAAAcAcAcHcAdwB3BwAAd2dmdncAAABwZmZmBwAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAd2BmZmYGdwB3YGZmZgZ3AHB3ZmZmdwcAAHdgZgZ3AAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleRight\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQAA8AAAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAAB3YGYGdwAAcHdmZmZ3BwB3YGZmZgZ3AHdgZmZmBncAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAHBmZmYHAAAAd2dmdncAAHB3AHcAdwcAcAcAAABwBwAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleLeft\"\n    },\n    \"image5\": {\n        \"data\": \"hwQPABAAAAAAdwAAAAAAAAB3dwAAAAAAAAB3AAAAdwAAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwAAd3cAAAAAAAB3AAAAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp0\"\n    },\n    \"image6\": {\n        \"data\": \"hwQPABAAAAAAAAAAAAB3AAAAAAAAd3cAAHcAAAB3AAAAd2dmZncAAABwZmZmBgAAAGBmZmZmcAcAZ2ZmZmZ3dwBnZmZmZnd3AGBmZmZmcAcAcGZmZgYAAAB3Z2ZmdwAAAHcAAAB3AAAAAAAAAHd3AAAAAAAAAHcAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleDown0\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQAA8AAAAAAAB3AAAAAAAAcHcHAAAAdwBwdwcAdwB3AAB3AAB3AHB3YGYGdwcAcHdmZmZ3BwAAYGZmZgYAAABgZmZmBgAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAHBmZmYHAAAAd2dmdncAAAB3AHcAdwAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleLeft0\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQAA8AAAAAAAAAAAAAAAAAAAAAAAAAAHcAdwB3AAAAd2dmdncAAABwZmZmBwAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAGBmZmYGAAAAYGZmZgYAAHB3ZmZmdwcAcHdgZgZ3BwB3AAB3AAB3AHcAcHcHAHcAAABwdwcAAAAAAAB3AAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleRight0\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\",\n        \"images.g.jres\",\n        \"images.g.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1749322342961,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","turtle.ts":"//% color=\"#2E8B57\" icon=\"\\uf188\" block=\"Turtle\"\nnamespace turtle {\n    let _turtleSprite: Sprite = null;\n    let _isPenDown: boolean = true;\n    let _penColor: number = 1;\n    let _penThickness: number = 1;\n    let _currentHeading: number = 0; // Será redefinido em _ensureTurtleExists\n\n    // Coordenadas da tartaruga (sistema Turtle: 0,0 no centro, Y aumenta para cima)\n    let _turtleRawX: number = 0;\n    let _turtleRawY: number = 0;\n    let _isTurtleVisible: boolean = true;\n\n    const ANIMATION_FRAME_DURATION = 150;\n    const PIXELS_PER_STEP = 4;\n    let _turtleSpeed = 6;\n\n    // --- Arte da Tartaruga (Frames) ---\n    const DIR_RIGHT = 0;\n    const DIR_UP = 1;\n    const DIR_LEFT = 2;\n    const DIR_DOWN = 3;\n\n    let _currentVisualDirection = DIR_UP; // Ajustado para o novo padrão inicial\n    let _turtleIdleFrames: Image[];\n\n    // --- IMAGENS DA TARTARUGA (APENAS IDLE) ---\n    const turtle_R_idle = img`\n        . . . . . . . . 7 7 . . . . . .\n        . 7 7 . . . . . 7 7 7 . . . . .\n        . 7 7 7 . . . . . . 7 7 . . . .\n        . . 7 7 7 6 6 6 6 6 7 7 . . . .\n        . . . 7 6 6 6 6 6 6 6 . . . . .\n        . . . 6 6 6 6 6 6 6 6 6 . 7 7 .\n        . . 7 6 6 6 6 6 6 6 6 6 7 7 7 7\n        . . 7 6 6 6 6 6 6 6 6 6 7 7 7 7\n        . . . 6 6 6 6 6 6 6 6 6 . 7 7 .\n        . . . 7 6 6 6 6 6 6 6 . . . . .\n        . . 7 7 7 6 6 6 6 6 7 7 . . . .\n        . 7 7 7 . . . . . . 7 7 . . . .\n        . 7 7 . . . . . 7 7 7 . . . . .\n        . . . . . . . . 7 7 . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n    `;\n    const turtle_L_idle = img`\n        . . . . . . 7 7 . . . . . . . .\n        . . . . . 7 7 7 . . . . . 7 7 .\n        . . . . 7 7 . . . . . . 7 7 7 .\n        . . . . 7 7 6 6 6 6 6 7 7 7 . .\n        . . . . . 6 6 6 6 6 6 6 7 . . .\n        . 7 7 . 6 6 6 6 6 6 6 6 6 . . .\n        7 7 7 7 6 6 6 6 6 6 6 6 6 7 . .\n        7 7 7 7 6 6 6 6 6 6 6 6 6 7 . .\n        . 7 7 . 6 6 6 6 6 6 6 6 6 . . .\n        . . . . . 6 6 6 6 6 6 6 7 . . .\n        . . . . 7 7 6 6 6 6 6 7 7 7 . .\n        . . . . 7 7 . . . . . . 7 7 7 .\n        . . . . . 7 7 7 . . . . . 7 7 .\n        . . . . . . 7 7 . . . . . . . .\n        . . . . . . . . . . . . . . . .\n        . . . . . . . . . . . . . . . .\n    `;\n    const turtle_U_idle = img`\n        . . . . . . 7 7 . . . . . . . .\n        . . . . . 7 7 7 7 . . . . . . .\n        . . . . . 7 7 7 7 . . . . . . .\n        . . . . . . 7 7 . . . . . . . .\n        . . 7 7 . 6 6 6 6 . 7 7 . . . .\n        . 7 7 7 6 6 6 6 6 6 7 7 7 . . .\n        7 7 . 6 6 6 6 6 6 6 6 . 7 7 . .\n        7 7 . 6 6 6 6 6 6 6 6 . 7 7 . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        . . . 7 6 6 6 6 6 6 7 . . . . .\n        . . 7 7 7 6 6 6 6 7 7 7 . . . .\n        . 7 7 7 . . 7 7 . . 7 7 7 . . .\n        . 7 7 . . . . . . . . 7 7 . . .\n        . . . . . . . . . . . . . . . .\n    `;   // <<< Certifique-se que este asset existe\n    const turtle_D_idle = img`\n        . . . . . . . . . . . . . . . .\n        . 7 7 . . . . . . . . 7 7 . . .\n        . 7 7 7 . . 7 7 . . 7 7 7 . . .\n        . . 7 7 7 6 6 6 6 7 7 7 . . . .\n        . . . 7 6 6 6 6 6 6 7 . . . . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        . . . 6 6 6 6 6 6 6 6 . . . . .\n        7 7 . 6 6 6 6 6 6 6 6 . 7 7 . .\n        7 7 . 6 6 6 6 6 6 6 6 . 7 7 . .\n        . 7 7 7 6 6 6 6 6 6 7 7 7 . . .\n        . . 7 7 . 6 6 6 6 . 7 7 . . . .\n        . . . . . . 7 7 . . . . . . . .\n        . . . . . 7 7 7 7 . . . . . . .\n        . . . . . 7 7 7 7 . . . . . . .\n        . . . . . . 7 7 . . . . . . . .\n    `; // <<< Certifique-se que este asset existe\n\n    // --- Funções Auxiliares de Coordenadas ---\n    function _turtleToScreenX(turtleX: number): number {\n        return scene.screenWidth() / 2 + turtleX;\n    }\n    function _turtleToScreenY(turtleY: number): number {\n        return scene.screenHeight() / 2 - turtleY; // Y invertido\n    }\n\n    function _initializeTurtleFrames() {\n        if (!_turtleIdleFrames || !_turtleIdleFrames[0]) {\n            _turtleIdleFrames = [turtle_R_idle, turtle_U_idle, turtle_L_idle, turtle_D_idle];\n\n            const fallbackImg = image.create(16, 16); fallbackImg.fill(1); fallbackImg.drawRect(0, 0, 16, 16, 7);\n            for (let i = 0; i < 4; i++) {\n                if (!_turtleIdleFrames[i]) {\n                    console.warn(`TURTLE: Missing idle frame for direction ${i}. Using fallback.`);\n                    _turtleIdleFrames[i] = fallbackImg.clone();\n                }\n            }\n        }\n    }\n\n    function _updateSpriteAppearance() {\n        if (!_turtleSprite) return;\n        _initializeTurtleFrames();\n\n        let normalizedAngle = (_currentHeading % 360 + 360) % 360;\n        if (normalizedAngle >= 315 || normalizedAngle < 45) { _currentVisualDirection = DIR_RIGHT; }\n        else if (normalizedAngle >= 45 && normalizedAngle < 135) { _currentVisualDirection = DIR_UP; }\n        else if (normalizedAngle >= 135 && normalizedAngle < 225) { _currentVisualDirection = DIR_LEFT; }\n        else { _currentVisualDirection = DIR_DOWN; }\n\n        if (_isTurtleVisible && _turtleIdleFrames[_currentVisualDirection]) {\n            _turtleSprite.setImage(_turtleIdleFrames[_currentVisualDirection]);\n            _turtleSprite.setFlag(SpriteFlag.Invisible, false);\n        } else if (!_isTurtleVisible) {\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        } else if (!_turtleIdleFrames[_currentVisualDirection]) {\n            console.warn(\"TURTLE: Idle frame missing for current visual direction: \" + _currentVisualDirection);\n        }\n    }\n\n    function _ensureTurtleExists() {\n        if (!_turtleSprite) {\n            _initializeTurtleFrames();\n\n            _turtleRawX = 0;\n            _turtleRawY = 0;\n            _currentHeading = 90; // <<< MUDANÇA: Começa virada para CIMA (90 graus)\n            _isPenDown = true;\n            _penColor = 1;\n            _penThickness = 1;\n            _isTurtleVisible = true;\n            _turtleSpeed = 6;\n            _currentVisualDirection = DIR_UP; // Define a direção visual inicial para cima\n\n            // _turtleIdleFrames[DIR_UP] deve ser válido após _initializeTurtleFrames (que inclui fallbacks)\n            let initialImage = _turtleIdleFrames[DIR_UP];\n            if (!initialImage) { // Fallback extremo, não deveria acontecer se _initializeTurtleFrames funcionar\n                initialImage = image.create(16, 16); initialImage.fill(1);\n                console.error(\"TURTLE: Critical fallback for initialImage, _turtleIdleFrames[DIR_UP] was unexpectedly null.\");\n            }\n\n            _turtleSprite = sprites.create(initialImage, SpriteKind.Player);\n            _turtleSprite.setFlag(SpriteFlag.StayInScreen, true);\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n\n            _updateSpriteAppearance(); // Garante que a imagem e visibilidade estão corretas\n        }\n    }\n\n    function _getAnimationDuration(): number {\n        if (_turtleSpeed === 0) return 0;\n        let duration = ANIMATION_FRAME_DURATION;\n        if (_turtleSpeed >= 1 && _turtleSpeed <= 10) {\n            duration = 25 + (10 - _turtleSpeed) * 25;\n        } else if (_turtleSpeed > 10) {\n            duration = 25;\n        }\n        return duration;\n    }\n\n    function _drawLineWithThickness(screenX0: number, screenY0: number, screenX1: number, screenY1: number, color: number, thickness: number) {\n        if (thickness <= 1) {\n            scene.backgroundImage().drawLine(Math.round(screenX0), Math.round(screenY0), Math.round(screenX1), Math.round(screenY1), color);\n        } else {\n            let r = Math.max(0, Math.floor((thickness - 1) / 2));\n            let x0 = Math.round(screenX0);\n            let y0 = Math.round(screenY0);\n            let x1 = Math.round(screenX1);\n            let y1 = Math.round(screenY1);\n\n            let dx = Math.abs(x1 - x0);\n            let dy = Math.abs(y1 - y0);\n            let sx = (x0 < x1) ? 1 : -1;\n            let sy = (y0 < y1) ? 1 : -1;\n            let err = dx - dy;\n\n            while (true) {\n                scene.backgroundImage().fillCircle(x0, y0, r, color);\n                if ((x0 === x1) && (y0 === y1)) break;\n                let e2 = 2 * err;\n                if (e2 > -dy) { err -= dy; x0 += sx; }\n                if (e2 < dx) { err += dx; y0 += sy; }\n            }\n        }\n    }\n\n    // --- Turtle Motion ---\n\n    //% block=\"forward %distance pixels\"\n    //% blockAlias=fd\n    //% distance.defl=50\n    //% group=\"Movement\" weight=100\n    export function forward(distance: number): void {\n        _ensureTurtleExists();\n        const absDistance = Math.abs(distance);\n        const effectiveDistance = distance;\n\n        const radians = _currentHeading * Math.PI / 180;\n        const totalDeltaX = Math.cos(radians) * effectiveDistance;\n        const totalDeltaY = Math.sin(radians) * effectiveDistance;\n\n        const animDuration = _getAnimationDuration();\n\n        if (animDuration === 0) {\n            const prevRawX = _turtleRawX;\n            const prevRawY = _turtleRawY;\n            _turtleRawX += totalDeltaX;\n            _turtleRawY += totalDeltaY;\n            if (_isPenDown) {\n                _drawLineWithThickness(\n                    _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                    _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                    _penColor, _penThickness\n                );\n            }\n            _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        } else {\n            const numAnimationSteps = Math.max(1, Math.ceil(absDistance / PIXELS_PER_STEP));\n            const stepDx = totalDeltaX / numAnimationSteps;\n            const stepDy = totalDeltaY / numAnimationSteps;\n\n            for (let i = 0; i < numAnimationSteps; i++) {\n                const prevRawX = _turtleRawX;\n                const prevRawY = _turtleRawY;\n\n                _turtleRawX += stepDx;\n                _turtleRawY += stepDy;\n\n                if (_isPenDown) {\n                    _drawLineWithThickness(\n                        _turtleToScreenX(prevRawX), _turtleToScreenY(prevRawY),\n                        _turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY),\n                        _penColor, _penThickness\n                    );\n                }\n                _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n                if (animDuration > 0) {\n                    pause(animDuration);\n                }\n            }\n        }\n\n        if (_isTurtleVisible) {\n            _updateSpriteAppearance();\n        }\n    }\n\n    //% block=\"fd %distance pixels\"\n    //% distance.defl=50\n    //% group=\"Movement\" weight=99 blockHidden=true\n    export function fd(distance: number): void { forward(distance); }\n\n    //% block=\"backward %distance pixels\"\n    //% blockAlias=bk,back\n    //% distance.defl=50\n    //% group=\"Movement\" weight=90\n    export function backward(distance: number): void {\n        forward(-distance);\n    }\n    //% block=\"bk %distance pixels\" group=\"Movement\" weight=89 blockHidden=true\n    export function bk(distance: number): void { backward(distance); }\n    //% block=\"back %distance pixels\" group=\"Movement\" weight=88 blockHidden=true\n    export function back(distance: number): void { backward(distance); }\n\n\n    //% block=\"left %angle degrees\"\n    //% blockAlias=lt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=80\n    export function left(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading += angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"lt %angle degrees\" group=\"Movement\" weight=79 blockHidden=true\n    export function lt(angle: number): void { left(angle); }\n\n    //% block=\"right %angle degrees\"\n    //% blockAlias=rt\n    //% angle.defl=90\n    //% group=\"Movement\" weight=70\n    export function right(angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading -= angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"rt %angle degrees\" group=\"Movement\" weight=69 blockHidden=true\n    export function rt(angle: number): void { right(angle); }\n\n    //% block=\"go to x %x y %y\"\n    //% blockAlias=setpos,setposition\n    //% x.defl=0 y.defl=0\n    //% group=\"Movement\" weight=60\n    export function goto(x: number, y: number): void {\n        _ensureTurtleExists();\n        _turtleRawX = x;\n        _turtleRawY = y;\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        _updateSpriteAppearance();\n    }\n    //% block=\"setpos x %x y %y\" group=\"Movement\" weight=59 blockHidden=true\n    export function setpos(x: number, y: number): void { goto(x, y); }\n    //% block=\"setposition x %x y %y\" group=\"Movement\" weight=58 blockHidden=true\n    export function setposition(x: number, y: number): void { goto(x, y); }\n\n\n    //% block=\"set heading %to_angle degrees\"\n    //% blockAlias=seth\n    //% to_angle.defl=0\n    //% group=\"Movement\" weight=50\n    export function setheading(to_angle: number): void {\n        _ensureTurtleExists();\n        _currentHeading = to_angle;\n        _updateSpriteAppearance();\n    }\n    //% block=\"seth %to_angle degrees\" group=\"Movement\" weight=49 blockHidden=true\n    export function seth(to_angle: number): void { setheading(to_angle); }\n\n    //% block=\"home\"\n    //% group=\"Movement\" weight=40\n    export function home(): void {\n        _ensureTurtleExists();\n        _turtleRawX = 0;\n        _turtleRawY = 0;\n        _currentHeading = 0; // Home reseta para 0 graus (direita) por padrão\n        _turtleSprite.setPosition(_turtleToScreenX(_turtleRawX), _turtleToScreenY(_turtleRawY));\n        _updateSpriteAppearance();\n    }\n\n    //% block=\"speed %speedValue (0-10)\"\n    //% speedValue.min=0 speedValue.max=10 speedValue.defl=6\n    //% group=\"Movement\" weight=30\n    export function speed(speedValue: number): void {\n        _ensureTurtleExists();\n        _turtleSpeed = Math.clamp(0, 10, Math.round(speedValue));\n    }\n\n    // --- Pen Control ---\n\n    //% block=\"pen down\"\n    //% blockAlias=pd,down\n    //% group=\"Pen Control\" weight=100\n    export function pendown(): void {\n        _ensureTurtleExists();\n        _isPenDown = true;\n    }\n    //% block=\"pd\" group=\"Pen Control\" weight=99 blockHidden=true\n    export function pd(): void { pendown(); }\n    //% block=\"down\" group=\"Pen Control\" weight=98 blockHidden=true\n    export function down(): void { pendown(); }\n\n    //% block=\"pen up\"\n    //% blockAlias=pu,up\n    //% group=\"Pen Control\" weight=90\n    export function penup(): void {\n        _ensureTurtleExists();\n        _isPenDown = false;\n    }\n    //% block=\"pu\" group=\"Pen Control\" weight=89 blockHidden=true\n    export function pu(): void { penup(); }\n    //% block=\"up\" group=\"Pen Control\" weight=88 blockHidden=true\n    export function up(): void { penup(); }\n\n    //% block=\"pen color %color=colorindexpicker\"\n    //% color.defl=1\n    //% group=\"Pen Control\" weight=80\n    export function pencolor(color: number): void {\n        _ensureTurtleExists();\n        _penColor = color;\n    }\n\n    //% block=\"is pen down?\"\n    //% group=\"Pen Control\" weight=70\n    export function isdown(): boolean {\n        _ensureTurtleExists();\n        return _isPenDown;\n    }\n\n    //% block=\"pen size %widthNum\"\n    //% blockAlias=width\n    //% widthNum.min=1 widthNum.defl=1\n    //% group=\"Pen Control\" weight=60\n    export function pensize(widthNum: number): void {\n        _ensureTurtleExists();\n        _penThickness = Math.max(1, Math.round(widthNum));\n    }\n    //% block=\"width %widthNum\" group=\"Pen Control\" weight=59 blockHidden=true\n    export function width(w: number): void { pensize(w); }\n\n\n    // --- Turtle State ---\n\n    //% block=\"heading\"\n    //% group=\"Turtle State\" weight=100\n    export function heading(): number {\n        _ensureTurtleExists();\n        return (_currentHeading % 360 + 360) % 360;\n    }\n\n    //% block=\"position\"\n    //% blockAlias=pos\n    //% group=\"Turtle State\" weight=90\n    export function position(): { x: number, y: number } {\n        _ensureTurtleExists();\n        return { x: Math.round(_turtleRawX), y: Math.round(_turtleRawY) };\n    }\n    //% block=\"pos\" group=\"Turtle State\" weight=89 blockHidden=true\n    export function pos(): { x: number, y: number } { return position(); }\n\n    //% block=\"x coordinate\"\n    //% group=\"Turtle State\" weight=80\n    export function xcor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawX);\n    }\n\n    //% block=\"y coordinate\"\n    //% group=\"Turtle State\" weight=70\n    export function ycor(): number {\n        _ensureTurtleExists();\n        return Math.round(_turtleRawY);\n    }\n\n    //% block=\"show turtle\"\n    //% blockAlias=st\n    //% group=\"Turtle State\" weight=60\n    export function showturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = true;\n        _updateSpriteAppearance();\n    }\n    //% block=\"st\" group=\"Turtle State\" weight=59 blockHidden=true\n    export function st(): void { showturtle(); }\n\n    //% block=\"hide turtle\"\n    //% blockAlias=ht\n    //% group=\"Turtle State\" weight=50\n    export function hideturtle(): void {\n        _ensureTurtleExists();\n        _isTurtleVisible = false;\n        if (_turtleSprite) {\n            _turtleSprite.setFlag(SpriteFlag.Invisible, true);\n        }\n    }\n    //% block=\"ht\" group=\"Turtle State\" weight=49 blockHidden=true\n    export function ht(): void { hideturtle(); }\n\n    //% block=\"is turtle visible?\"\n    //% group=\"Turtle State\" weight=40\n    export function isvisible(): boolean {\n        _ensureTurtleExists();\n        return _isTurtleVisible;\n    }\n\n    // --- Drawing Control ---\n    //% block=\"clear drawings\"\n    //% group=\"Drawing Control\" weight=100\n    export function clear(): void {\n        scene.backgroundImage().fill(scene.backgroundColor());\n    }\n\n    //% block=\"reset turtle\"\n    //% group=\"Drawing Control\" weight=90\n    export function reset(): void {\n        if (_turtleSprite) {\n            _turtleSprite.destroy();\n            _turtleSprite = null;\n        }\n        scene.backgroundImage().fill(scene.backgroundColor());\n        _ensureTurtleExists();\n    }\n\n    _ensureTurtleExists();\n}","main.py":"# Vermelho\nturtle.pencolor(2)\nfor index in range(4):\n    turtle.forward(30)\n    turtle.left(90)","images.g.jres":"{\n    \"image1\": {\n        \"data\": \"hwQPABAAAAAAAAB3AAAAAAAAcHcAAHAHAAB3AAAAdwcAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwcAAHB3AABwBwAAAHcAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp\"\n    },\n    \"image2\": {\n        \"data\": \"hwQPABAAAAAAAAAAdwAAAHAHAAB3BwAAcHcAAAB3AAAAd2dmZncAAABwZmZmBgAAAGBmZmZmcAcAZ2ZmZmZ3dwBnZmZmZnd3AGBmZmZmcAcAcGZmZgYAAAB3Z2ZmdwAAcHcAAAB3AABwBwAAdwcAAAAAAAB3AAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleDown\"\n    },\n    \"image3\": {\n        \"data\": \"hwQQAA8AAAAAAAAAAAAAAHAHAAAAcAcAcHcAdwB3BwAAd2dmdncAAABwZmZmBwAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAd2BmZmYGdwB3YGZmZgZ3AHB3ZmZmdwcAAHdgZgZ3AAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleRight\"\n    },\n    \"image4\": {\n        \"data\": \"hwQQAA8AAAAAAAB3AAAAAAAAcHcHAAAAAABwdwcAAAAAAAB3AAAAAAB3YGYGdwAAcHdmZmZ3BwB3YGZmZgZ3AHdgZmZmBncAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAHBmZmYHAAAAd2dmdncAAHB3AHcAdwcAcAcAAABwBwAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleLeft\"\n    },\n    \"image5\": {\n        \"data\": \"hwQPABAAAAAAdwAAAAAAAAB3dwAAAAAAAAB3AAAAdwAAAHdmZnZ3AAAAYGZmZgcAcAdmZmZmBgB3d2ZmZmZ2AHd3ZmZmZnYAcAdmZmZmBgAAAGBmZmYHAAAAd2ZmdncAAAB3AAAAdwAAd3cAAAAAAAB3AAAAAAAAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleUp0\"\n    },\n    \"image6\": {\n        \"data\": \"hwQPABAAAAAAAAAAAAB3AAAAAAAAd3cAAHcAAAB3AAAAd2dmZncAAABwZmZmBgAAAGBmZmZmcAcAZ2ZmZmZ3dwBnZmZmZnd3AGBmZmZmcAcAcGZmZgYAAAB3Z2ZmdwAAAHcAAAB3AAAAAAAAAHd3AAAAAAAAAHcAAAAAAAAAAAA=\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleDown0\"\n    },\n    \"image7\": {\n        \"data\": \"hwQQAA8AAAAAAAB3AAAAAAAAcHcHAAAAdwBwdwcAdwB3AAB3AAB3AHB3YGYGdwcAcHdmZmZ3BwAAYGZmZgYAAABgZmZmBgAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAHBmZmYHAAAAd2dmdncAAAB3AHcAdwAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleLeft0\"\n    },\n    \"image8\": {\n        \"data\": \"hwQQAA8AAAAAAAAAAAAAAAAAAAAAAAAAAHcAdwB3AAAAd2dmdncAAABwZmZmBwAAAGBmZmYGAAAAYGZmZgYAAABgZmZmBgAAAGBmZmYGAAAAYGZmZgYAAHB3ZmZmdwcAcHdgZgZ3BwB3AAB3AAB3AHcAcHcHAHcAAABwdwcAAAAAAAB3AAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"turtleRight0\"\n    },\n    \"image9\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"displayName\": \"nome\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myImages\"\n    }\n}","images.g.ts":"","tilemap.g.jres":"{\n    \"transparency16\": {\n        \"data\": \"hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==\",\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"tilemapTile\": true\n    },\n    \"level1\": {\n        \"id\": \"level1\",\n        \"mimeType\": \"application/mkcd-tilemap\",\n        \"data\": \"MTAwYTAwMDgwMDAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMTAxMDEwMTAxMDEwMTAyMDIwMjAxMDIwMjAyMDIwMTAxMDEwMjAyMDEwMTAxMDEwMTAxMDEwMTAyMDIwMTAyMDIwMTAxMDIwMTAxMDIwMjAxMDEwMTAxMDEwMjAxMDEwMjAyMDEwMTAxMDEwMTAyMDEwMzAyMDIwMjAyMDIwMjAyMDIwMjAyMDIyMjIyMjIyMjIyMDIwMDAwMDAyMjAyMjIyMjAwMjAwMjAwMDAwMDIwMDIyMjAwMDIyMDAyMDAwMDAyMjAwMjAwMDAwMjIwMjIyMjIyMjIyMg==\",\n        \"tileset\": [\n            \"myTiles.transparency16\",\n            \"sprites.castle.tilePath5\",\n            \"sprites.builtin.forestTiles0\",\n            \"sprites.swamp.swampTile13\"\n        ],\n        \"displayName\": \"level1\"\n    },\n    \"*\": {\n        \"mimeType\": \"image/x-mkcd-f4\",\n        \"dataEncoding\": \"base64\",\n        \"namespace\": \"myTiles\"\n    }\n}","tilemap.g.ts":"","pxt.json":"{\n    \"name\": \"Turtle\",\n    \"version\": \"0.0.1\",\n    \"description\": \"Uma extensão para simular gráficos Turtle no MakeCode Arcade.\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"turtle.ts\",\n        \"main.py\",\n        \"images.g.jres\",\n        \"images.g.ts\",\n        \"tilemap.g.jres\",\n        \"tilemap.g.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1749322352612}